<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title></title>
    <url>/2021/11/30/Deep%20Attention%20Diffusion%20Graph%20Neural%20Networks%20for%20Text%20Classification/</url>
    <content><![CDATA[<h1 id="Deep-Attention-Diffusion-Graph-Neural-Networks-for-Text-Classification"><a href="#Deep-Attention-Diffusion-Graph-Neural-Networks-for-Text-Classification" class="headerlink" title="Deep Attention Diffusion Graph Neural Networks for Text Classification"></a>Deep Attention Diffusion Graph Neural Networks for Text Classification</h1><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>​        文本分类是自然语言处理中具有广泛应用的一项基本任务。近年来，图神经网络(GNN)以其强大的表示能力引起了人们的广泛关注。然而，现有的基于GNN的文本分类方法大多只考虑文本中的单跳邻域和低频信息，不能充分利用文本丰富的上下文信息。此外，如果有许多图层堆叠在一起，这些模型就会遇到过度平滑的问题。本文提出了一种深度注意力扩散图神经网络(DADGNN)模型来学习文本表示，以弥合单词与相邻单词之间交互困难的鸿沟。在各种标准基准数据集上的实验结果表明，该方法具有良好的性能。</p>
<p>​        文本分类作为自然语言处理领域的一项重要而基础的任务，多年来受到了学者们的广泛关注，并被广泛应用于各种实际应用中，如话题标记、计算表型、问题回答和对话表演分类。文本分类的性能在很大程度上依赖于模型从原始文本中提取文本特征的能力。以往基于浅层学习的文本分类方法主要使用手工制作的稀疏词汇特征，如词袋模型(BoW)或n-grams来表示文本。由于这些特征是预定义的，因此模型没有充分利用大量的训练数据。以卷积神经网络(CNNs) (Kim, 2014)和循环神经网络(RNNs) 为代表的深度学习架构由于其在文本挖掘方面的强大性能而变得越来越受欢迎。这些模型可以很好地捕获局部连续词序列中的语义和句法信息。</p>
<p>​         近年来，图神经网络(gnn)因其在处理复杂结构化数据和关系方面的优势而受到越来越多的关注。由于gnn具有强大的表征能力，在对具有图结构的文本建模时，gnn在文本分类任务中取得了很好的结果。尽管上述模型取得了成功，但gnn存在一些严重的局限性，这主要是由于以下因素:(1)接受域受限。以前的大多数方法允许图表中的一个单词直接访问邻近区域。换句话说，单词的嵌入仅仅依赖于其相邻单词在每一层上的表示的影响。此外，用于构建单词边缘的滑动窗口通常并不大。这使得远程单词交互成为不可能。因此，增加目标词的接受域是获得精确文本表示的关键。(2)浅层次。目前大多数基于图的文本分类模型都采用了相当浅的设置，因为它们在两层的情况下获得了最好的性能。两层图模型聚集了两跳邻居中的节点，因此不能提取超过两跳邻居的信息。理论上，我们可以通过大量的层捕获单词之间的长期依赖关系。然而，大多数gnn面临的一个共同挑战是，当叠加多个层以利用更大的接收场时，性能会严重下降。一些研究人员将这种现象归因于过度平滑(无法区分不同类型节点的表示)。由于可获得的上下文信息有限，在文本分类任务中仍然需要探索更深层次的gnn来获取更多的潜在特征，特别是对于短文本。(三)非精确的文档级表示。大多数基于图的文本分类模型利用简单的池操作(例如对图中的所有节点求和或平均)来获得文档级表示。这削弱了一些关键节点的效果，显著降低了模型的表现力，因为不同的单词在文本中扮演着不同的角色。(四)低通滤波器。本质上，现有的基于图的文本分类方法是固定系数的低通滤波器。已经证实，gnn中的low-pass滤波器主要保持了节点特征的通用性，忽略了它们之间的差异。因此，当总是采用低通滤波器时，学习到的连接节点表示变得不可区分。同时，一些研究已经证明了图信号中的高频信息可以增强模型的分辨能力，特别是当网络表现出非分类性时。因此，有必要设计一个过滤器，它不仅表现出低通特性学习单词嵌入。</p>
<p>​        为了克服上述局限性，我们提出了一种基于学习到的有效文本表示的深度注意扩散图神经网络(DADGNN)模型用于文本分类。具体地说，我们利用注意扩散技术来扩大文档中每个词的接受域，从而捕获每个层的长范围词交互。此外，为了提取词语的深层隐藏语义，我们对gnn的传播和转换过程进行解耦，以训练更深层次的网络。最后，我们计算每个节点的权重，以获得精确的文档级表示。我们的工作主要贡献如下:</p>
<ul>
<li>我们引入了一种新的基于注意扩散和解耦技术的模型DADGNN，该模型对建模文档具有良好的表达能力，克服了传统基于图的模型的局限性。</li>
<li>我们从理论上证明了注意力扩散操作等效于一个可以同时利用高、低频图信号的多项式图滤波器。</li>
<li>我们在一系列基准数据集上进行了广泛的实验，DADGNN最先进的性能说明了它与其他竞争性基准模型相比的优越性。</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>Graph Random Neural Networks for Semi-Supervised Learning on Graphs</title>
    <url>/2021/12/09/Graph-Random-Neural-Networks-for-Semi-Supervised-Learning-on-Graphs/</url>
    <content><![CDATA[<h1 id="Graph-Random-Neural-Networks-for-Semi-Supervised-Learning-on-Graphs"><a href="#Graph-Random-Neural-Networks-for-Semi-Supervised-Learning-on-Graphs" class="headerlink" title="Graph Random Neural Networks for Semi-Supervised Learning on Graphs"></a>Graph Random Neural Networks for Semi-Supervised Learning on Graphs</h1><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>图神经网络已被广泛研究。然而，现有的大多数GNN模型本身存在过度平滑、缺乏鲁棒性和标记节点较少时泛化能力差的问题。在本文中，我们提出了一个简单而有效的框架-图随机神经网络(GRAND)来解决这些问题。在GRAND中，我们首先设计一个随机传播策略来执行图数据增强。然后我们利用一致性正则化来优化跨不同数据扩展的未标记节点的预测一致性。在图基准数据集上的大量实验表明，在半监督节点分类方面，GRAND显著优于最先进的GNN基线。最后，我们证明了GRAND缓解了过度平滑和非鲁棒性的问题，表现出比现有GNN更好的泛化行为。</p>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>图卷积操作是拉普拉斯平滑的一种特殊形式，因此，叠加许多GNN层往往会使节点的特征难以区分。此外，最近的工作表明在传播过程中耦合非线性变换会进一步加剧这一问题。其次，GNN通常对图攻击不具有鲁棒性，这是因为它们大多采用确定性传播。确定性传播使得每个节点高度依赖于它的邻域，使得节点很容易被潜在的数据噪声误导，并容易受到干扰。</p>
<p>第三个问题在于半监督学习的一般设置，其中标准的训练方法很容易过拟合稀缺的标签信息。为了解决这一广泛存在的问题，大多数方法都集中在如何利用大量未标记数据。在计算机视觉中，最近的一些尝试，如Mix Match , UDA，通过设计一致性正则化训练的数据增强方法来解决这一问题，在半监督图像分类任务中取得了很大的成功。这启发我们将这一想法应用到GNN中，以促进图的半监督学习。</p>
<p>在这项工作中，我们通过设计半监督学习的图数据增强和一致性正则化策略来解决这些问题。具体来说，我们提出了图随机神经网络(GRAND)，一个简单而强大的基于图的半监督学习框架。</p>
<p>为了有效地增加图数据，我们在GRAND中提出随机传播，其中每个节点的特征可以被随机地部分(dropout)或全部删除，然后将被扰动的特征矩阵传播到图上。因此，每个节点都可以对特定的邻居不敏感，从而增加了GRAND的健壮性。此外，随机传播的设计可以自然地分离特征传播和变换，这在大多数GNN中通常是相互耦合的。这使GRAND能够安全地执行高阶特性传播，而不会增加复杂性，从而减少了对GRAND进行过度平滑的风险。更重要的是，随机传播允许每个节点随机地将消息传递给它的邻域。在图数据同质性的假设下，我们能够随机地为每个节点生成不同的增广表示。然后，我们利用一致性正则化来加强预测模型，例如，一个简单的多层感知机，在相同的未标记数据的不同扩展上输出相似的预测，提高了GRAND在半监督设置下的泛化行为。</p>
<p>最后，我们从理论上说明了随机传播和一致性正则化可以增强每个节点及其多跳邻域之间的分类可信度的一致性。在经验上，我们还表明，这两种策略都可以提高GRAND的泛化能力，并缓解现有GNN普遍面临的非鲁棒性和过度平滑问题。总之，大量的实验表明，GRAND在GNN基准数据集上实现了最先进的半监督学习结果</p>
]]></content>
      <categories>
        <category>论文</category>
        <category>文本分类</category>
      </categories>
      <tags>
        <tag>论文</tag>
      </tags>
  </entry>
  <entry>
    <title>Residual Correlation in Graph Neural Network Regression</title>
    <url>/2021/09/08/Residual-Correlation-in-Graph-Neural-Network-Regression/</url>
    <content><![CDATA[<h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>​        图神经网络将每个顶点的邻域特征转换为顶点的向量表示。然后，每个顶点的表示被独立地用于预测它的标签。这个标准的处理方式隐含地假设顶点标签在给定其邻域特征的情况下是有条件独立的。然而，这是一个强烈的假设，我们表明，在许多真实的图数据集上，这是远远不正确的。<strong>在回归任务中，我们发现这种条件独立假设严重限制了预测能力</strong>。这并不奇怪，因为传统的基于图的半监督学习方法，如标签传播，通过明确地建模预测结果的相关性，它是以相反的方式工作。</p>
<p>​        在这里，我们用一个可解释和有效的框架来解决这个问题，这个框架可以通过简单地利用回归残差中的相关结构来改进任何图神经网络的结构。<strong>具体地说，我们用参数化的多元高斯模型对残差在顶点上的联合分布进行建模，并通过最大化观测标签的边际似然函数来估计参数</strong>。我们的框架实现了比竞争基线更高的精度，学习到的参数可以解释为连接顶点之间的相关性强度。此外，我们开发了低方差、无偏模型参数估计的线性时间算法，允许我们扩展到大型网络。我们还提供了我们方法的一个基本版本，该版本对相关结构做了更强的假设，但实现起来很轻松，通常以最小的开销获得很大的实际性能。</p>
]]></content>
      <categories>
        <category>图神经网络</category>
      </categories>
  </entry>
  <entry>
    <title>MySQL</title>
    <url>/2021/11/04/MySQL/</url>
    <content><![CDATA[<h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><p>什么是数据库？什么是数据库管理系统？什么是SQL？他们之间的关系是什么？</p>
<span id="more"></span>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">数据库：</span><br><span class="line">	英文单词DataBase，简称DB。按照一定格式存储数据的一些文件的组合。</span><br><span class="line">	顾名思义：存储数据的仓库，实际上就是一堆文件。这些文件中存储了具有特定格式的数据。</span><br><span class="line">数据库管理系统：</span><br><span class="line">		DataBaseManagement，简称DBMS。</span><br><span class="line">		数据库管理系统是专门用来管理数据库中数据的，数据库管理系统可以对数据库当中的数据进行增删改查。</span><br><span class="line">常见的数据库管理系统：</span><br><span class="line">		MySQL、Oracle、MS SqlServer、DB2、sybase等....</span><br></pre></td></tr></table></figure>

<h1 id="SQL：结构化查询语言"><a href="#SQL：结构化查询语言" class="headerlink" title="SQL：结构化查询语言"></a>SQL：结构化查询语言</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">程序员需要学习SQL语句，程序员通过编写SQL语句，然后DBMS负责执行SQL语句，最终来完成数据库中数据的增删改查操作。</span><br><span class="line">SQL是一套标准，程序员主要学习的就是SQL语句，这个SQL在mysql中可以使用</span><br><span class="line">同时在Oracle中也可以使用，在DB2中也可以使用。</span><br><span class="line"></span><br><span class="line">三者之间的关系？</span><br><span class="line">	DBMS--执行--&gt; SQL --操作--&gt; DB</span><br><span class="line"></span><br><span class="line">先安装数据库管理系统MySQL，然后学习SQL语句怎么写，编写SQL语句之后，DBMS</span><br><span class="line">对SQL语句进行执行，最终来完成数据库的数据管理。</span><br></pre></td></tr></table></figure>

<h2 id="关于SQL语句的分类"><a href="#关于SQL语句的分类" class="headerlink" title="关于SQL语句的分类"></a>关于SQL语句的分类</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SQL语句有很多，最好进行分门别类，这样更容易记忆。</span><br><span class="line">	分为：</span><br><span class="line">	DQL：</span><br><span class="line">		数据查询语言（凡是带有select关键字的都是查询语句）</span><br><span class="line">		select...</span><br><span class="line"></span><br><span class="line">	DML：</span><br><span class="line">		数据操作语言（凡是对表当中的数据进行增删改的都是DML）</span><br><span class="line">		insert delete update</span><br><span class="line">		insert 增</span><br><span class="line">		delete 删</span><br><span class="line">		update 改</span><br><span class="line">		这个主要是操作表中的数据data。</span><br><span class="line"></span><br><span class="line">	DDL：</span><br><span class="line">		数据定义语言</span><br><span class="line">		凡是带有create、drop、alter的都是DDL。</span><br><span class="line">		DDL主要操作的是表的结构。不是表中的数据。</span><br><span class="line">		create：新建，等同于增</span><br><span class="line">		drop：删除</span><br><span class="line">		alter：修改</span><br><span class="line">		这个增删改和DML不同，这个主要是对表结构进行操作。</span><br><span class="line"></span><br><span class="line">	TCL：</span><br><span class="line">		是事务控制语言</span><br><span class="line">		包括：</span><br><span class="line">		事务提交：commit;</span><br><span class="line">		事务回滚：rollback;</span><br><span class="line"></span><br><span class="line">	DCL：</span><br><span class="line">		是数据控制语言。</span><br><span class="line">		例如：授权grant、撤销权限revoke....</span><br></pre></td></tr></table></figure>

<h1 id="MySQL常用命令"><a href="#MySQL常用命令" class="headerlink" title="MySQL常用命令"></a>MySQL常用命令</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">退出mysql ：exit;</span><br><span class="line"></span><br><span class="line">查看mysql中有哪些数据库 : show databases;  #注意：以分号结尾，分号是英文的分号。</span><br><span class="line">mysql&gt; show databases;</span><br><span class="line">	+--------------------+</span><br><span class="line">	| Database           |</span><br><span class="line">	+--------------------+</span><br><span class="line">	| information_schema |</span><br><span class="line">	| mysql              |</span><br><span class="line">	| performance_schema |</span><br><span class="line">	| test               |</span><br><span class="line">	+--------------------+</span><br><span class="line">	mysql默认自带了4个数据库。</span><br><span class="line">	</span><br><span class="line">选择使用某个数据库:</span><br><span class="line">mysql&gt; use test;</span><br><span class="line">	Database changed</span><br><span class="line">	表示正在使用一个名字叫做test的数据库。</span><br><span class="line"></span><br><span class="line">创建数据库:</span><br><span class="line">mysql&gt; create database bjpowernode;</span><br><span class="line">	Query OK, 1 row affected (0.00 sec)</span><br><span class="line">mysql&gt; show databases;</span><br><span class="line">		+--------------------+</span><br><span class="line">		| Database           |</span><br><span class="line">		+--------------------+</span><br><span class="line">		| information_schema |</span><br><span class="line">		| bjpowernode        |</span><br><span class="line">		| mysql              |</span><br><span class="line">		| performance_schema |</span><br><span class="line">		| test               |</span><br><span class="line">		+--------------------+</span><br><span class="line">		</span><br><span class="line">查看某个数据库下有哪些表:</span><br><span class="line">mysql&gt; show tables;</span><br><span class="line"></span><br><span class="line">查看mysql数据库的版本号：</span><br><span class="line">mysql&gt; select version();</span><br><span class="line">		+-----------+</span><br><span class="line">		| version() |</span><br><span class="line">		+-----------+</span><br><span class="line">		| 5.5.36    |</span><br><span class="line">		+-----------+</span><br><span class="line">		</span><br><span class="line">查看当前使用的是哪个数据库:</span><br><span class="line">mysql&gt; select database();</span><br><span class="line">	+-------------+</span><br><span class="line">	| database()  |</span><br><span class="line">	+-------------+</span><br><span class="line">	| bjpowernode |</span><br><span class="line">	+-------------+</span><br><span class="line"></span><br><span class="line">导入一下提前准备好的数据：bjpowernode.sql 这个文件中是练习准备的数据库表。</span><br><span class="line">怎么将sql文件中的数据导入</span><br><span class="line">mysql&gt; source D:\course\03-MySQL\document\bjpowernode.sql #注意：路径中不要有中文！！！！</span><br><span class="line"></span><br><span class="line">查看表的结构：</span><br><span class="line">mysql&gt; desc dept; # describe缩写为：desc</span><br><span class="line">+--------+-------------+------+-----+---------+-------+</span><br><span class="line">| Field  | Type        | Null | Key | Default | Extra |</span><br><span class="line">+--------+-------------+------+-----+---------+-------+</span><br><span class="line">| DEPTNO | int(2)      | NO   | PRI | NULL    |       |部门编号</span><br><span class="line">| DNAME  | varchar(14) | YES  |     | NULL    |       |部门名字</span><br><span class="line">| LOC    | varchar(13) | YES  |     | NULL    |       |地理位置</span><br><span class="line">+--------+-------------+------+-----+---------+-------+</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="数据库表"><a href="#数据库表" class="headerlink" title="数据库表"></a>数据库表</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">数据库当中最基本的单元是表：table</span><br><span class="line"></span><br><span class="line">	什么是表table？为什么用表来存储数据呢？</span><br><span class="line"></span><br><span class="line">		姓名	性别	年龄(列：字段) </span><br><span class="line">		---------------------------</span><br><span class="line">		张三	男			20            -------&gt;行（记录）</span><br><span class="line">		李四	女			21            -------&gt;行（记录）</span><br><span class="line">		王五	男			22            -------&gt;行（记录）</span><br><span class="line">	</span><br><span class="line">	数据库当中是以表格的形式表示数据的。因为表比较直观。</span><br><span class="line"></span><br><span class="line">	任何一张表都有行和列：</span><br><span class="line">		行（row）：被称为数据/记录。</span><br><span class="line">		列（column）：被称为字段。</span><br><span class="line">        </span><br><span class="line">	姓名字段、性别字段、年龄字段。</span><br><span class="line"></span><br><span class="line">	了解一下：</span><br><span class="line">		每一个字段都有：字段名、数据类型、约束等属性。字段名可以理解，是一个普通的名字，见名知意就行。</span><br><span class="line">		数据类型：字符串，数字，日期等，后期讲。</span><br><span class="line">		约束：约束也有很多，其中一个叫做唯一性约束，这种约束添加之后，该字段中的数据不能重复。		</span><br></pre></td></tr></table></figure>

<h1 id="查询：select"><a href="#查询：select" class="headerlink" title="查询：select"></a>查询：select</h1><h2 id="简单查询"><a href="#简单查询" class="headerlink" title="简单查询"></a>简单查询</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">查询一个字段？</span><br><span class="line">select 字段名 from 表名; </span><br><span class="line"># 其中要注意：select和from都是关键字。</span><br><span class="line"># 字段名和表名都是标识符。</span><br><span class="line"></span><br><span class="line">强调：对于SQL语句来说，是通用的，所有的SQL语句以“;”结尾。</span><br><span class="line">	 另外SQL语句不区分大小写，都行。</span><br><span class="line"></span><br><span class="line">查询两个字段，或者多个字段使用逗号隔开“,”</span><br><span class="line">查询部门编号和部门名</span><br><span class="line">select deptno,dname from dept;</span><br><span class="line">    +--------+------------+</span><br><span class="line">    | deptno | dname      |</span><br><span class="line">    +--------+------------+</span><br><span class="line">    |     10 | ACCOUNTING |</span><br><span class="line">    |     20 | RESEARCH   |</span><br><span class="line">    |     30 | SALES      |</span><br><span class="line">    |     40 | OPERATIONS |</span><br><span class="line">    +--------+------------+</span><br><span class="line">    </span><br><span class="line">查询所有字段</span><br><span class="line">第一种方式：可以把每个字段都写上</span><br><span class="line">	select a,b,c,d,e,f... from tablename;</span><br><span class="line"></span><br><span class="line">第二种方式：可以使用*</span><br><span class="line">	select * from dept;</span><br><span class="line">		+--------+------------+----------+</span><br><span class="line">		| DEPTNO | DNAME      | LOC      |</span><br><span class="line">		+--------+------------+----------+</span><br><span class="line">        |     10 | ACCOUNTING | NEW YORK |</span><br><span class="line">        |     20 | RESEARCH   | DALLAS   |</span><br><span class="line">        |     30 | SALES      | CHICAGO  |</span><br><span class="line">        |     40 | OPERATIONS | BOSTON   |</span><br><span class="line">        +--------+------------+----------+</span><br><span class="line"></span><br><span class="line">    这种方式的缺点：</span><br><span class="line">        1、效率低</span><br><span class="line">        2、可读性差。</span><br><span class="line">    在实际开发中不建议，可以自己玩没问题。</span><br><span class="line">    你可以在DOS命令窗口中想快速的看一看全表数据可以采用这种方式。</span><br><span class="line"></span><br><span class="line">给查询的列起别名：使用as关键字起别名。</span><br><span class="line">  mysql&gt; select deptno,dname as deptname from dept;</span><br><span class="line">      +--------+------------+</span><br><span class="line">      | deptno | deptname   |</span><br><span class="line">      +--------+------------+</span><br><span class="line">      |     10 | ACCOUNTING |</span><br><span class="line">      |     20 | RESEARCH   |</span><br><span class="line">      |     30 | SALES      |</span><br><span class="line">      |     40 | OPERATIONS |</span><br><span class="line">      +--------+------------+</span><br><span class="line">  注意：只是将显示的查询结果列名显示为deptname，原表列名还是叫：dname</span><br><span class="line">  记住：select语句是永远都不会进行修改操作的。（因为只负责查询）</span><br><span class="line"></span><br><span class="line">  as关键字可以省略吗？可以的</span><br><span class="line">    mysql&gt; select deptno,dname deptname from dept;</span><br><span class="line">    </span><br><span class="line">假设起别名的时候，别名里面有空格，怎么办？   </span><br><span class="line">select deptno,dname &#x27;dept name&#x27; from dept; //加单引号</span><br><span class="line">select deptno,dname &quot;dept name&quot; from dept; //加双引号</span><br><span class="line">      +--------+------------+</span><br><span class="line">      | deptno | dept name  |</span><br><span class="line">      +--------+------------+</span><br><span class="line">      |     10 | ACCOUNTING |</span><br><span class="line">      |     20 | RESEARCH   |</span><br><span class="line">      |     30 | SALES      |</span><br><span class="line">      |     40 | OPERATIONS |</span><br><span class="line">      +--------+------------+</span><br><span class="line">注意：在所有的数据库当中，字符串统一使用单引号括起来，单引号是标准，双引号在oracle数据库中用不了。但是在mysql中可以使用。</span><br></pre></td></tr></table></figure>

<h2 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h2><p>条件查询：不是将表中所有数据都查出来。是查询出来符合条件的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">查询语法格式：</span><br><span class="line">    select</span><br><span class="line">      字段1,字段2,字段3....</span><br><span class="line">    from </span><br><span class="line">      表名</span><br><span class="line">    where</span><br><span class="line">      条件;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">都有哪些条件？</span><br><span class="line">= 等于</span><br><span class="line">查询薪资等于800的员工姓名和编号？</span><br><span class="line">  select empno,ename from emp where sal = 800;</span><br><span class="line">查询SMITH的编号和薪资？</span><br><span class="line">  select empno,sal from emp where ename = &#x27;SMITH&#x27;; //字符串使用单引号</span><br><span class="line"></span><br><span class="line">&lt;&gt; 或!= 不等于</span><br><span class="line">查询薪资不等于800的员工姓名和编号？</span><br><span class="line">  select empno,ename from emp where sal != 800;</span><br><span class="line">  select empno,ename from emp where sal &lt;&gt; 800; // 小于号和大于号组成的不等号</span><br><span class="line">  </span><br><span class="line">&lt; 小于</span><br><span class="line">查询薪资小于2000的员工姓名和编号？</span><br><span class="line">  mysql&gt; select empno,ename,sal from emp where sal &lt; 2000;</span><br><span class="line">  +-------+--------+---------+</span><br><span class="line">  | empno | ename  | sal     |</span><br><span class="line">  +-------+--------+---------+</span><br><span class="line">  |  7369 | SMITH  |  800.00 |</span><br><span class="line">  |  7499 | ALLEN  | 1600.00 |</span><br><span class="line">  |  7521 | WARD   | 1250.00 |</span><br><span class="line">  +-------+--------+---------+</span><br><span class="line"></span><br><span class="line">&lt;= 小于等于</span><br><span class="line">查询薪资小于等于3000的员工姓名和编号？</span><br><span class="line">  select empno,ename,sal from emp where sal &lt;= 3000;</span><br><span class="line"></span><br><span class="line">&gt; 大于</span><br><span class="line">查询薪资大于3000的员工姓名和编号？</span><br><span class="line">  select empno,ename,sal from emp where sal &gt; 3000;</span><br><span class="line"></span><br><span class="line">&gt;= 大于等于</span><br><span class="line">查询薪资大于等于3000的员工姓名和编号？</span><br><span class="line">  select empno,ename,sal from emp where sal &gt;= 3000;</span><br><span class="line"></span><br><span class="line">between … and …. 两个值之间, 等同于 &gt;= and &lt;=</span><br><span class="line">查询薪资在2450和3000之间的员工信息？包括2450和3000</span><br><span class="line">  第一种方式：&gt;= and &lt;= （and是并且的意思。）</span><br><span class="line">    select empno,ename,sal from emp where sal &gt;= 2450 and sal &lt;= 3000;</span><br><span class="line">    +-------+-------+---------+</span><br><span class="line">    | empno | ename | sal     |</span><br><span class="line">    +-------+-------+---------+</span><br><span class="line">    |  7566 | JONES | 2975.00 |</span><br><span class="line">    |  7698 | BLAKE | 2850.00 |</span><br><span class="line">    |  7782 | CLARK | 2450.00 |</span><br><span class="line">    |  7788 | SCOTT | 3000.00 |</span><br><span class="line">    |  7902 | FORD  | 3000.00 |</span><br><span class="line">    +-------+-------+---------+</span><br><span class="line">  第二种方式：between … and …</span><br><span class="line">    select </span><br><span class="line">      empno,ename,sal </span><br><span class="line">    from </span><br><span class="line">      emp </span><br><span class="line">    where </span><br><span class="line">      sal between 2450 and 3000;</span><br><span class="line">    </span><br><span class="line">    注意：</span><br><span class="line">      使用between and的时候，必须遵循左小右大。</span><br><span class="line">      between and是闭区间，包括两端的值。</span><br><span class="line"></span><br><span class="line">is null 为 null（is not null 不为空）</span><br><span class="line">注意：在数据库当中null不能使用等号进行衡量。需要使用is null因为数据库中的null代表什么也没有，它不是一个值，所以不能使用等号衡量。</span><br><span class="line"></span><br><span class="line">and 并且 </span><br><span class="line"></span><br><span class="line">or 或者</span><br><span class="line"></span><br><span class="line">and和or同时出现的话，有优先级问题吗？</span><br><span class="line">and和or同时出现，and优先级较高。如果想让or先执行，需要加“小括号”.以后在开发中，如果不确定优先级，就加小括号就行了。</span><br><span class="line"></span><br><span class="line">in 包含，相当于多个 or （not in 不在这个范围中）</span><br><span class="line"></span><br><span class="line">not 可以取非，主要用在 is 或 in 中</span><br><span class="line"></span><br><span class="line">like 称为模糊查询，支持%或下划线匹配</span><br><span class="line"># %匹配任意多个字符</span><br><span class="line"># 下划线：任意一个字符。</span><br><span class="line">#（%是一个特殊的符号，_ 也是一个特殊符号）</span><br><span class="line"></span><br><span class="line">找出名字以T结尾的？</span><br><span class="line">  select ename from emp where ename like &#x27;%T&#x27;;</span><br><span class="line">  </span><br><span class="line">找出名字以K开始的？</span><br><span class="line">  select ename from emp where ename like &#x27;K%&#x27;;</span><br><span class="line"></span><br><span class="line">找出第二个字每是A的？</span><br><span class="line">  select ename from emp where ename like &#x27;_A%&#x27;;</span><br><span class="line"></span><br><span class="line">找出第三个字母是R的？</span><br><span class="line">  select ename from emp where ename like &#x27;__R%&#x27;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="分组查询"><a href="#分组查询" class="headerlink" title="分组查询"></a>分组查询</h2><blockquote>
<p>什么是分组查询？</p>
</blockquote>
<ul>
<li>在实际的应用中，可能有这样的需求，需要先进行分组，然后对每一组的数据进行操作，这个时候我们需要使用分组查询。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">语法格式：</span><br><span class="line">	select</span><br><span class="line">      ...</span><br><span class="line">    from</span><br><span class="line">      ...</span><br><span class="line">    group by</span><br><span class="line">      ...</span><br><span class="line"></span><br><span class="line">注意:</span><br><span class="line">select ename,job,sum(sal) from emp group by job;</span><br><span class="line">    +-------+-----------+----------+</span><br><span class="line">    | ename | job       | sum(sal) |</span><br><span class="line">    +-------+-----------+----------+</span><br><span class="line">    | SCOTT | ANALYST   |  6000.00 |</span><br><span class="line">    | SMITH | CLERK     |  4150.00 |</span><br><span class="line">    | JONES | MANAGER   |  8275.00 |</span><br><span class="line">    | KING  | PRESIDENT |  5000.00 |</span><br><span class="line">    | ALLEN | SALESMAN  |  5600.00 |</span><br><span class="line">    +-------+-----------+----------+</span><br><span class="line">以上语句在mysql中可以执行，但select后面添加ename字段没有意义。</span><br><span class="line">以上语句在oracle中执行报错。</span><br><span class="line">oracle的语法比mysql的语法严格。（mysql的语法相对来说松散一些！）</span><br><span class="line"></span><br><span class="line">重点结论：在一条select语句当中，如果有group by语句的话，select后面只能跟：参加分组的字段，以及分组函数。其它的一律不能跟。</span><br><span class="line"></span><br><span class="line">找出“每个部门，不同工作岗位”的最高薪资？</span><br><span class="line">select </span><br><span class="line">  deptno, job, max(sal)</span><br><span class="line">from</span><br><span class="line">  emp</span><br><span class="line">group by</span><br><span class="line">  deptno, job;</span><br><span class="line">技巧：两个字段联合成1个字段看。（两个字段联合分组）</span><br><span class="line"></span><br><span class="line">使用having可以对分完组之后的数据进一步过滤。</span><br><span class="line">having不能单独使用，having不能代替where，having必须和group by联合使用。</span><br><span class="line"></span><br><span class="line">where和having，优先选择where，where实在完成不了了，再选择having。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>补充一点</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">将之前的关键字全部组合在一起，来看一下他们的执行顺序？</span><br><span class="line">    select</span><br><span class="line">      	...</span><br><span class="line">    from</span><br><span class="line">     	...</span><br><span class="line">    where</span><br><span class="line">    	...</span><br><span class="line">    group by</span><br><span class="line">     	 ...</span><br><span class="line">	having</span><br><span class="line">		...</span><br><span class="line">    order by</span><br><span class="line">     	...</span><br><span class="line">以上关键字的顺序不能颠倒，需要记忆。</span><br><span class="line">执行顺序是什么？</span><br><span class="line">  1. from</span><br><span class="line">  2. where</span><br><span class="line">  3. group by</span><br><span class="line">  4. having</span><br><span class="line">  5. select</span><br><span class="line">  6. order by</span><br></pre></td></tr></table></figure>



<h1 id="排序：order-by"><a href="#排序：order-by" class="headerlink" title="排序：order by"></a>排序：order by</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">语法格式：</span><br><span class="line">	select </span><br><span class="line">		ename,sal</span><br><span class="line">	from</span><br><span class="line">		emp</span><br><span class="line">	order by</span><br><span class="line">		sal; // 默认是升序！！</span><br><span class="line">指定降序： desc</span><br><span class="line">指定升序： asc</span><br><span class="line"></span><br><span class="line">以两个字段排序吗？或者说按照多个字段排序？</span><br><span class="line">查询员工名字和薪资，要求按照薪资升序，如果薪资一样的话，再按照名字升序排列。</span><br><span class="line">select </span><br><span class="line">	ename,sal</span><br><span class="line">from</span><br><span class="line">	emp</span><br><span class="line">order by</span><br><span class="line">	sal asc, ename asc; // sal在前，起主导，只有sal相等的时候，才会考虑启用ename排序。</span><br></pre></td></tr></table></figure>

<h1 id="数据处理函数"><a href="#数据处理函数" class="headerlink" title="数据处理函数"></a>数据处理函数</h1><ul>
<li>数据处理函数又被称为单行处理函数</li>
</ul>
<h3 id="单行处理函数"><a href="#单行处理函数" class="headerlink" title="单行处理函数"></a>单行处理函数</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">单行处理函数的特点：一个输入对应一个输出。</span><br><span class="line">单行处理函数常见:</span><br><span class="line">lower 转换小写</span><br><span class="line">	mysql&gt; select lower(ename) as ename from emp;</span><br><span class="line">	</span><br><span class="line">upper 转换大写</span><br><span class="line">	mysql&gt; select upper(name) as name from t_student;</span><br><span class="line">	</span><br><span class="line">substr 取子串（substr(被截取的字符串, 起始下标,截取的长度)）</span><br><span class="line">	mysql&gt; select substr(ename, 1, 1) as ename from emp;</span><br><span class="line">	</span><br><span class="line">concat函数进行字符串的拼接</span><br><span class="line">	mysql&gt; select concat(empno,ename) from emp;</span><br><span class="line">length 取长度</span><br><span class="line">	mysql&gt; select length(ename) enamelength from emp;</span><br><span class="line">	</span><br><span class="line">trim 去空格</span><br><span class="line">	mysql&gt;	select * from emp where ename = trim(&#x27;   KING&#x27;);</span><br><span class="line">	</span><br><span class="line">str_to_date 将字符串转换成日期</span><br><span class="line"></span><br><span class="line">date_format 格式化日期</span><br><span class="line">	</span><br><span class="line">format 设置千分位</span><br><span class="line">	</span><br><span class="line">case..when..then..when..then..else..end</span><br><span class="line">当员工的工作岗位是MANAGER的时候，工资上调10%，当工作岗位是SALESMAN的时候，工资上调50%,其它正常。	（注意：不修改数据库，只是将查询结果显示为工资上调）</span><br><span class="line">select </span><br><span class="line">  ename,job, sal as oldsal,</span><br><span class="line">  (case job when &#x27;MANAGER&#x27; then sal*1.1 when &#x27;SALESMAN&#x27; then sal*1.5 else sal end) as newsal </span><br><span class="line">from </span><br><span class="line">  emp;</span><br><span class="line"></span><br><span class="line">round 四舍五入</span><br><span class="line">mysql&gt; select round(1236.567, 0) as result from emp; //保留整数位。</span><br><span class="line">mysql&gt; select round(1236.567, 1) as result from emp; //保留1个小数</span><br><span class="line">mysql&gt; select round(1236.567, 2) as result from emp; //保留2个小数</span><br><span class="line">mysql&gt; select round(1236.567, -1) as result from emp; // 保留到十位。</span><br><span class="line"></span><br><span class="line">rand() 生成随机数</span><br><span class="line">  mysql&gt; select round(rand()*100,0) from emp; // 100以内的随机数</span><br><span class="line"></span><br><span class="line">ifnull 可以将 null 转换成一个具体值</span><br><span class="line">ifnull是空处理函数。专门处理空的。在所有数据库当中，只要有NULL参与的数学运算，最终结果就是NULL。</span><br><span class="line">注意：NULL只要参与运算，最终结果一定是NULL。为了避免这个现象，需要使用ifnull函数。ifnull函数用法：ifnull(数据, 被当做哪个值)。如果“数据”为NULL的时候，把这个数据结构当做哪个值。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="分组函数（多行处理函数）"><a href="#分组函数（多行处理函数）" class="headerlink" title="分组函数（多行处理函数）"></a>分组函数（多行处理函数）</h3><p>多行处理函数特点：多个输入，对应1个输出。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">count	# 计数</span><br><span class="line">sum		# 求和</span><br><span class="line">avg		# 平均值</span><br><span class="line">max		# 最大值</span><br><span class="line">min		# 最小值</span><br><span class="line"></span><br><span class="line">注意：</span><br><span class="line">	1. 分组函数在使用的时候必须先进行分组，然后才能用。如果你没有对数据进行分组，整张表默认为一组。</span><br><span class="line">	2. 分组函数自动忽略NULL，你不需要提前对NULL进行处理。</span><br><span class="line">	3. 分组函数中count(*)和count(具体字段)有什么区别？</span><br><span class="line">		count(具体字段)：表示统计该字段下所有不为NULL的元素的总数。</span><br><span class="line">		count(*)：统计表当中的总行数。（只要有一行数据count则++）</span><br><span class="line">      	因为每一行记录不可能都为NULL，一行数据中有一列不为NULL，则这行数据就是有效的。</span><br><span class="line">    4. 分组函数不能够直接使用在where子句中。</span><br><span class="line">    5. 所有的分组函数可以组合起来一起用。</span><br></pre></td></tr></table></figure>

<h3 id="distinct"><a href="#distinct" class="headerlink" title="distinct"></a>distinct</h3><blockquote>
<p>把查询结果去除重复记录 <strong>distinct</strong> </p>
</blockquote>
<p>注意：原表数据不会被修改，只是查询结果去重。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// distinct只能出现在所有字段的最前方。</span><br><span class="line">mysql&gt; select distinct job from emp;</span><br><span class="line"></span><br><span class="line">// distinct出现在job,deptno两个字段之前，表示两个字段联合起来去重。</span><br><span class="line">mysql&gt; select distinct job,deptno from emp;</span><br></pre></td></tr></table></figure>

<h1 id="连接查询"><a href="#连接查询" class="headerlink" title="连接查询"></a>连接查询</h1><blockquote>
<p>多张表联合起来查询数据，被称为连接查询。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">根据表连接的方式分类：</span><br><span class="line">内连接： 等值连接 非等值连接 自连接</span><br><span class="line"></span><br><span class="line">外连接： 左外连接（左连接）	右外连接（右连接）</span><br></pre></td></tr></table></figure>

<h2 id="内连接：等值连接"><a href="#内连接：等值连接" class="headerlink" title="内连接：等值连接"></a>内连接：等值连接</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SQL99语法：</span><br><span class="line">  select </span><br><span class="line">    ...</span><br><span class="line">  from</span><br><span class="line">    a</span><br><span class="line">  inner join</span><br><span class="line">    b</span><br><span class="line">  on</span><br><span class="line">    a和b的连接条件</span><br><span class="line">  where</span><br><span class="line">    筛选条件</span><br><span class="line"># inner可以省略（带着inner可读性更好！！！一眼就能看出来是内连接）</span><br></pre></td></tr></table></figure>

<h2 id="内连接：非等值连接"><a href="#内连接：非等值连接" class="headerlink" title="内连接：非等值连接"></a>内连接：非等值连接</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select </span><br><span class="line">	e.ename, e.sal, s.grade</span><br><span class="line">from</span><br><span class="line">	emp e</span><br><span class="line">join</span><br><span class="line">	salgrade s</span><br><span class="line">on</span><br><span class="line">	e.sal between s.losal and s.hisal; // 条件不是一个等量关系，称为非等值连接。</span><br></pre></td></tr></table></figure>

<h2 id="内连接：自连接"><a href="#内连接：自连接" class="headerlink" title="内连接：自连接"></a>内连接：自连接</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select </span><br><span class="line">	a.ename as &#x27;员工名&#x27;, b.ename as &#x27;领导名&#x27;</span><br><span class="line">from</span><br><span class="line">	emp a</span><br><span class="line">join</span><br><span class="line">	emp b</span><br><span class="line">on</span><br><span class="line">	a.mgr = b.empno; //员工的领导编号 = 领导的员工编号</span><br><span class="line">以上就是内连接中的：自连接，技巧：一张表看做两张表</span><br></pre></td></tr></table></figure>

<h2 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a>外连接</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// outer是可以省略的，带着可读性强。</span><br><span class="line">select </span><br><span class="line">	e.ename,d.dname</span><br><span class="line">from</span><br><span class="line">	emp e </span><br><span class="line">right outer join </span><br><span class="line">	dept d</span><br><span class="line">on</span><br><span class="line">	e.deptno = d.deptno;</span><br><span class="line">	</span><br><span class="line">right代表什么：表示将join关键字右边的这张表看成主表，主要是为了将这张表的数据全部查询出来，捎带着关联查询左边的表。在外连接当中，两张表连接，产生了主次关系。</span><br><span class="line"></span><br><span class="line">带有right的是右外连接，又叫做右连接。</span><br><span class="line">带有left的是左外连接，又叫做左连接。</span><br><span class="line">任何一个右连接都有左连接的写法。</span><br><span class="line">任何一个左连接都有右连接的写法。</span><br><span class="line"></span><br><span class="line">思考：外连接的查询结果条数一定是 &gt;= 内连接的查询结果条数？</span><br><span class="line">	正确。</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">三张表，四张表怎么连接？</span><br><span class="line">语法：</span><br><span class="line">  select </span><br><span class="line">    ...</span><br><span class="line">  from</span><br><span class="line">    a</span><br><span class="line">  join</span><br><span class="line">    b</span><br><span class="line">  on</span><br><span class="line">    a和b的连接条件</span><br><span class="line">  join</span><br><span class="line">    c</span><br><span class="line">  on</span><br><span class="line">    a和c的连接条件</span><br><span class="line">  right join</span><br><span class="line">    d</span><br><span class="line">  on</span><br><span class="line">    a和d的连接条件</span><br><span class="line">  </span><br><span class="line">  一条SQL中内连接和外连接可以混合。都可以出现！</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h1><blockquote>
<p>select语句中嵌套select语句，被嵌套的select语句称为子查询。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">子查询都可以出现在哪里呢？</span><br><span class="line">select</span><br><span class="line">  ..(select).</span><br><span class="line">from</span><br><span class="line">  ..(select).</span><br><span class="line">where</span><br><span class="line">  ..(select).</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">where子句中的子查询:</span><br><span class="line"></span><br><span class="line">第一步：查询最低工资是多少</span><br><span class="line">  select min(sal) from emp;</span><br><span class="line">  +----------+</span><br><span class="line">  | min(sal) |</span><br><span class="line">  +----------+</span><br><span class="line">  |   800.00 |</span><br><span class="line">  +----------+</span><br><span class="line">第二步：找出&gt;800的</span><br><span class="line">  select ename,sal from emp where sal &gt; 800;</span><br><span class="line"></span><br><span class="line">第三步：合并</span><br><span class="line">  select ename,sal from emp where sal &gt; (select min(sal) from emp);</span><br><span class="line">  </span><br><span class="line">from子句中的子查询:</span><br><span class="line">	注意：from后面的子查询，可以将子查询的查询结果当做一张临时表。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">select后面出现的子查询（这个内容不需要掌握，了解即可！！！）</span><br><span class="line">	注意：对于select后面的子查询来说，这个子查询只能一次返回1条结果</span><br></pre></td></tr></table></figure>

<h1 id="union合并"><a href="#union合并" class="headerlink" title="union合并"></a>union合并</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">案例：查询工作岗位是MANAGER和SALESMAN的员工？</span><br><span class="line">select ename,job from emp where job = &#x27;MANAGER&#x27; or job = &#x27;SALESMAN&#x27;;</span><br><span class="line">select ename,job from emp where job in(&#x27;MANAGER&#x27;,&#x27;SALESMAN&#x27;);</span><br><span class="line">+--------+----------+</span><br><span class="line">| ename  | job      |</span><br><span class="line">+--------+----------+</span><br><span class="line">| ALLEN  | SALESMAN |</span><br><span class="line">| WARD   | SALESMAN |</span><br><span class="line">| JONES  | MANAGER  |</span><br><span class="line">| MARTIN | SALESMAN |</span><br><span class="line">| BLAKE  | MANAGER  |</span><br><span class="line">| CLARK  | MANAGER  |</span><br><span class="line">| TURNER | SALESMAN |</span><br><span class="line">+--------+----------+</span><br><span class="line"></span><br><span class="line">select ename,job from emp where job = &#x27;MANAGER&#x27;</span><br><span class="line">union</span><br><span class="line">select ename,job from emp where job = &#x27;SALESMAN&#x27;;</span><br><span class="line"></span><br><span class="line">+--------+----------+</span><br><span class="line">| ename  | job      |</span><br><span class="line">+--------+----------+</span><br><span class="line">| JONES  | MANAGER  |</span><br><span class="line">| BLAKE  | MANAGER  |</span><br><span class="line">| CLARK  | MANAGER  |</span><br><span class="line">| ALLEN  | SALESMAN |</span><br><span class="line">| WARD   | SALESMAN |</span><br><span class="line">| MARTIN | SALESMAN |</span><br><span class="line">| TURNER | SALESMAN |</span><br><span class="line">+--------+----------+</span><br><span class="line">union的效率要高一些。对于表连接来说，每连接一次新表，</span><br><span class="line">则匹配的次数满足笛卡尔积，成倍的翻。。。</span><br><span class="line">但是union可以减少匹配的次数。在减少匹配次数的情况下，</span><br><span class="line">还可以完成两个结果集的拼接。</span><br><span class="line"></span><br><span class="line">a 连接 b 连接 c</span><br><span class="line">a 10条记录</span><br><span class="line">b 10条记录</span><br><span class="line">c 10条记录</span><br><span class="line">匹配次数是：1000</span><br><span class="line"></span><br><span class="line">a 连接 b一个结果：10 * 10 --&gt; 100次</span><br><span class="line">a 连接 c一个结果：10 * 10 --&gt; 100次</span><br><span class="line">使用union的话是：100次 + 100次 = 200次。（union把乘法变成了加法运算）</span><br><span class="line"></span><br><span class="line">union在使用的时候有注意事项吗？</span><br><span class="line"></span><br><span class="line">//错误的：union在进行结果集合并的时候，要求两个结果集的列数相同。</span><br><span class="line">select ename,job from emp where job = &#x27;MANAGER&#x27;</span><br><span class="line">union</span><br><span class="line">select ename from emp where job = &#x27;SALESMAN&#x27;;</span><br><span class="line"></span><br><span class="line">// MYSQL可以，oracle语法严格 ，不可以，报错。要求：结果集合并时列和列的数据类型也要一致。</span><br><span class="line">select ename,job from emp where job = &#x27;MANAGER&#x27;</span><br><span class="line">union</span><br><span class="line">select ename,sal from emp where job = &#x27;SALESMAN&#x27;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="limit"><a href="#limit" class="headerlink" title="limit"></a>limit</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">limit作用：将查询结果集的一部分取出来。通常使用在分页查询当中。</span><br><span class="line">百度默认：一页显示10条记录。</span><br><span class="line">分页的作用是为了提高用户的体验，因为一次全部都查出来，用户体验差。可以一页一页翻页看</span><br><span class="line"></span><br><span class="line">limit的使用</span><br><span class="line">完整用法：limit startIndex, length</span><br><span class="line">  startIndex是起始下标，length是长度。</span><br><span class="line">  起始下标从0开始。</span><br><span class="line"></span><br><span class="line">缺省用法：limit 5; 这是取前5</span><br><span class="line"></span><br><span class="line">注意：mysql当中limit在order by之后执行！！！！！！</span><br><span class="line"></span><br><span class="line">分页</span><br><span class="line">每页显示3条记录</span><br><span class="line">第1页：limit 0,3		[0 1 2]</span><br><span class="line">第2页：limit 3,3		[3 4 5]</span><br><span class="line">第3页：limit 6,3		[6 7 8]</span><br><span class="line">第4页：limit 9,3		[9 10 11]</span><br><span class="line"></span><br><span class="line">每页显示pageSize条记录</span><br><span class="line">第pageNo页：limit (pageNo - 1) * pageSize  , pageSize</span><br><span class="line"></span><br><span class="line">public static void main(String[] args)&#123;</span><br><span class="line">  // 用户提交过来一个页码，以及每页显示的记录条数</span><br><span class="line">  int pageNo = 5; //第5页</span><br><span class="line">  int pageSize = 10; //每页显示10条</span><br><span class="line"></span><br><span class="line">  int startIndex = (pageNo - 1) * pageSize;</span><br><span class="line">  String sql = &quot;select ...limit &quot; + startIndex + &quot;, &quot; + pageSize;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">记公式：</span><br><span class="line">limit (pageNo-1)*pageSize , pageSize</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">关于DQL语句的大总结：</span><br><span class="line">select </span><br><span class="line">  ...</span><br><span class="line">from</span><br><span class="line">  ...</span><br><span class="line">where</span><br><span class="line">  ...</span><br><span class="line">group by</span><br><span class="line">  ...</span><br><span class="line">having</span><br><span class="line">  ...</span><br><span class="line">order by</span><br><span class="line">  ...</span><br><span class="line">limit</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">执行顺序？</span><br><span class="line">  1.from</span><br><span class="line">  2.where</span><br><span class="line">  3.group by</span><br><span class="line">  4.having</span><br><span class="line">  5.select</span><br><span class="line">  6.order by</span><br><span class="line">  7.limit..</span><br></pre></td></tr></table></figure>

<h1 id="表的创建"><a href="#表的创建" class="headerlink" title="表的创建"></a>表的创建</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">建表的语法格式：(建表属于DDL语句，DDL包括：create drop alter)</span><br><span class="line">create table 表名(字段名1 数据类型, 字段名2 数据类型, 字段名3 数据类型);</span><br><span class="line"></span><br><span class="line">create table 表名(</span><br><span class="line">  字段名1 数据类型, </span><br><span class="line">  字段名2 数据类型, </span><br><span class="line">  字段名3 数据类型</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">表名：建议以t_ 或者 tbl_开始，可读性强。见名知意。</span><br><span class="line">字段名：见名知意。</span><br><span class="line">表名和字段名都属于标识符。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">关于mysql中的数据类型</span><br><span class="line">很多数据类型，我们只需要掌握一些常见的数据类型即可。</span><br><span class="line"></span><br><span class="line">  varchar(最长255)</span><br><span class="line">    可变长度的字符串</span><br><span class="line">    比较智能，节省空间。</span><br><span class="line">    会根据实际的数据长度动态分配空间。</span><br><span class="line"></span><br><span class="line">    优点：节省空间</span><br><span class="line">    缺点：需要动态分配空间，速度慢。</span><br><span class="line"></span><br><span class="line">  char(最长255)</span><br><span class="line">    定长字符串</span><br><span class="line">    不管实际的数据长度是多少。</span><br><span class="line">    分配固定长度的空间去存储数据。</span><br><span class="line">    使用不恰当的时候，可能会导致空间的浪费。</span><br><span class="line"></span><br><span class="line">    优点：不需要动态分配空间，速度快。</span><br><span class="line">    缺点：使用不当可能会导致空间的浪费。</span><br><span class="line"></span><br><span class="line">   varchar 和 char 我们应该怎么选择？</span><br><span class="line">      性别字段你选什么？因为性别是固定长度的字符串，所以选择char。</span><br><span class="line">      姓名字段你选什么？每一个人的名字长度不同，所以选择varchar。</span><br><span class="line"></span><br><span class="line">  int(最长11)</span><br><span class="line">    数字中的整数型。等同于java的int。</span><br><span class="line"></span><br><span class="line">  bigint</span><br><span class="line">    数字中的长整型。等同于java中的long。</span><br><span class="line"></span><br><span class="line">  float	</span><br><span class="line">    单精度浮点型数据</span><br><span class="line"></span><br><span class="line">  double</span><br><span class="line">    双精度浮点型数据</span><br><span class="line"></span><br><span class="line">  date</span><br><span class="line">    短日期类型</span><br><span class="line"></span><br><span class="line">  datetime</span><br><span class="line">    长日期类型</span><br><span class="line"></span><br><span class="line">  clob </span><br><span class="line">    字符大对象</span><br><span class="line">    最多可以存储4G的字符串。</span><br><span class="line">    比如：存储一篇文章，存储一个说明。</span><br><span class="line">    超过255个字符的都要采用CLOB字符大对象来存储。</span><br><span class="line">    Character Large OBject:CLOB</span><br><span class="line"></span><br><span class="line">  blob</span><br><span class="line">    二进制大对象</span><br><span class="line">    Binary Large OBject</span><br><span class="line">    专门用来存储图片、声音、视频等流媒体数据。</span><br><span class="line">    往BLOB类型的字段上插入数据的时候，例如插入一个图片、视频等，</span><br><span class="line">    你需要使用IO流才行。</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">创建一个学生表？</span><br><span class="line">    学号、姓名、年龄、性别、邮箱地址</span><br><span class="line">    create table t_student(</span><br><span class="line">      no int,</span><br><span class="line">      name varchar(32),</span><br><span class="line">      sex char(1),</span><br><span class="line">      age int(3),</span><br><span class="line">      email varchar(255)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">  删除表：</span><br><span class="line">  drop table t_student; // 当这张表不存在的时候会报错！</span><br><span class="line"></span><br><span class="line">  // 如果这张表存在的话，删除</span><br><span class="line">  drop table if exists t_student;</span><br><span class="line">  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="插入数据insert"><a href="#插入数据insert" class="headerlink" title="插入数据insert"></a>插入数据insert</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">插入数据insert （DML）</span><br><span class="line">	</span><br><span class="line">语法格式：</span><br><span class="line">  insert into 表名(字段名1,字段名2,字段名3...) values(值1,值2,值3);</span><br><span class="line"></span><br><span class="line">  注意：字段名和值要一一对应。什么是一一对应？</span><br><span class="line">    数量要对应。数据类型要对应。</span><br><span class="line">    </span><br><span class="line">insert语句中的“字段名”可以省略吗？可以</span><br><span class="line">  insert into t_student values(2); //错误的</span><br><span class="line"></span><br><span class="line">  // 注意：前面的字段名省略的话，等于都写上了！所以值也要都写上！</span><br><span class="line">  insert into t_student values(2, &#x27;lisi&#x27;, &#x27;f&#x27;, 20, &#x27;lisi@123.com&#x27;);</span><br><span class="line">  +------+------+------+------+--------------+</span><br><span class="line">  | no   | name | sex  | age  | email        |</span><br><span class="line">  +------+------+------+------+--------------+</span><br><span class="line">  |    1 | NULL | m    | NULL | NULL         |</span><br><span class="line">  |    2 | lisi | f    |   20 | lisi@123.com |</span><br><span class="line">  +------+------+------+------+--------------+</span><br><span class="line"></span><br><span class="line">一次可以插入多条记录：</span><br><span class="line">  insert into t_user(id,name,birth,create_time) values</span><br><span class="line">  (1,&#x27;zs&#x27;,&#x27;1980-10-11&#x27;,now()), </span><br><span class="line">  (2,&#x27;lisi&#x27;,&#x27;1981-10-11&#x27;,now()),</span><br><span class="line">  (3,&#x27;wangwu&#x27;,&#x27;1982-10-11&#x27;,now());</span><br><span class="line"></span><br><span class="line">  语法：insert into t_user(字段名1,字段名2) values(),(),(),();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">insert插入日期</span><br><span class="line">	数字格式化：format</span><br><span class="line">	</span><br><span class="line">	格式化数字：format(数字, &#x27;格式&#x27;)</span><br><span class="line">  select ename,format(sal, &#x27;$999,999&#x27;) as sal from emp;</span><br><span class="line"></span><br><span class="line">str_to_date：将字符串varchar类型转换成date类型</span><br><span class="line">date_format：将date类型转换成具有一定格式的varchar字符串类型。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">插入数据？</span><br><span class="line">insert into t_user(id,name,birth) values(1, &#x27;zhangsan&#x27;, &#x27;01-10-1990&#x27;); // 1990年10月1日</span><br><span class="line">出问题了：原因是类型不匹配。数据库birth是date类型，这里给了一个字符串varchar。</span><br><span class="line"></span><br><span class="line">怎么办？可以使用str_to_date函数进行类型转换。</span><br><span class="line">str_to_date函数可以将字符串转换成日期类型date？</span><br><span class="line">语法格式：</span><br><span class="line">  str_to_date(&#x27;字符串日期&#x27;, &#x27;日期格式&#x27;)</span><br><span class="line"></span><br><span class="line">mysql的日期格式：</span><br><span class="line">  %Y	年</span><br><span class="line">  %m    月</span><br><span class="line">  %d    日</span><br><span class="line">  %h	时</span><br><span class="line">  %i	分</span><br><span class="line">  %s	秒</span><br><span class="line"></span><br><span class="line">insert into t_user(id,name,birth) values(1, &#x27;zhangsan&#x27;, str_to_date(&#x27;01-10-1990&#x27;,&#x27;%d-%m-%Y&#x27;));</span><br><span class="line"></span><br><span class="line">str_to_date函数可以把字符串varchar转换成日期date类型数据，</span><br><span class="line">通常使用在插入insert方面，因为插入的时候需要一个日期类型的数据，</span><br><span class="line">需要通过该函数将字符串转换成date。</span><br><span class="line"></span><br><span class="line">如果你提供的日期字符串是这个格式，str_to_date函数就不需要了！！！</span><br><span class="line">  %Y-%m-%d</span><br><span class="line">insert into t_user(id,name,birth) values(2, &#x27;lisi&#x27;, &#x27;1990-10-01&#x27;);</span><br><span class="line"></span><br><span class="line">查询的时候可以以某个特定的日期格式展示吗？</span><br><span class="line">date_format</span><br><span class="line">这个函数可以将日期类型转换成特定格式的字符串。</span><br><span class="line"></span><br><span class="line">select id,name,date_format(birth, &#x27;%m/%d/%Y&#x27;) as birth from t_user;</span><br><span class="line">+------+----------+------------+</span><br><span class="line">| id   | name     | birth      |</span><br><span class="line">+------+----------+------------+</span><br><span class="line">|    1 | zhangsan | 10/01/1990 |</span><br><span class="line">|    2 | lisi     | 10/01/1990 |</span><br><span class="line">+------+----------+------------+</span><br><span class="line"></span><br><span class="line">date_format函数怎么用？</span><br><span class="line">  date_format(日期类型数据, &#x27;日期格式&#x27;)</span><br><span class="line">  这个函数通常使用在查询日期方面。设置展示的日期格式。</span><br><span class="line"></span><br><span class="line">mysql&gt; select id,name,birth from t_user;</span><br><span class="line">+------+----------+------------+</span><br><span class="line">| id   | name     | birth      |</span><br><span class="line">+------+----------+------------+</span><br><span class="line">|    1 | zhangsan | 1990-10-01 |</span><br><span class="line">|    2 | lisi     | 1990-10-01 |</span><br><span class="line">+------+----------+------------+</span><br><span class="line">以上的SQL语句实际上是进行了默认的日期格式化，</span><br><span class="line">自动将数据库中的date类型转换成varchar类型。</span><br><span class="line">并且采用的格式是mysql默认的日期格式：&#x27;%Y-%m-%d&#x27;</span><br><span class="line"></span><br><span class="line">select id,name,date_format(birth,&#x27;%Y/%m/%d&#x27;) as birth from t_user;</span><br><span class="line"></span><br><span class="line">java中的日期格式？</span><br><span class="line">  yyyy-MM-dd HH:mm:ss SSS</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">date和datetime两个类型的区别？</span><br><span class="line">	date是短日期：只包括年月日信息。</span><br><span class="line">	datetime是长日期：包括年月日时分秒信息。</span><br><span class="line">	mysql短日期默认格式：%Y-%m-%d</span><br><span class="line">	mysql长日期默认格式：%Y-%m-%d %h:%i:%s</span><br></pre></td></tr></table></figure>

<h1 id="修改update"><a href="#修改update" class="headerlink" title="修改update"></a>修改update</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">语法格式：</span><br><span class="line">update 表名 set 字段名1=值1,字段名2=值2,字段名3=值3... where 条件;</span><br><span class="line"></span><br><span class="line">注意：没有条件限制会导致所有数据全部更新。</span><br><span class="line"></span><br><span class="line">update t_user set name = &#x27;jack&#x27;, birth = &#x27;2000-10-11&#x27; where id = 2;</span><br><span class="line">+------+----------+------------+---------------------+</span><br><span class="line">| id   | name     | birth      | create_time         |</span><br><span class="line">+------+----------+------------+---------------------+</span><br><span class="line">|    1 | zhangsan | 1990-10-01 | 2020-03-18 15:49:50 |</span><br><span class="line">|    2 | jack     | 2000-10-11 | 2020-03-18 15:51:23 |</span><br><span class="line">+------+----------+------------+---------------------+</span><br><span class="line"></span><br><span class="line">update t_user set name = &#x27;jack&#x27;, birth = &#x27;2000-10-11&#x27;, create_time = now() where id = 2;</span><br><span class="line"></span><br><span class="line">更新所有？</span><br><span class="line">  update t_user set name = &#x27;abc&#x27;;</span><br></pre></td></tr></table></figure>

<h1 id="删除数据-delete"><a href="#删除数据-delete" class="headerlink" title="删除数据 delete"></a>删除数据 delete</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">语法格式？</span><br><span class="line">  delete from 表名 where 条件;</span><br><span class="line"></span><br><span class="line">注意：没有条件，整张表的数据会全部删除！</span><br><span class="line"></span><br><span class="line">delete from t_user where id = 2;</span><br><span class="line"></span><br><span class="line">insert into t_user(id) values(2);</span><br><span class="line"></span><br><span class="line">delete from t_user; // 删除所有！</span><br><span class="line"></span><br><span class="line">快速删除表中的数据？【truncate比较重要，必须掌握】</span><br><span class="line"></span><br><span class="line">//删除dept_bak表中的数据</span><br><span class="line">delete from dept_bak; //这种删除数据的方式比较慢。</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from dept_bak;</span><br><span class="line">Empty set (0.00 sec)</span><br><span class="line"></span><br><span class="line">delete语句删除数据的原理？（delete属于DML语句！！！）</span><br><span class="line">  表中的数据被删除了，但是这个数据在硬盘上的真实存储空间不会被释放！！！</span><br><span class="line">  这种删除缺点是：删除效率比较低。</span><br><span class="line">  这种删除优点是：支持回滚，后悔了可以再恢复数据！！！</span><br><span class="line"></span><br><span class="line">truncate语句删除数据的原理？</span><br><span class="line">  这种删除效率比较高，表被一次截断，物理删除。</span><br><span class="line">  这种删除缺点：不支持回滚。</span><br><span class="line">  这种删除优点：快速。</span><br><span class="line"></span><br><span class="line">用法：truncate table dept_bak; （这种操作属于DDL操作。）</span><br><span class="line"></span><br><span class="line">大表非常大，上亿条记录？？？？</span><br><span class="line">  删除的时候，使用delete，也许需要执行1个小时才能删除完！效率较低。</span><br><span class="line">  可以选择使用truncate删除表中的数据。只需要不到1秒钟的时间就删除结束。效率较高。</span><br><span class="line">  但是使用truncate之前，必须仔细询问客户是否真的要删除，并警告删除之后不可恢复！</span><br><span class="line"></span><br><span class="line">  truncate是删除表中的数据，表还在！</span><br><span class="line"></span><br><span class="line">删除表操作？</span><br><span class="line">  drop table 表名; // 这不是删除表中的数据，这是把表删除。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">什么是约束？</span><br><span class="line">约束对应的英语单词： constraint</span><br><span class="line">在创建表的时候，我们可以给表中的字段加上一些约束，来保证这个表中数据的</span><br><span class="line">完整性、有效性！！！</span><br><span class="line"></span><br><span class="line">约束的作用就是为了保证：表中的数据有效！！</span><br><span class="line"></span><br><span class="line">约束包括哪些？</span><br><span class="line">非空约束：not null</span><br><span class="line">唯一性约束: unique</span><br><span class="line">主键约束: primary key （简称PK）</span><br><span class="line">外键约束：foreign key（简称FK）</span><br><span class="line">检查约束：check（mysql不支持，oracle支持）</span><br></pre></td></tr></table></figure>

<h2 id="非空约束：not-null"><a href="#非空约束：not-null" class="headerlink" title="非空约束：not null"></a>非空约束：not null</h2><blockquote>
<p>唯一性约束unique约束的字段不能重复，但是可以为NULL。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">drop table if exists t_vip;</span><br><span class="line">create table t_vip(</span><br><span class="line">  id int,</span><br><span class="line">  name varchar(255) not null  // not null只有列级约束，没有表级约束！</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h2 id="唯一性约束-unique"><a href="#唯一性约束-unique" class="headerlink" title="唯一性约束: unique"></a>唯一性约束: unique</h2><blockquote>
<p>唯一性约束unique约束的字段不能重复，但是可以为NULL。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">唯一性约束unique约束的字段不能重复，但是可以为NULL。</span><br><span class="line">drop table if exists t_vip;</span><br><span class="line">create table t_vip(</span><br><span class="line">  id int,</span><br><span class="line">  name varchar(255) unique,</span><br><span class="line">  email varchar(255)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">如何做到联合唯一约束</span><br><span class="line">drop table if exists t_vip;</span><br><span class="line">create table t_vip(</span><br><span class="line">  id int,</span><br><span class="line">  name varchar(255),</span><br><span class="line">  email varchar(255),</span><br><span class="line">  unique(name,email) // 约束没有添加在列的后面，这种约束被称为表级约束。</span><br><span class="line">);</span><br><span class="line">name和email两个字段联合起来唯一</span><br><span class="line">在mysql当中，如果一个字段同时被not null和unique约束的话，该字段自动变成主键字段。</span><br></pre></td></tr></table></figure>

<h2 id="主键约束-primary-key"><a href="#主键约束-primary-key" class="headerlink" title="主键约束: primary key"></a>主键约束: primary key</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">主键约束的相关术语？</span><br><span class="line">  主键约束：就是一种约束。</span><br><span class="line">  主键字段：该字段上添加了主键约束，这样的字段叫做：主键字段</span><br><span class="line">  主键值：主键字段中的每一个值都叫做：主键值。</span><br><span class="line"></span><br><span class="line">什么是主键？有啥用？</span><br><span class="line">  主键值是每一行记录的唯一标识。</span><br><span class="line">  主键值是每一行记录的身份证号！！！</span><br><span class="line"></span><br><span class="line">记住：任何一张表都应该有主键，没有主键，表无效！！</span><br><span class="line"></span><br><span class="line">主键的特征：not null + unique（主键值不能是NULL，同时也不能重复！）</span><br><span class="line"></span><br><span class="line">怎么给一张表添加主键约束呢？</span><br><span class="line">  drop table if exists t_vip;</span><br><span class="line">  // 1个字段做主键，叫做：单一主键</span><br><span class="line">  create table t_vip(</span><br><span class="line">    id int primary key,  //列级约束</span><br><span class="line">    name varchar(255)</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">表级约束主要是给多个字段联合起来添加约束？</span><br><span class="line">  drop table if exists t_vip;</span><br><span class="line">  // id和name联合起来做主键：复合主键！！！！</span><br><span class="line">  create table t_vip(</span><br><span class="line">    id int,</span><br><span class="line">    name varchar(255),</span><br><span class="line">    email varchar(255),</span><br><span class="line">    primary key(id,name)</span><br><span class="line">  );</span><br><span class="line">  </span><br><span class="line">在实际开发中不建议使用：复合主键。建议使用单一主键！</span><br><span class="line">因为主键值存在的意义就是这行记录的身份证号，只要意义达到即可，单一主键可以做到。</span><br><span class="line">复合主键比较复杂，不建议使用！！！</span><br><span class="line"></span><br><span class="line">主键值建议使用：</span><br><span class="line">  int</span><br><span class="line">  bigint</span><br><span class="line">  char</span><br><span class="line">  等类型。</span><br><span class="line"></span><br><span class="line">不建议使用：varchar来做主键。主键值一般都是数字，一般都是定长的！</span><br><span class="line"></span><br><span class="line">主键除了：单一主键和复合主键之外，还可以这样进行分类？</span><br><span class="line">  自然主键：主键值是一个自然数，和业务没关系。</span><br><span class="line">  业务主键：主键值和业务紧密关联，例如拿银行卡账号做主键值。这就是业务主键！</span><br><span class="line"></span><br><span class="line">在实际开发中使用业务主键多，还是使用自然主键多一些？</span><br><span class="line">  自然主键使用比较多，因为主键只要做到不重复就行，不需要有意义。</span><br><span class="line">  业务主键不好，因为主键一旦和业务挂钩，那么当业务发生变动的时候，</span><br><span class="line">  可能会影响到主键值，所以业务主键不建议使用。尽量使用自然主键。</span><br><span class="line">  </span><br><span class="line">在mysql当中，有一种机制，可以帮助我们自动维护一个主键值？</span><br><span class="line">		drop table if exists t_vip;</span><br><span class="line">		create table t_vip(</span><br><span class="line">			id int primary key auto_increment, //auto_increment表示自增，从1开始，以1递增！</span><br><span class="line">			name varchar(255)</span><br><span class="line">		);</span><br></pre></td></tr></table></figure>



<h2 id="外键约束：foreign-key"><a href="#外键约束：foreign-key" class="headerlink" title="外键约束：foreign key"></a>外键约束：foreign key</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">外键约束涉及到的相关术语：</span><br><span class="line">  外键约束：一种约束（ foreign key）</span><br><span class="line">  外键字段：该字段上添加了外键约束</span><br><span class="line">  外键值：外键字段当中的每一个值。</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h1><blockquote>
<p>什么是存储引擎，有什么用呢？</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">存储引擎是MySQL中特有的一个术语，其它数据库中没有。（Oracle中有，但是不叫这个名字）</span><br><span class="line">存储引擎这个名字高端大气上档次。实际上存储引擎是一个表存储/组织数据的方式。</span><br><span class="line">不同的存储引擎，表存储数据的方式不同。</span><br><span class="line"></span><br><span class="line">怎么给表添加/指定“存储引擎”呢？</span><br><span class="line">show create table t_student;</span><br><span class="line"></span><br><span class="line">可以在建表的时候给表指定存储引擎。</span><br><span class="line">CREATE TABLE `t_student` (</span><br><span class="line">  `no` int(11) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  `name` varchar(255) DEFAULT NULL,</span><br><span class="line">  `cno` int(11) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`no`),</span><br><span class="line">  KEY `cno` (`cno`),</span><br><span class="line">  CONSTRAINT `t_student_ibfk_1` FOREIGN KEY (`cno`) REFERENCES `t_class` (`classno`)</span><br><span class="line">) ENGINE=InnoDB AUTO_INCREMENT=11 DEFAULT CHARSET=utf8</span><br><span class="line"></span><br><span class="line">在建表的时候可以在最后小括号的&quot;)&quot;的右边使用：</span><br><span class="line">  ENGINE来指定存储引擎。</span><br><span class="line">  CHARSET来指定这张表的字符编码方式。</span><br><span class="line">	</span><br><span class="line">结论：</span><br><span class="line">  mysql默认的存储引擎是：InnoDB</span><br><span class="line">  mysql默认的字符编码方式是：utf8</span><br><span class="line">  </span><br><span class="line">怎么查看mysql支持哪些存储引擎呢？</span><br><span class="line">命令： show engines \G</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="MyISAM存储引擎"><a href="#MyISAM存储引擎" class="headerlink" title="MyISAM存储引擎"></a>MyISAM存储引擎</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">它管理的表具有以下特征：</span><br><span class="line">  使用三个文件表示每个表：</span><br><span class="line">    格式文件 — 存储表结构的定义（mytable.frm）</span><br><span class="line">    数据文件 — 存储表行的内容（mytable.MYD）</span><br><span class="line">    索引文件 — 存储表上索引（mytable.MYI）：索引是一本书的目录，缩小扫描范围，提高查询效率的一种机制。</span><br><span class="line">  可被转换为压缩、只读表来节省空间</span><br><span class="line"></span><br><span class="line">  提示一下：</span><br><span class="line">    对于一张表来说，只要是主键，</span><br><span class="line">    或者加有unique约束的字段上会自动创建索引。</span><br><span class="line"></span><br><span class="line">  MyISAM存储引擎特点：</span><br><span class="line">    可被转换为压缩、只读表来节省空间</span><br><span class="line">    这是这种存储引擎的优势！！！！</span><br><span class="line">  </span><br><span class="line">  MyISAM不支持事务机制，安全性低。</span><br></pre></td></tr></table></figure>

<h2 id="InnoDB存储引擎"><a href="#InnoDB存储引擎" class="headerlink" title="InnoDB存储引擎"></a>InnoDB存储引擎</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">这是mysql默认的存储引擎，同时也是一个重量级的存储引擎。</span><br><span class="line">InnoDB支持事务，支持数据库崩溃后自动恢复机制。</span><br><span class="line">InnoDB存储引擎最主要的特点是：非常安全。</span><br><span class="line"></span><br><span class="line">它管理的表具有下列主要特征：</span><br><span class="line">  – 每个 InnoDB 表在数据库目录中以.frm 格式文件表示</span><br><span class="line">  – InnoDB 表空间 tablespace 被用于存储表的内容（表空间是一个逻辑名称。表空间存储数据+索引。）</span><br><span class="line"></span><br><span class="line">  – 提供一组用来记录事务性活动的日志文件</span><br><span class="line">  – 用 COMMIT(提交)、SAVEPOINT 及ROLLBACK(回滚)支持事务处理</span><br><span class="line">  – 提供全 ACID 兼容</span><br><span class="line">  – 在 MySQL 服务器崩溃后提供自动恢复</span><br><span class="line">  – 多版本（MVCC）和行级锁定</span><br><span class="line">  – 支持外键及引用的完整性，包括级联删除和更新</span><br><span class="line"></span><br><span class="line">InnoDB最大的特点就是支持事务：</span><br><span class="line">  以保证数据的安全。效率不是很高，并且也不能压缩，不能转换为只读，</span><br><span class="line">  不能很好的节省存储空间。</span><br></pre></td></tr></table></figure>

<h2 id="MEMORY存储引擎"><a href="#MEMORY存储引擎" class="headerlink" title="MEMORY存储引擎"></a>MEMORY存储引擎</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">使用 MEMORY 存储引擎的表，其数据存储在内存中，且行的长度固定，</span><br><span class="line">这两个特点使得 MEMORY 存储引擎非常快。</span><br><span class="line"></span><br><span class="line">MEMORY 存储引擎管理的表具有下列特征：</span><br><span class="line">  – 在数据库目录内，每个表均以.frm 格式的文件表示。</span><br><span class="line">  – 表数据及索引被存储在内存中。（目的就是快，查询快！）</span><br><span class="line">  – 表级锁机制。</span><br><span class="line">  – 不能包含 TEXT 或 BLOB 字段。</span><br><span class="line"></span><br><span class="line">MEMORY 存储引擎以前被称为HEAP 引擎。</span><br><span class="line"></span><br><span class="line">MEMORY引擎优点：查询效率是最高的。不需要和硬盘交互。</span><br><span class="line">MEMORY引擎缺点：不安全，关机之后数据消失。因为数据和索引都是在内存当中。</span><br></pre></td></tr></table></figure>

<h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">什么是事务？</span><br><span class="line"></span><br><span class="line">一个事务其实就是一个完整的业务逻辑。</span><br><span class="line">是一个最小的工作单元。不可再分。</span><br><span class="line"></span><br><span class="line">什么是一个完整的业务逻辑？</span><br><span class="line">  假设转账，从A账户向B账户中转账10000.</span><br><span class="line">  将A账户的钱减去10000（update语句）</span><br><span class="line">  将B账户的钱加上10000（update语句）</span><br><span class="line">  这就是一个完整的业务逻辑。</span><br><span class="line"></span><br><span class="line">  以上的操作是一个最小的工作单元，要么同时成功，要么同时失败，不可再分。</span><br><span class="line">  这两个update语句要求必须同时成功或者同时失败，这样才能保证钱是正确的。</span><br><span class="line"></span><br><span class="line">只有DML语句才会有事务这一说，其它语句和事务无关！！！</span><br><span class="line">insert</span><br><span class="line">delete</span><br><span class="line">update</span><br><span class="line">只有以上的三个语句和事务有关系，其它都没有关系。</span><br><span class="line"></span><br><span class="line">因为 只有以上的三个语句是数据库表中数据进行增、删、改的。</span><br><span class="line">只要你的操作一旦涉及到数据的增、删、改，那么就一定要考虑安全问题。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">InnoDB存储引擎：提供一组用来记录事务性活动的日志文件</span><br><span class="line"></span><br><span class="line">事务开启了：</span><br><span class="line">insert</span><br><span class="line">insert</span><br><span class="line">insert</span><br><span class="line">delete</span><br><span class="line">update</span><br><span class="line">update</span><br><span class="line">update</span><br><span class="line">事务结束了！</span><br><span class="line"></span><br><span class="line">在事务的执行过程中，每一条DML的操作都会记录到“事务性活动的日志文件”中。</span><br><span class="line">在事务的执行过程中，我们可以提交事务，也可以回滚事务。</span><br><span class="line"></span><br><span class="line">提交事务？</span><br><span class="line">  清空事务性活动的日志文件，将数据全部彻底持久化到数据库表中。</span><br><span class="line">  提交事务标志着，事务的结束。并且是一种全部成功的结束。</span><br><span class="line"></span><br><span class="line">回滚事务？</span><br><span class="line">  将之前所有的DML操作全部撤销，并且清空事务性活动的日志文件</span><br><span class="line">  回滚事务标志着，事务的结束。并且是一种全部失败的结束。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="提交事务、回滚事务"><a href="#提交事务、回滚事务" class="headerlink" title="提交事务、回滚事务"></a>提交事务、回滚事务</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">提交事务：commit; 语句</span><br><span class="line">回滚事务：rollback; 语句（回滚永远都是只能回滚到上一次的提交点！）</span><br><span class="line"></span><br><span class="line">事务对应的英语单词是：transaction</span><br><span class="line"></span><br><span class="line">测试一下，在mysql当中默认的事务行为是怎样的？</span><br><span class="line">  mysql默认情况下是支持自动提交事务的。（自动提交）</span><br><span class="line">  什么是自动提交？</span><br><span class="line">    每执行一条DML语句，则提交一次！</span><br><span class="line"></span><br><span class="line">  这种自动提交实际上是不符合我们的开发习惯，因为一个业务</span><br><span class="line">  通常是需要多条DML语句共同执行才能完成的，为了保证数据</span><br><span class="line">  的安全，必须要求同时成功之后再提交，所以不能执行一条</span><br><span class="line">  就提交一条。</span><br><span class="line"></span><br><span class="line">怎么将mysql的自动提交机制关闭掉呢？</span><br><span class="line">  先执行这个命令：start transaction;</span><br></pre></td></tr></table></figure>

<p><strong>代码演示</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">演示事务：</span><br><span class="line">  ---------------------------------回滚事务----------------------------------------</span><br><span class="line">  mysql&gt; use bjpowernode;</span><br><span class="line">  Database changed</span><br><span class="line">  mysql&gt; select * from dept_bak;</span><br><span class="line">  Empty set (0.00 sec)</span><br><span class="line"></span><br><span class="line">  mysql&gt; start transaction;</span><br><span class="line">  Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">  mysql&gt; insert into dept_bak values(10,&#x27;abc&#x27;, &#x27;tj&#x27;);</span><br><span class="line">  Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">  mysql&gt; insert into dept_bak values(10,&#x27;abc&#x27;, &#x27;tj&#x27;);</span><br><span class="line">  Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">  mysql&gt; select * from dept_bak;</span><br><span class="line">  +--------+-------+------+</span><br><span class="line">  | DEPTNO | DNAME | LOC  |</span><br><span class="line">  +--------+-------+------+</span><br><span class="line">  |     10 | abc   | tj   |</span><br><span class="line">  |     10 | abc   | tj   |</span><br><span class="line">  +--------+-------+------+</span><br><span class="line">  2 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">  mysql&gt; rollback;</span><br><span class="line">  Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">  mysql&gt; select * from dept_bak;</span><br><span class="line">  Empty set (0.00 sec)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  ---------------------------------提交事务----------------------------------------</span><br><span class="line">  mysql&gt; use bjpowernode;</span><br><span class="line">  Database changed</span><br><span class="line">  mysql&gt; select * from dept_bak;</span><br><span class="line">  +--------+-------+------+</span><br><span class="line">  | DEPTNO | DNAME | LOC  |</span><br><span class="line">  +--------+-------+------+</span><br><span class="line">  |     10 | abc   | bj   |</span><br><span class="line">  +--------+-------+------+</span><br><span class="line">  1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">  mysql&gt; start transaction;</span><br><span class="line">  Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">  mysql&gt; insert into dept_bak values(20,&#x27;abc</span><br><span class="line">  Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">  mysql&gt; insert into dept_bak values(20,&#x27;abc</span><br><span class="line">  Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">  mysql&gt; insert into dept_bak values(20,&#x27;abc</span><br><span class="line">  Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">  mysql&gt; commit;</span><br><span class="line">  Query OK, 0 rows affected (0.01 sec)</span><br><span class="line"></span><br><span class="line">  mysql&gt; select * from dept_bak;</span><br><span class="line">  +--------+-------+------+</span><br><span class="line">  | DEPTNO | DNAME | LOC  |</span><br><span class="line">  +--------+-------+------+</span><br><span class="line">  |     10 | abc   | bj   |</span><br><span class="line">  |     20 | abc   | tj   |</span><br><span class="line">  |     20 | abc   | tj   |</span><br><span class="line">  |     20 | abc   | tj   |</span><br><span class="line">  +--------+-------+------+</span><br><span class="line">  4 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">  mysql&gt; rollback;</span><br><span class="line">  Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">  mysql&gt; select * from dept_bak;</span><br><span class="line">  +--------+-------+------+</span><br><span class="line">  | DEPTNO | DNAME | LOC  |</span><br><span class="line">  +--------+-------+------+</span><br><span class="line">  |     10 | abc   | bj   |</span><br><span class="line">  |     20 | abc   | tj   |</span><br><span class="line">  |     20 | abc   | tj   |</span><br><span class="line">  |     20 | abc   | tj   |</span><br><span class="line">  +--------+-------+------+</span><br><span class="line">  4 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<h2 id="事务四个特性"><a href="#事务四个特性" class="headerlink" title="事务四个特性"></a>事务四个特性</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A：原子性</span><br><span class="line">  说明事务是最小的工作单元。不可再分。</span><br><span class="line"></span><br><span class="line">C：一致性</span><br><span class="line">  所有事务要求，在同一个事务当中，所有操作必须同时成功，或者同时失败，</span><br><span class="line">  以保证数据的一致性。</span><br><span class="line"></span><br><span class="line">I：隔离性</span><br><span class="line">  A事务和B事务之间具有一定的隔离。</span><br><span class="line">  教室A和教室B之间有一道墙，这道墙就是隔离性。</span><br><span class="line">  A事务在操作一张表的时候，另一个事务B也操作这张表会那样？？？</span><br><span class="line"></span><br><span class="line">D：持久性</span><br><span class="line">  事务最终结束的一个保障。事务提交，就相当于将没有保存到硬盘上的数据</span><br><span class="line">  保存到硬盘上！</span><br></pre></td></tr></table></figure>

<h2 id="事务的隔离性"><a href="#事务的隔离性" class="headerlink" title="事务的隔离性"></a>事务的隔离性</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A教室和B教室中间有一道墙，这道墙可以很厚，也可以很薄。这就是事务的隔离级别。</span><br><span class="line">这道墙越厚，表示隔离级别就越高。</span><br><span class="line"></span><br><span class="line">事务和事务之间的隔离级别有哪些呢？4个级别</span><br><span class="line"></span><br><span class="line">读未提交：read uncommitted（最低的隔离级别）《没有提交就读到了》</span><br><span class="line">  什么是读未提交？</span><br><span class="line">    事务A可以读取到事务B未提交的数据。</span><br><span class="line">  这种隔离级别存在的问题就是：</span><br><span class="line">    脏读现象！(Dirty Read)</span><br><span class="line">    我们称读到了脏数据。</span><br><span class="line">  这种隔离级别一般都是理论上的，大多数的数据库隔离级别都是二档起步！</span><br><span class="line"></span><br><span class="line">读已提交：read committed《提交之后才能读到》</span><br><span class="line">  什么是读已提交？</span><br><span class="line">    事务A只能读取到事务B提交之后的数据。</span><br><span class="line">  这种隔离级别解决了什么问题？</span><br><span class="line">    解决了脏读的现象。</span><br><span class="line">  这种隔离级别存在什么问题？</span><br><span class="line">    不可重复读取数据。</span><br><span class="line">    什么是不可重复读取数据呢？</span><br><span class="line">      在事务开启之后，第一次读到的数据是3条，当前事务还没有</span><br><span class="line">      结束，可能第二次再读取的时候，读到的数据是4条，3不等于4</span><br><span class="line">      称为不可重复读取。</span><br><span class="line"></span><br><span class="line">  这种隔离级别是比较真实的数据，每一次读到的数据是绝对的真实。</span><br><span class="line">  oracle数据库默认的隔离级别是：read committed</span><br><span class="line"></span><br><span class="line">可重复读：repeatable read《提交之后也读不到，永远读取的都是刚开启事务时的数据》</span><br><span class="line">  什么是可重复读取？</span><br><span class="line">    事务A开启之后，不管是多久，每一次在事务A中读取到的数据</span><br><span class="line">    都是一致的。即使事务B将数据已经修改，并且提交了，事务A</span><br><span class="line">    读取到的数据还是没有发生改变，这就是可重复读。</span><br><span class="line">  可重复读解决了什么问题？</span><br><span class="line">    解决了不可重复读取数据。</span><br><span class="line">  可重复读存在的问题是什么？</span><br><span class="line">    可以会出现幻影读。</span><br><span class="line">    每一次读取到的数据都是幻象。不够真实！</span><br><span class="line">  </span><br><span class="line">  早晨9点开始开启了事务，只要事务不结束，到晚上9点，读到的数据还是那样！</span><br><span class="line">  读到的是假象。不够绝对的真实。</span><br><span class="line"></span><br><span class="line">  mysql中默认的事务隔离级别就是这个！！！！！！！！！！！</span><br><span class="line"></span><br><span class="line">序列化/串行化：serializable（最高的隔离级别）</span><br><span class="line">  这是最高隔离级别，效率最低。解决了所有的问题。</span><br><span class="line">  这种隔离级别表示事务排队，不能并发！</span><br><span class="line">  synchronized，线程同步（事务同步）</span><br><span class="line">  每一次读取到的数据都是最真实的，并且效率是最低的。</span><br><span class="line"></span><br><span class="line">查看隔离级别：SELECT @@tx_isolation</span><br><span class="line">+-----------------+</span><br><span class="line">| @@tx_isolation  |</span><br><span class="line">+-----------------+</span><br><span class="line">| REPEATABLE-READ |</span><br><span class="line">+-----------------+</span><br><span class="line">mysql默认的隔离级别</span><br></pre></td></tr></table></figure>

<h1 id="索引（index）"><a href="#索引（index）" class="headerlink" title="索引（index）"></a>索引（index）</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">什么是索引？</span><br><span class="line">索引是在数据库表的字段上添加的，是为了提高查询效率存在的一种机制。</span><br><span class="line">一张表的一个字段可以添加一个索引，当然，多个字段联合起来也可以添加索引。</span><br><span class="line">索引相当于一本书的目录，是为了缩小扫描范围而存在的一种机制。</span><br><span class="line"></span><br><span class="line">对于一本字典来说，查找某个汉字有两种方式：</span><br><span class="line">  第一种方式：一页一页挨着找，直到找到为止，这种查找方式属于全字典扫描。</span><br><span class="line">  效率比较低。</span><br><span class="line">  第二种方式：先通过目录（索引）去定位一个大概的位置，然后直接定位到这个</span><br><span class="line">  位置，做局域性扫描，缩小扫描的范围，快速的查找。这种查找方式属于通过</span><br><span class="line">  索引检索，效率较高。</span><br><span class="line">  </span><br><span class="line">select * from t_user where name = &#x27;jack&#x27;;</span><br><span class="line"></span><br><span class="line">以上的这条SQL语句会去name字段上扫描，为什么？</span><br><span class="line">  因为查询条件是：name=&#x27;jack&#x27;</span><br><span class="line"></span><br><span class="line">如果name字段上没有添加索引（目录），或者说没有给name字段创建索引，</span><br><span class="line">MySQL会进行全扫描，会将name字段上的每一个值都比对一遍。效率比较低。</span><br><span class="line"></span><br><span class="line">MySQL在查询方面主要就是两种方式：</span><br><span class="line">  第一种方式：全表扫描</span><br><span class="line">  第二种方式：根据索引检索。</span><br><span class="line"></span><br><span class="line">注意：</span><br><span class="line">  在实际中，汉语字典前面的目录是排序的，按照a b c d e f....排序，</span><br><span class="line">  为什么排序呢？因为只有排序了才会有区间查找这一说！（缩小扫描范围</span><br><span class="line">  其实就是扫描某个区间罢了！）</span><br><span class="line"></span><br><span class="line">  在mysql数据库当中索引也是需要排序的，并且这个所以的排序和TreeSet</span><br><span class="line">  数据结构相同。TreeSet（TreeMap）底层是一个自平衡的二叉树！在mysql</span><br><span class="line">  当中索引是一个B-Tree数据结构。</span><br><span class="line"></span><br><span class="line">  遵循左小又大原则存放。采用中序遍历方式遍历取数据。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">假设有一张用户表：t_user</span><br><span class="line"></span><br><span class="line">id(PK)					name						每一行记录在硬盘上都有物理存储编号</span><br><span class="line">----------------------------------------------------------------------------------</span><br><span class="line">100						zhangsan					0x1111</span><br><span class="line">120						lisi						0x2222</span><br><span class="line">99							wangwu					0x8888</span><br><span class="line">88							zhaoliu					0x9999</span><br><span class="line">101						jack						0x6666</span><br><span class="line">55							lucy						0x5555</span><br><span class="line">130						tom						0x7777</span><br><span class="line"></span><br><span class="line">提醒1：在任何数据库当中主键上都会自动添加索引对象，id字段上自动有索引，</span><br><span class="line">因为id是PK。另外在mysql当中，一个字段上如果有unique约束的话，也会自动</span><br><span class="line">创建索引对象。</span><br><span class="line"></span><br><span class="line">提醒2：在任何数据库当中，任何一张表的任何一条记录在硬盘存储上都有</span><br><span class="line">一个硬盘的物理存储编号。</span><br><span class="line"></span><br><span class="line">提醒3：在mysql当中，索引是一个单独的对象，不同的存储引擎以不同的形式</span><br><span class="line">存在，在MyISAM存储引擎中，索引存储在一个.MYI文件中。在InnoDB存储引擎中</span><br><span class="line">索引存储在一个逻辑名称叫做tablespace的当中。在MEMORY存储引擎当中索引</span><br><span class="line">被存储在内存当中。不管索引存储在哪里，索引在mysql当中都是一个树的形式</span><br><span class="line">存在。（自平衡二叉树：B-Tree）</span><br></pre></td></tr></table></figure>

<h2 id="添加索引的条件"><a href="#添加索引的条件" class="headerlink" title="添加索引的条件"></a>添加索引的条件</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">什么条件下，我们会考虑给字段添加索引呢？</span><br><span class="line">条件1：数据量庞大（到底有多么庞大算庞大，这个需要测试，因为每一个硬件环境不同）</span><br><span class="line">条件2：该字段经常出现在where的后面，以条件的形式存在，也就是说这个字段总是被扫描。</span><br><span class="line">条件3：该字段很少的DML(insert delete update)操作。（因为DML之后，索引需要重新排序。）</span><br><span class="line"></span><br><span class="line">建议不要随意添加索引，因为索引也是需要维护的，太多的话反而会降低系统的性能。</span><br><span class="line">建议通过主键查询，建议通过unique约束的字段进行查询，效率是比较高的。</span><br></pre></td></tr></table></figure>

<h2 id="索引的创建和删除"><a href="#索引的创建和删除" class="headerlink" title="索引的创建和删除"></a>索引的创建和删除</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">创建索引：</span><br><span class="line">  mysql&gt; create index emp_ename_index on emp(ename);</span><br><span class="line">  给emp表的ename字段添加索引，起名：emp_ename_index</span><br><span class="line"></span><br><span class="line">删除索引：</span><br><span class="line">  mysql&gt; drop index emp_ename_index on emp;</span><br><span class="line">  将emp表上的emp_ename_index索引对象删除。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="是否使用索引进行检索"><a href="#是否使用索引进行检索" class="headerlink" title="是否使用索引进行检索"></a>是否使用索引进行检索</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.5、在mysql当中，怎么查看一个SQL语句是否使用了索引进行检索？</span><br><span class="line"></span><br><span class="line">mysql&gt; explain select * from emp where ename = &#x27;KING&#x27;;</span><br><span class="line">+----+-------------+-------+------+---------------+------+---------+------+------+-------------+</span><br><span class="line">| id | select_type | table | type | possible_keys | key  | key_len | ref  | rows | Extra       |</span><br><span class="line">+----+-------------+-------+------+---------------+------+---------+------+------+-------------+</span><br><span class="line">|  1 | SIMPLE      | emp   | ALL  | NULL          | NULL | NULL    | NULL |   14 | Using where |</span><br><span class="line">+----+-------------+-------+------+---------------+------+---------+------+------+-------------+</span><br><span class="line">扫描14条记录：说明没有使用索引。type=ALL</span><br><span class="line"></span><br><span class="line">mysql&gt; create index emp_ename_index on emp(ename);</span><br><span class="line"></span><br><span class="line">mysql&gt; explain select * from emp where ename = &#x27;KING&#x27;;</span><br><span class="line">+----+-------------+-------+------+-----------------+-----------------+---------+-------+------+-------------+</span><br><span class="line">| id | select_type | table | type | possible_keys   | key             | key_len | ref   | rows | Extra       |</span><br><span class="line">+----+-------------+-------+------+-----------------+-----------------+---------+-------+------+-------------+</span><br><span class="line">|  1 | SIMPLE      | emp   | ref  | emp_ename_index | emp_ename_index | 33      | const |    1 | Using where |</span><br><span class="line">+----+-------------+-------+------+-----------------+-----------------+---------+-------+------+-------------+</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="索引失效的情况"><a href="#索引失效的情况" class="headerlink" title="索引失效的情况"></a>索引失效的情况</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">索引有失效的时候，什么时候索引失效呢？</span><br><span class="line"></span><br><span class="line">失效的第1种情况：</span><br><span class="line">  select * from emp where ename like &#x27;%T&#x27;;</span><br><span class="line"></span><br><span class="line">  ename上即使添加了索引，也不会走索引，为什么？</span><br><span class="line">    原因是因为模糊匹配当中以“%”开头了！</span><br><span class="line">    尽量避免模糊查询的时候以“%”开始。</span><br><span class="line">    这是一种优化的手段/策略。</span><br><span class="line"></span><br><span class="line">  mysql&gt; explain select * from emp where ename like &#x27;%T&#x27;;</span><br><span class="line">  +----+-------------+-------+------+---------------+------+---------+------+------+-------------+</span><br><span class="line">  | id | select_type | table | type | possible_keys | key  | key_len | ref  | rows | Extra       |</span><br><span class="line">  +----+-------------+-------+------+---------------+------+---------+------+------+-------------+</span><br><span class="line">  |  1 | SIMPLE      | emp   | ALL  | NULL          | NULL | NULL    | NULL |   14 | Using where |</span><br><span class="line">  +----+-------------+-------+------+---------------+------+---------+------+------+-------------+</span><br><span class="line"></span><br><span class="line">失效的第2种情况：</span><br><span class="line">  使用or的时候会失效，如果使用or那么要求or两边的条件字段都要有</span><br><span class="line">  索引，才会走索引，如果其中一边有一个字段没有索引，那么另一个</span><br><span class="line">  字段上的索引也会实现。所以这就是为什么不建议使用or的原因。</span><br><span class="line"></span><br><span class="line">  mysql&gt; explain select * from emp where ename = &#x27;KING&#x27; or job = &#x27;MANAGER&#x27;;</span><br><span class="line">  +----+-------------+-------+------+-----------------+------+---------+------+------+-------------+</span><br><span class="line">  | id | select_type | table | type | possible_keys   | key  | key_len | ref  | rows | Extra       |</span><br><span class="line">  +----+-------------+-------+------+-----------------+------+---------+------+------+-------------+</span><br><span class="line">  |  1 | SIMPLE      | emp   | ALL  | emp_ename_index | NULL | NULL    | NULL |   14 | Using where |</span><br><span class="line">  +----+-------------+-------+------+-----------------+------+---------+------+------+-------------+</span><br><span class="line"></span><br><span class="line">失效的第3种情况：</span><br><span class="line">  使用复合索引的时候，没有使用左侧的列查找，索引失效</span><br><span class="line">  什么是复合索引？</span><br><span class="line">    两个字段，或者更多的字段联合起来添加一个索引，叫做复合索引。</span><br><span class="line">  </span><br><span class="line">  create index emp_job_sal_index on emp(job,sal);</span><br><span class="line">  </span><br><span class="line">  mysql&gt; explain select * from emp where job = &#x27;MANAGER&#x27;;</span><br><span class="line">  +----+-------------+-------+------+-------------------+-------------------+---------+-------+------+-------------+</span><br><span class="line">  | id | select_type | table | type | possible_keys     | key               | key_len | ref   | rows | Extra       |</span><br><span class="line">  +----+-------------+-------+------+-------------------+-------------------+---------+-------+------+-------------+</span><br><span class="line">  |  1 | SIMPLE      | emp   | ref  | emp_job_sal_index | emp_job_sal_index | 30      | const |    3 | Using where |</span><br><span class="line">  +----+-------------+-------+------+-------------------+-------------------+---------+-------+------+-------------+</span><br><span class="line">  </span><br><span class="line">  mysql&gt; explain select * from emp where sal = 800;</span><br><span class="line">  +----+-------------+-------+------+---------------+------+---------+------+------+-------------+</span><br><span class="line">  | id | select_type | table | type | possible_keys | key  | key_len | ref  | rows | Extra       |</span><br><span class="line">  +----+-------------+-------+------+---------------+------+---------+------+------+-------------+</span><br><span class="line">  |  1 | SIMPLE      | emp   | ALL  | NULL          | NULL | NULL    | NULL |   14 | Using where |</span><br><span class="line">  +----+-------------+-------+------+---------------+------+---------+------+------+-------------+</span><br><span class="line"></span><br><span class="line">失效的第4种情况：</span><br><span class="line">  在where当中索引列参加了运算，索引失效。</span><br><span class="line">  mysql&gt; create index emp_sal_index on emp(sal);</span><br><span class="line"></span><br><span class="line">  explain select * from emp where sal = 800;</span><br><span class="line">  +----+-------------+-------+------+---------------+---------------+---------+-------+------+-------------+</span><br><span class="line">  | id | select_type | table | type | possible_keys | key           | key_len | ref   | rows | Extra       |</span><br><span class="line">  +----+-------------+-------+------+---------------+---------------+---------+-------+------+-------------+</span><br><span class="line">  |  1 | SIMPLE      | emp   | ref  | emp_sal_index | emp_sal_index | 9       | const |    1 | Using where |</span><br><span class="line">  +----+-------------+-------+------+---------------+---------------+---------+-------+------+-------------+</span><br><span class="line"></span><br><span class="line">  mysql&gt; explain select * from emp where sal+1 = 800;</span><br><span class="line">  +----+-------------+-------+------+---------------+------+---------+------+------+-------------+</span><br><span class="line">  | id | select_type | table | type | possible_keys | key  | key_len | ref  | rows | Extra       |</span><br><span class="line">  +----+-------------+-------+------+---------------+------+---------+------+------+-------------+</span><br><span class="line">  |  1 | SIMPLE      | emp   | ALL  | NULL          | NULL | NULL    | NULL |   14 | Using where |</span><br><span class="line">  +----+-------------+-------+------+---------------+------+---------+------+------+-------------+</span><br><span class="line"></span><br><span class="line">失效的第5种情况：</span><br><span class="line">  在where当中索引列使用了函数</span><br><span class="line">  explain select * from emp where lower(ename) = &#x27;smith&#x27;;</span><br><span class="line">  +----+-------------+-------+------+---------------+------+---------+------+------+-------------+</span><br><span class="line">  | id | select_type | table | type | possible_keys | key  | key_len | ref  | rows | Extra       |</span><br><span class="line">  +----+-------------+-------+------+---------------+------+---------+------+------+-------------+</span><br><span class="line">  |  1 | SIMPLE      | emp   | ALL  | NULL          | NULL | NULL    | NULL |   14 | Using where |</span><br><span class="line">  +----+-------------+-------+------+---------------+------+---------+------+------+-------------+</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="索引分类"><a href="#索引分类" class="headerlink" title="索引分类"></a>索引分类</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">单一索引：一个字段上添加索引。</span><br><span class="line">复合索引：两个字段或者更多的字段上添加索引。</span><br><span class="line"></span><br><span class="line">主键索引：主键上添加索引。</span><br><span class="line">唯一性索引：具有unique约束的字段上添加索引。</span><br><span class="line">.....</span><br><span class="line"></span><br><span class="line">注意：唯一性比较弱的字段上添加索引用处不大。</span><br></pre></td></tr></table></figure>

<h1 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h1><blockquote>
<p>什么是视图？</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">视图：站在不同的角度去看待同一份数据。</span><br></pre></td></tr></table></figure>

<h2 id="视图创建和删除"><a href="#视图创建和删除" class="headerlink" title="视图创建和删除"></a>视图创建和删除</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">创建视图对象：</span><br><span class="line">  create view dept2_view as select * from dept2;</span><br><span class="line"></span><br><span class="line">删除视图对象：</span><br><span class="line">  drop view dept2_view;</span><br><span class="line"></span><br><span class="line">注意：只有DQL语句才能以view的形式创建。</span><br><span class="line">  create view view_name as 这里的语句必须是DQL语句;</span><br></pre></td></tr></table></figure>

<h2 id="视图的用途"><a href="#视图的用途" class="headerlink" title="视图的用途"></a>视图的用途</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">《方便，简化开发，利于维护》</span><br><span class="line">我们可以面向视图对象进行增删改查，对视图对象的增删改查，会导致</span><br><span class="line">原表被操作！（视图的特点：通过对视图的操作，会影响到原表数据。）</span><br><span class="line"></span><br><span class="line">//面向视图查询</span><br><span class="line">select * from dept2_view; </span><br><span class="line"></span><br><span class="line">// 面向视图插入</span><br><span class="line">insert into dept2_view(deptno,dname,loc) values(60,&#x27;SALES&#x27;, &#x27;BEIJING&#x27;);</span><br><span class="line"></span><br><span class="line">// 查询原表数据</span><br><span class="line">mysql&gt; select * from dept2;</span><br><span class="line">+--------+------------+----------+</span><br><span class="line">| DEPTNO | DNAME      | LOC      |</span><br><span class="line">+--------+------------+----------+</span><br><span class="line">|     10 | ACCOUNTING | NEW YORK |</span><br><span class="line">|     20 | RESEARCH   | DALLAS   |</span><br><span class="line">|     30 | SALES      | CHICAGO  |</span><br><span class="line">|     40 | OPERATIONS | BOSTON   |</span><br><span class="line">|     60 | SALES      | BEIJING  |</span><br><span class="line">+--------+------------+----------+</span><br><span class="line"></span><br><span class="line">// 面向视图删除</span><br><span class="line">mysql&gt; delete from dept2_view;</span><br><span class="line"></span><br><span class="line">// 查询原表数据</span><br><span class="line">mysql&gt; select * from dept2;</span><br><span class="line">Empty set (0.00 sec)</span><br><span class="line"></span><br><span class="line">假设有一条非常复杂的SQL语句，而这条SQL语句需要在不同的位置上反复使用。</span><br><span class="line">每一次使用这个sql语句的时候都需要重新编写，很长，很麻烦，怎么办？</span><br><span class="line">  可以把这条复杂的SQL语句以视图对象的形式新建。</span><br><span class="line">  在需要编写这条SQL语句的位置直接使用视图对象，可以大大简化开发。</span><br><span class="line">  并且利于后期的维护，因为修改的时候也只需要修改一个位置就行，只需要</span><br><span class="line">  修改视图对象所映射的SQL语句。</span><br><span class="line"></span><br><span class="line">我们以后面向视图开发的时候，使用视图的时候可以像使用table一样。</span><br><span class="line">可以对视图进行增删改查等操作。视图不是在内存当中，视图对象也是</span><br><span class="line">存储在硬盘上的，不会消失。</span><br><span class="line"></span><br><span class="line">再提醒一下：</span><br><span class="line">  视图对应的语句只能是DQL语句。</span><br><span class="line">  但是视图对象创建完成之后，可以对视图进行增删改查等操作。</span><br><span class="line"></span><br><span class="line">小插曲：</span><br><span class="line">  增删改查，又叫做：CRUD。</span><br><span class="line">  CRUD是在公司中程序员之间沟通的术语。一般我们很少说增删改查。</span><br><span class="line">  一般都说CRUD。</span><br><span class="line"></span><br><span class="line">  C:Create（增）</span><br><span class="line">  R:Retrive（查：检索）</span><br><span class="line">  U:Update（改）</span><br><span class="line">  D:Delete（删）</span><br></pre></td></tr></table></figure>

<h1 id="DBA常用命令"><a href="#DBA常用命令" class="headerlink" title="DBA常用命令"></a>DBA常用命令</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">重点掌握：</span><br><span class="line">  数据的导入和导出（数据的备份）</span><br><span class="line">  其它命令了解一下即可。</span><br><span class="line"></span><br><span class="line">数据导出？</span><br><span class="line">  注意：在windows的dos命令窗口中：</span><br><span class="line">    mysqldump bjpowernode&gt;D:\bjpowernode.sql -uroot -p123456</span><br><span class="line">  </span><br><span class="line">  可以导出指定的表吗？</span><br><span class="line">    mysqldump bjpowernode emp&gt;D:\bjpowernode.sql -uroot -p123456</span><br><span class="line"></span><br><span class="line">数据导入？</span><br><span class="line">  注意：需要先登录到mysql数据库服务器上。</span><br><span class="line">  然后创建数据库：create database bjpowernode;</span><br><span class="line">  使用数据库：use bjpowernode</span><br><span class="line">  然后初始化数据库：source D:\bjpowernode.sql</span><br></pre></td></tr></table></figure>

<h1 id="数据库设计三范式"><a href="#数据库设计三范式" class="headerlink" title="数据库设计三范式"></a>数据库设计三范式</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">什么是数据库设计范式？</span><br><span class="line">数据库表的设计依据。教你怎么进行数据库表的设计。</span><br><span class="line"></span><br><span class="line">数据库设计范式共有？</span><br><span class="line">3个。</span><br><span class="line">第一范式：要求任何一张表必须有主键，每一个字段原子性不可再分。</span><br><span class="line"></span><br><span class="line">第二范式：建立在第一范式的基础之上，要求所有非主键字段完全依赖主键，</span><br><span class="line">不要产生部分依赖。</span><br><span class="line"></span><br><span class="line">第三范式：建立在第二范式的基础之上，要求所有非主键字段直接依赖主键，</span><br><span class="line">不要产生传递依赖。</span><br><span class="line"></span><br><span class="line">声明：三范式是面试官经常问的，所以一定要熟记在心！</span><br><span class="line"></span><br><span class="line">设计数据库表的时候，按照以上的范式进行，可以避免表中数据的冗余，空间的浪费。</span><br><span class="line"></span><br><span class="line">第一范式</span><br><span class="line">最核心，最重要的范式，所有表的设计都需要满足。</span><br><span class="line">必须有主键，并且每一个字段都是原子性不可再分。</span><br><span class="line"></span><br><span class="line">学生编号 学生姓名 联系方式</span><br><span class="line">------------------------------------------</span><br><span class="line">1001		张三		zs@gmail.com,1359999999</span><br><span class="line">1002		李四		ls@gmail.com,13699999999</span><br><span class="line">1001		王五		ww@163.net,13488888888</span><br><span class="line"></span><br><span class="line">以上是学生表，满足第一范式吗？</span><br><span class="line">  不满足，第一：没有主键。第二：联系方式可以分为邮箱地址和电话</span><br><span class="line"></span><br><span class="line">学生编号(pk) 学生姓名	邮箱地址			联系电话</span><br><span class="line">----------------------------------------------------</span><br><span class="line">1001				张三		zs@gmail.com	1359999999</span><br><span class="line">1002				李四		ls@gmail.com	13699999999</span><br><span class="line">1003				王五		ww@163.net		13488888888</span><br><span class="line"></span><br><span class="line">第二范式：</span><br><span class="line">建立在第一范式的基础之上，</span><br><span class="line">要求所有非主键字段必须完全依赖主键，不要产生部分依赖。</span><br><span class="line"></span><br><span class="line">学生编号 学生姓名 教师编号 教师姓名</span><br><span class="line">----------------------------------------------------</span><br><span class="line">1001			张三		001		王老师</span><br><span class="line">1002			李四		002		赵老师</span><br><span class="line">1003			王五		001		王老师</span><br><span class="line">1001			张三		002		赵老师</span><br><span class="line"></span><br><span class="line">这张表描述了学生和老师的关系：（1个学生可能有多个老师，1个老师有多个学生）</span><br><span class="line">这是非常典型的：多对多关系！</span><br><span class="line"></span><br><span class="line">分析以上的表是否满足第一范式？</span><br><span class="line">  不满足第一范式。</span><br><span class="line"></span><br><span class="line">怎么满足第一范式呢？修改</span><br><span class="line"></span><br><span class="line">学生编号+教师编号(pk)		学生姓名  教师姓名</span><br><span class="line">----------------------------------------------------</span><br><span class="line">1001			001				张三			王老师</span><br><span class="line">1002			002				李四			赵老师</span><br><span class="line">1003			001				王五			王老师</span><br><span class="line">1001			002				张三			赵老师</span><br><span class="line"></span><br><span class="line">学生编号 教师编号，两个字段联合做主键，复合主键（PK: 学生编号+教师编号）</span><br><span class="line">经过修改之后，以上的表满足了第一范式。但是满足第二范式吗？</span><br><span class="line">  不满足，“张三”依赖1001，“王老师”依赖001，显然产生了部分依赖。</span><br><span class="line">  产生部分依赖有什么缺点？</span><br><span class="line">    数据冗余了。空间浪费了。“张三”重复了，“王老师”重复了。</span><br><span class="line"></span><br><span class="line">为了让以上的表满足第二范式，你需要这样设计：</span><br><span class="line">  使用三张表来表示多对多的关系！！！！</span><br><span class="line">  学生表</span><br><span class="line">  学生编号(pk)		学生名字</span><br><span class="line">  ------------------------------------</span><br><span class="line">  1001					张三</span><br><span class="line">  1002					李四</span><br><span class="line">  1003					王五</span><br><span class="line">  </span><br><span class="line">  教师表</span><br><span class="line">  教师编号(pk)		教师姓名</span><br><span class="line">  --------------------------------------</span><br><span class="line">  001					王老师</span><br><span class="line">  002					赵老师</span><br><span class="line"></span><br><span class="line">  学生教师关系表</span><br><span class="line">  id(pk)			学生编号(fk)			教师编号(fk)</span><br><span class="line">  ------------------------------------------------------</span><br><span class="line">  1						1001						001</span><br><span class="line">  2						1002						002</span><br><span class="line">  3						1003						001</span><br><span class="line">  4						1001						002</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">背口诀：</span><br><span class="line">  多对多怎么设计？</span><br><span class="line">    多对多，三张表，关系表两个外键！！！！！！！！！！！！！！！</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">第三范式</span><br><span class="line">第三范式建立在第二范式的基础之上</span><br><span class="line">要求所有非主键字典必须直接依赖主键，不要产生传递依赖。</span><br><span class="line"></span><br><span class="line">学生编号（PK） 学生姓名 班级编号  班级名称</span><br><span class="line">---------------------------------------------------------</span><br><span class="line">  1001				张三		01			一年一班</span><br><span class="line">  1002				李四		02			一年二班</span><br><span class="line">  1003				王五		03			一年三班</span><br><span class="line">  1004				赵六		03			一年三班</span><br><span class="line"></span><br><span class="line">以上表的设计是描述：班级和学生的关系。很显然是1对多关系！</span><br><span class="line">一个教室中有多个学生。</span><br><span class="line"></span><br><span class="line">分析以上表是否满足第一范式？</span><br><span class="line">  满足第一范式，有主键。</span><br><span class="line"></span><br><span class="line">分析以上表是否满足第二范式？</span><br><span class="line">  满足第二范式，因为主键不是复合主键，没有产生部分依赖。主键是单一主键。</span><br><span class="line"></span><br><span class="line">分析以上表是否满足第三范式？</span><br><span class="line">  第三范式要求：不要产生传递依赖！</span><br><span class="line">  一年一班依赖01，01依赖1001，产生了传递依赖。</span><br><span class="line">  不符合第三范式的要求。产生了数据的冗余。</span><br><span class="line"></span><br><span class="line">那么应该怎么设计一对多呢？</span><br><span class="line"></span><br><span class="line">  班级表：一</span><br><span class="line">  班级编号(pk)				班级名称</span><br><span class="line">  ----------------------------------------</span><br><span class="line">  01								一年一班</span><br><span class="line">  02								一年二班</span><br><span class="line">  03								一年三班</span><br><span class="line"></span><br><span class="line">  学生表：多</span><br><span class="line"></span><br><span class="line">  学生编号（PK） 学生姓名 班级编号(fk)</span><br><span class="line">  -------------------------------------------</span><br><span class="line">  1001				张三			01			</span><br><span class="line">  1002				李四			02			</span><br><span class="line">  1003				王五			03			</span><br><span class="line">  1004				赵六			03		</span><br><span class="line">  </span><br><span class="line">  背口诀：</span><br><span class="line">    一对多，两张表，多的表加外键！！！！！！！！！！！！</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="总结表的设计"><a href="#总结表的设计" class="headerlink" title="总结表的设计"></a>总结表的设计</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">一对多：</span><br><span class="line">  一对多，两张表，多的表加外键！！！！！！！！！！！！</span><br><span class="line"></span><br><span class="line">多对多：</span><br><span class="line">  多对多，三张表，关系表两个外键！！！！！！！！！！！！！！！</span><br><span class="line"></span><br><span class="line">一对一：</span><br><span class="line">一对一放到一张表中不就行了吗？为啥还要拆分表？</span><br><span class="line">在实际的开发中，可能存在一张表字段太多，太庞大。这个时候要拆分表。</span><br><span class="line">一对一怎么设计？</span><br><span class="line">  没有拆分表之前：一张表</span><br><span class="line">    t_user</span><br><span class="line">    id		login_name		login_pwd		real_name		email				address........</span><br><span class="line">    ---------------------------------------------------------------------------</span><br><span class="line">    1			zhangsan		123				张三				zhangsan@xxx</span><br><span class="line">    2			lisi			123				李四				lisi@xxx</span><br><span class="line">    ...</span><br><span class="line">  </span><br><span class="line">  这种庞大的表建议拆分为两张：</span><br><span class="line">    t_login 登录信息表</span><br><span class="line">    id(pk)		login_name		login_pwd	</span><br><span class="line">    ---------------------------------</span><br><span class="line">    1				zhangsan		123			</span><br><span class="line">    2				lisi			123			</span><br><span class="line"></span><br><span class="line">    t_user 用户详细信息表</span><br><span class="line">    id(pk)		real_name		email				address........	login_id(fk+unique)</span><br><span class="line">    -----------------------------------------------------------------------------------------</span><br><span class="line">    100			张三				zhangsan@xxx								1</span><br><span class="line">    200			李四				lisi@xxx									2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    口诀：一对一，外键唯一！！！！！！！！！！</span><br></pre></td></tr></table></figure>

<h1 id="嘱咐"><a href="#嘱咐" class="headerlink" title="嘱咐"></a>嘱咐</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">数据库设计三范式是理论上的。</span><br><span class="line"></span><br><span class="line">实践和理论有的时候有偏差。</span><br><span class="line"></span><br><span class="line">最终的目的都是为了满足客户的需求，有的时候会拿冗余换执行速度。</span><br><span class="line"></span><br><span class="line">因为在sql当中，表和表之间连接次数越多，效率越低。（笛卡尔积）</span><br><span class="line"></span><br><span class="line">有的时候可能会存在冗余，但是为了减少表的连接次数，这样做也是合理的，</span><br><span class="line">并且对于开发人员来说，sql语句的编写难度也会降低。</span><br><span class="line"></span><br><span class="line">面试的时候把这句话说上：他就不会认为你是初级程序员了！</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>IDEA中快速添加main、System方法</title>
    <url>/2021/09/06/IDEA%E4%B8%AD%E5%BF%AB%E9%80%9F%E6%B7%BB%E5%8A%A0main%E3%80%81System%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p><strong>IDEA中快速添加main、System方法：</strong></p>
<p>今天就研究了一下如何在IEDA中实现下面2个功能:</p>
<ol>
<li>写main就能补全main方法</li>
<li>写syso就能补全System.out.println（）</li>
</ol>
<span id="more"></span>

<p>参考:<a href="https://blog.csdn.net/wangpengzhi19891223/article/details/78950047/?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-0.no_search_link&spm=1001.2101.3001.4242">IDEA中快速添加main、System方法</a></p>
]]></content>
      <categories>
        <category>idea</category>
      </categories>
  </entry>
  <entry>
    <title></title>
    <url>/2022/03/03/SpringMVC%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>[TOC]</p>
<h1 id="一、SpringMVC简介"><a href="#一、SpringMVC简介" class="headerlink" title="一、SpringMVC简介"></a>一、SpringMVC简介</h1><h3 id="1、什么是MVC"><a href="#1、什么是MVC" class="headerlink" title="1、什么是MVC"></a>1、什么是MVC</h3><p>MVC是一种软件架构的思想，将软件按照模型、视图、控制器来划分</p>
<p>M：Model，模型层，指工程中的JavaBean，作用是处理数据</p>
<p>JavaBean分为两类：</p>
<ul>
<li>一类称为实体类Bean：专门存储业务数据的，如 Student、User 等</li>
<li>一类称为业务处理 Bean：指 Service 或 Dao 对象，专门用于处理业务逻辑和数据访问。</li>
</ul>
<p>V：View，视图层，指工程中的html或jsp等页面，作用是与用户进行交互，展示数据</p>
<p>C：Controller，控制层，指工程中的servlet，作用是接收请求和响应浏览器</p>
<p>MVC的工作流程：<br>用户通过视图层发送请求到服务器，在服务器中请求被Controller接收，Controller调用相应的Model层处理请求，处理完毕将结果返回到Controller，Controller再根据请求处理的结果找到相应的View视图，渲染数据后最终响应给浏览器</p>
<h3 id="2、什么是SpringMVC"><a href="#2、什么是SpringMVC" class="headerlink" title="2、什么是SpringMVC"></a>2、什么是SpringMVC</h3><p>SpringMVC是Spring的一个后续产品，是Spring的一个子项目</p>
<p>SpringMVC 是 Spring 为表述层开发提供的一整套完备的解决方案。在表述层框架历经 Strust、WebWork、Strust2 等诸多产品的历代更迭之后，目前业界普遍选择了 SpringMVC 作为 Java EE 项目表述层开发的<strong>首选方案</strong>。</p>
<blockquote>
<p>注：三层架构分为表述层（或表示层）、业务逻辑层、数据访问层，表述层表示前台页面和后台servlet</p>
</blockquote>
<h3 id="3、SpringMVC的特点"><a href="#3、SpringMVC的特点" class="headerlink" title="3、SpringMVC的特点"></a>3、SpringMVC的特点</h3><ul>
<li><strong>Spring 家族原生产品</strong>，与 IOC 容器等基础设施无缝对接</li>
<li><strong>基于原生的Servlet</strong>，通过了功能强大的<strong>前端控制器DispatcherServlet</strong>，对请求和响应进行统一处理</li>
<li>表述层各细分领域需要解决的问题<strong>全方位覆盖</strong>，提供<strong>全面解决方案</strong></li>
<li><strong>代码清新简洁</strong>，大幅度提升开发效率</li>
<li>内部组件化程度高，可插拔式组件<strong>即插即用</strong>，想要什么功能配置相应组件即可</li>
<li><strong>性能卓著</strong>，尤其适合现代大型、超大型互联网项目要求</li>
</ul>
<h1 id="二、HelloWorld"><a href="#二、HelloWorld" class="headerlink" title="二、HelloWorld"></a>二、HelloWorld</h1><h3 id="1、开发环境"><a href="#1、开发环境" class="headerlink" title="1、开发环境"></a>1、开发环境</h3><p>IDE：idea 2019.2</p>
<p>构建工具：maven3.5.4</p>
<p>服务器：tomcat7</p>
<p>Spring版本：5.3.1</p>
<h3 id="2、创建maven工程"><a href="#2、创建maven工程" class="headerlink" title="2、创建maven工程"></a>2、创建maven工程</h3><h5 id="a-gt-添加web模块"><a href="#a-gt-添加web模块" class="headerlink" title="a&gt;添加web模块"></a>a&gt;添加web模块</h5><h5 id="b-gt-打包方式：war"><a href="#b-gt-打包方式：war" class="headerlink" title="b&gt;打包方式：war"></a>b&gt;打包方式：war</h5><h5 id="c-gt-引入依赖"><a href="#c-gt-引入依赖" class="headerlink" title="c&gt;引入依赖"></a>c&gt;引入依赖</h5><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- SpringMVC --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 日志 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ch.qos.logback<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>logback-classic<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- ServletAPI --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- Spring5和Thymeleaf整合包 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.thymeleaf<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>thymeleaf-spring5<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.12.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>注：由于 Maven 的传递性，我们不必将所有需要的包全部配置依赖，而是配置最顶端的依赖，其他靠传递性导入。</p>
<p><img src="/2022/03/03/SpringMVC%E7%AC%94%E8%AE%B0/img%5Cimg001.png" alt="images"></p>
<h3 id="3、配置web-xml"><a href="#3、配置web-xml" class="headerlink" title="3、配置web.xml"></a>3、配置web.xml</h3><p>注册SpringMVC的前端控制器DispatcherServlet</p>
<h5 id="a-gt-默认配置方式"><a href="#a-gt-默认配置方式" class="headerlink" title="a&gt;默认配置方式"></a>a&gt;默认配置方式</h5><p>此配置作用下，SpringMVC的配置文件默认位于WEB-INF下，默认名称为&lt;servlet-name&gt;-servlet.xml，例如，以下配置所对应SpringMVC的配置文件位于WEB-INF下，文件名为springMVC-servlet.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置SpringMVC的前端控制器，对浏览器发送的请求统一进行处理 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springMVC<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springMVC<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        设置springMVC的核心控制器所能处理的请求的请求路径</span></span><br><span class="line"><span class="comment">        /所匹配的请求可以是/login或.html或.js或.css方式的请求路径</span></span><br><span class="line"><span class="comment">        但是/不能匹配.jsp请求路径的请求</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="b-gt-扩展配置方式"><a href="#b-gt-扩展配置方式" class="headerlink" title="b&gt;扩展配置方式"></a>b&gt;扩展配置方式</h5><p>可通过init-param标签设置SpringMVC配置文件的位置和名称，通过load-on-startup标签设置SpringMVC前端控制器DispatcherServlet的初始化时间</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置SpringMVC的前端控制器，对浏览器发送的请求统一进行处理 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springMVC<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 通过初始化参数指定SpringMVC配置文件的位置和名称 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- contextConfigLocation为固定值 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 使用classpath:表示从类路径查找配置文件，例如maven工程中的src/main/resources --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:springMVC.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment"> 		作为框架的核心组件，在启动过程中有大量的初始化操作要做</span></span><br><span class="line"><span class="comment">		而这些操作放在第一次请求时才执行会严重影响访问速度</span></span><br><span class="line"><span class="comment">		因此需要通过此标签将启动控制DispatcherServlet的初始化时间提前到服务器启动时</span></span><br><span class="line"><span class="comment">	--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springMVC<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        设置springMVC的核心控制器所能处理的请求的请求路径</span></span><br><span class="line"><span class="comment">        /所匹配的请求可以是/login或.html或.js或.css方式的请求路径</span></span><br><span class="line"><span class="comment">        但是/不能匹配.jsp请求路径的请求</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注：</p>
<p>&lt;url-pattern&gt;标签中使用/和/*的区别：</p>
<p>/所匹配的请求可以是/login或.html或.js或.css方式的请求路径，但是/不能匹配.jsp请求路径的请求</p>
<p>因此就可以避免在访问jsp页面时，该请求被DispatcherServlet处理，从而找不到相应的页面</p>
<p>/*则能够匹配所有请求，例如在使用过滤器时，若需要对所有请求进行过滤，就需要使用/*的写法</p>
</blockquote>
<h3 id="4、创建请求控制器"><a href="#4、创建请求控制器" class="headerlink" title="4、创建请求控制器"></a>4、创建请求控制器</h3><p>由于前端控制器对浏览器发送的请求进行了统一的处理，但是具体的请求有不同的处理过程，因此需要创建处理具体请求的类，即请求控制器</p>
<p>请求控制器中每一个处理请求的方法成为控制器方法</p>
<p>因为SpringMVC的控制器由一个POJO（普通的Java类）担任，因此需要通过@Controller注解将其标识为一个控制层组件，交给Spring的IoC容器管理，此时SpringMVC才能够识别控制器的存在</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5、创建springMVC的配置文件"><a href="#5、创建springMVC的配置文件" class="headerlink" title="5、创建springMVC的配置文件"></a>5、创建springMVC的配置文件</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 自动扫描包 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.atguigu.mvc.controller&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 配置Thymeleaf视图解析器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;viewResolver&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.thymeleaf.spring5.view.ThymeleafViewResolver&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;order&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;characterEncoding&quot;</span> <span class="attr">value</span>=<span class="string">&quot;UTF-8&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;templateEngine&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.thymeleaf.spring5.SpringTemplateEngine&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;templateResolver&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.thymeleaf.spring5.templateresolver.SpringResourceTemplateResolver&quot;</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">                    <span class="comment">&lt;!-- 视图前缀 --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;prefix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;/WEB-INF/templates/&quot;</span>/&gt;</span></span><br><span class="line">    </span><br><span class="line">                    <span class="comment">&lt;!-- 视图后缀 --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suffix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;.html&quot;</span>/&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;templateMode&quot;</span> <span class="attr">value</span>=<span class="string">&quot;HTML5&quot;</span>/&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;characterEncoding&quot;</span> <span class="attr">value</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">   处理静态资源，例如html、js、css、jpg</span></span><br><span class="line"><span class="comment">  若只设置该标签，则只能访问静态资源，其他请求则无法访问</span></span><br><span class="line"><span class="comment">  此时必须设置&lt;mvc:annotation-driven/&gt;解决问题</span></span><br><span class="line"><span class="comment"> --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:default-servlet-handler</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 开启mvc注解驱动 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:message-converters</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 处理响应中文内容乱码 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.http.converter.StringHttpMessageConverter&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;defaultCharset&quot;</span> <span class="attr">value</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;supportedMediaTypes&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">value</span>&gt;</span>text/html<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">value</span>&gt;</span>application/json<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mvc:message-converters</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:annotation-driven</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="6、测试HelloWorld"><a href="#6、测试HelloWorld" class="headerlink" title="6、测试HelloWorld"></a>6、测试HelloWorld</h3><h5 id="a-gt-实现对首页的访问"><a href="#a-gt-实现对首页的访问" class="headerlink" title="a&gt;实现对首页的访问"></a>a&gt;实现对首页的访问</h5><p>在请求控制器中创建处理请求的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// @RequestMapping注解：处理请求和控制器方法之间的映射关系</span></span><br><span class="line"><span class="comment">// @RequestMapping注解的value属性可以通过请求地址匹配请求，/表示的当前工程的上下文路径</span></span><br><span class="line"><span class="comment">// localhost:8080/springMVC/</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">index</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//设置视图名称</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;index&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="b-gt-通过超链接跳转到指定页面"><a href="#b-gt-通过超链接跳转到指定页面" class="headerlink" title="b&gt;通过超链接跳转到指定页面"></a>b&gt;通过超链接跳转到指定页面</h5><p>在主页index.html中设置超链接</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span> <span class="attr">xmlns:th</span>=<span class="string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/hello&#125;&quot;</span>&gt;</span>HelloWorld<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在请求控制器中创建处理请求的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/hello&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">HelloWorld</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;target&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7、总结"><a href="#7、总结" class="headerlink" title="7、总结"></a>7、总结</h3><p>浏览器发送请求，若请求地址符合前端控制器的url-pattern，该请求就会被前端控制器DispatcherServlet处理。前端控制器会读取SpringMVC的核心配置文件，通过扫描组件找到控制器，将请求地址和控制器中@RequestMapping注解的value属性值进行匹配，若匹配成功，该注解所标识的控制器方法就是处理请求的方法。处理请求的方法需要返回一个字符串类型的视图名称，该视图名称会被视图解析器解析，加上前缀和后缀组成视图的路径，通过Thymeleaf对视图进行渲染，最终转发到视图所对应页面</p>
<h1 id="三、-RequestMapping注解"><a href="#三、-RequestMapping注解" class="headerlink" title="三、@RequestMapping注解"></a>三、@RequestMapping注解</h1><h3 id="1、-RequestMapping注解的功能"><a href="#1、-RequestMapping注解的功能" class="headerlink" title="1、@RequestMapping注解的功能"></a>1、@RequestMapping注解的功能</h3><p>从注解名称上我们可以看到，@RequestMapping注解的作用就是将请求和处理请求的控制器方法关联起来，建立映射关系。</p>
<p>SpringMVC 接收到指定的请求，就会来找到在映射关系中对应的控制器方法来处理这个请求。</p>
<h3 id="2、-RequestMapping注解的位置"><a href="#2、-RequestMapping注解的位置" class="headerlink" title="2、@RequestMapping注解的位置"></a>2、@RequestMapping注解的位置</h3><p>@RequestMapping标识一个类：设置映射请求的请求路径的初始信息</p>
<p>@RequestMapping标识一个方法：设置映射请求请求路径的具体信息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/test&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestMappingController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//此时请求映射所映射的请求的请求路径为：/test/testRequestMapping</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/testRequestMapping&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">testRequestMapping</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3、-RequestMapping注解的value属性"><a href="#3、-RequestMapping注解的value属性" class="headerlink" title="3、@RequestMapping注解的value属性"></a>3、@RequestMapping注解的value属性</h3><p>@RequestMapping注解的value属性通过请求的请求地址匹配请求映射</p>
<p>@RequestMapping注解的value属性是一个字符串类型的数组，表示该请求映射能够匹配多个请求地址所对应的请求</p>
<p>@RequestMapping注解的value属性必须设置，至少通过请求地址匹配请求映射</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/testRequestMapping&#125;&quot;</span>&gt;</span>测试@RequestMapping的value属性--&gt;/testRequestMapping<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/test&#125;&quot;</span>&gt;</span>测试@RequestMapping的value属性--&gt;/test<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(</span></span><br><span class="line"><span class="meta">        value = &#123;&quot;/testRequestMapping&quot;, &quot;/test&quot;&#125;</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testRequestMapping</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4、-RequestMapping注解的method属性"><a href="#4、-RequestMapping注解的method属性" class="headerlink" title="4、@RequestMapping注解的method属性"></a>4、@RequestMapping注解的method属性</h3><p>@RequestMapping注解的method属性通过请求的请求方式（get或post）匹配请求映射</p>
<p>@RequestMapping注解的method属性是一个RequestMethod类型的数组，表示该请求映射能够匹配多种请求方式的请求</p>
<p>若当前请求的请求地址满足请求映射的value属性，但是请求方式不满足method属性，则浏览器报错405：Request method ‘POST’ not supported</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/test&#125;&quot;</span>&gt;</span>测试@RequestMapping的value属性--&gt;/test<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">th:action</span>=<span class="string">&quot;@&#123;/test&#125;&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(</span></span><br><span class="line"><span class="meta">        value = &#123;&quot;/testRequestMapping&quot;, &quot;/test&quot;&#125;,</span></span><br><span class="line"><span class="meta">        method = &#123;RequestMethod.GET, RequestMethod.POST&#125;</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testRequestMapping</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注：</p>
<p>1、对于处理指定请求方式的控制器方法，SpringMVC中提供了@RequestMapping的派生注解</p>
<p>处理get请求的映射–&gt;@GetMapping</p>
<p>处理post请求的映射–&gt;@PostMapping</p>
<p>处理put请求的映射–&gt;@PutMapping</p>
<p>处理delete请求的映射–&gt;@DeleteMapping</p>
<p>2、常用的请求方式有get，post，put，delete</p>
<p>但是目前浏览器只支持get和post，若在form表单提交时，为method设置了其他请求方式的字符串（put或delete），则按照默认的请求方式get处理</p>
<p>若要发送put和delete请求，则需要通过spring提供的过滤器HiddenHttpMethodFilter，在RESTful部分会讲到</p>
</blockquote>
<h3 id="5、-RequestMapping注解的params属性（了解）"><a href="#5、-RequestMapping注解的params属性（了解）" class="headerlink" title="5、@RequestMapping注解的params属性（了解）"></a>5、@RequestMapping注解的params属性（了解）</h3><p>@RequestMapping注解的params属性通过请求的请求参数匹配请求映射</p>
<p>@RequestMapping注解的params属性是一个字符串类型的数组，可以通过四种表达式设置请求参数和请求映射的匹配关系</p>
<p>“param”：要求请求映射所匹配的请求必须携带param请求参数</p>
<p>“!param”：要求请求映射所匹配的请求必须不能携带param请求参数</p>
<p>“param=value”：要求请求映射所匹配的请求必须携带param请求参数且param=value</p>
<p>“param!=value”：要求请求映射所匹配的请求必须携带param请求参数但是param!=value</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/test(username=&#x27;admin&#x27;,password=123456)&quot;</span>&gt;</span>测试@RequestMapping的params属性--&gt;/test<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(</span></span><br><span class="line"><span class="meta">        value = &#123;&quot;/testRequestMapping&quot;, &quot;/test&quot;&#125;</span></span><br><span class="line"><span class="meta">        ,method = &#123;RequestMethod.GET, RequestMethod.POST&#125;</span></span><br><span class="line"><span class="meta">        ,params = &#123;&quot;username&quot;,&quot;password!=123456&quot;&#125;</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testRequestMapping</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注：</p>
<p>若当前请求满足@RequestMapping注解的value和method属性，但是不满足params属性，此时页面回报错400：Parameter conditions “username, password!=123456” not met for actual request parameters: username={admin}, password={123456}</p>
</blockquote>
<h3 id="6、-RequestMapping注解的headers属性（了解）"><a href="#6、-RequestMapping注解的headers属性（了解）" class="headerlink" title="6、@RequestMapping注解的headers属性（了解）"></a>6、@RequestMapping注解的headers属性（了解）</h3><p>@RequestMapping注解的headers属性通过请求的请求头信息匹配请求映射</p>
<p>@RequestMapping注解的headers属性是一个字符串类型的数组，可以通过四种表达式设置请求头信息和请求映射的匹配关系</p>
<p>“header”：要求请求映射所匹配的请求必须携带header请求头信息</p>
<p>“!header”：要求请求映射所匹配的请求必须不能携带header请求头信息</p>
<p>“header=value”：要求请求映射所匹配的请求必须携带header请求头信息且header=value</p>
<p>“header!=value”：要求请求映射所匹配的请求必须携带header请求头信息且header!=value</p>
<p>若当前请求满足@RequestMapping注解的value和method属性，但是不满足headers属性，此时页面显示404错误，即资源未找到</p>
<h3 id="7、SpringMVC支持ant风格的路径"><a href="#7、SpringMVC支持ant风格的路径" class="headerlink" title="7、SpringMVC支持ant风格的路径"></a>7、SpringMVC支持ant风格的路径</h3><p>？：表示任意的单个字符</p>
<p>*：表示任意的0个或多个字符</p>
<p>**：表示任意的一层或多层目录</p>
<p>注意：在使用**时，只能使用/**/xxx的方式</p>
<h3 id="8、SpringMVC支持路径中的占位符（重点）"><a href="#8、SpringMVC支持路径中的占位符（重点）" class="headerlink" title="8、SpringMVC支持路径中的占位符（重点）"></a>8、SpringMVC支持路径中的占位符（重点）</h3><p>原始方式：/deleteUser?id=1</p>
<p>rest方式：/deleteUser/1</p>
<p>SpringMVC路径中的占位符常用于RESTful风格中，当请求路径中将某些数据通过路径的方式传输到服务器中，就可以在相应的@RequestMapping注解的value属性中通过占位符{xxx}表示传输的数据，在通过@PathVariable注解，将占位符所表示的数据赋值给控制器方法的形参</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/testRest/1/admin&#125;&quot;</span>&gt;</span>测试路径中的占位符--&gt;/testRest<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testRest/&#123;id&#125;/&#123;username&#125;&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testRest</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> String id, <span class="meta">@PathVariable(&quot;username&quot;)</span> String username)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;id:&quot;</span>+id+<span class="string">&quot;,username:&quot;</span>+username);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//最终输出的内容为--&gt;id:1,username:admin</span></span><br></pre></td></tr></table></figure>

<h1 id="四、SpringMVC获取请求参数"><a href="#四、SpringMVC获取请求参数" class="headerlink" title="四、SpringMVC获取请求参数"></a>四、SpringMVC获取请求参数</h1><h3 id="1、通过ServletAPI获取"><a href="#1、通过ServletAPI获取" class="headerlink" title="1、通过ServletAPI获取"></a>1、通过ServletAPI获取</h3><p>将HttpServletRequest作为控制器方法的形参，此时HttpServletRequest类型的参数表示封装了当前请求的请求报文的对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testParam&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testParam</span><span class="params">(HttpServletRequest request)</span></span>&#123;</span><br><span class="line">    String username = request.getParameter(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">    String password = request.getParameter(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;username:&quot;</span>+username+<span class="string">&quot;,password:&quot;</span>+password);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2、通过控制器方法的形参获取请求参数"><a href="#2、通过控制器方法的形参获取请求参数" class="headerlink" title="2、通过控制器方法的形参获取请求参数"></a>2、通过控制器方法的形参获取请求参数</h3><p>在控制器方法的形参位置，设置和请求参数同名的形参，当浏览器发送请求，匹配到请求映射时，在DispatcherServlet中就会将请求参数赋值给相应的形参</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/testParam(username=&#x27;admin&#x27;,password=123456)&#125;&quot;</span>&gt;</span>测试获取请求参数--&gt;/testParam<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testParam&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testParam</span><span class="params">(String username, String password)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;username:&quot;</span>+username+<span class="string">&quot;,password:&quot;</span>+password);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注：</p>
<p>若请求所传输的请求参数中有多个同名的请求参数，此时可以在控制器方法的形参中设置字符串数组或者字符串类型的形参接收此请求参数</p>
<p>若使用字符串数组类型的形参，此参数的数组中包含了每一个数据</p>
<p>若使用字符串类型的形参，此参数的值为每个数据中间使用逗号拼接的结果</p>
</blockquote>
<h3 id="3、-RequestParam"><a href="#3、-RequestParam" class="headerlink" title="3、@RequestParam"></a>3、@RequestParam</h3><p>@RequestParam是将请求参数和控制器方法的形参创建映射关系</p>
<p>@RequestParam注解一共有三个属性：</p>
<p>value：指定为形参赋值的请求参数的参数名</p>
<p>required：设置是否必须传输此请求参数，默认值为true</p>
<p>若设置为true时，则当前请求必须传输value所指定的请求参数，若没有传输该请求参数，且没有设置defaultValue属性，则页面报错400：Required String parameter ‘xxx’ is not present；若设置为false，则当前请求不是必须传输value所指定的请求参数，若没有传输，则注解所标识的形参的值为null</p>
<p>defaultValue：不管required属性值为true或false，当value所指定的请求参数没有传输或传输的值为””时，则使用默认值为形参赋值</p>
<h3 id="4、-RequestHeader"><a href="#4、-RequestHeader" class="headerlink" title="4、@RequestHeader"></a>4、@RequestHeader</h3><p>@RequestHeader是将请求头信息和控制器方法的形参创建映射关系</p>
<p>@RequestHeader注解一共有三个属性：value、required、defaultValue，用法同@RequestParam</p>
<h3 id="5、-CookieValue"><a href="#5、-CookieValue" class="headerlink" title="5、@CookieValue"></a>5、@CookieValue</h3><p>@CookieValue是将cookie数据和控制器方法的形参创建映射关系</p>
<p>@CookieValue注解一共有三个属性：value、required、defaultValue，用法同@RequestParam</p>
<h3 id="6、通过POJO获取请求参数"><a href="#6、通过POJO获取请求参数" class="headerlink" title="6、通过POJO获取请求参数"></a>6、通过POJO获取请求参数</h3><p>可以在控制器方法的形参位置设置一个实体类类型的形参，此时若浏览器传输的请求参数的参数名和实体类中的属性名一致，那么请求参数就会为此属性赋值</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">th:action</span>=<span class="string">&quot;@&#123;/testpojo&#125;&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">    用户名：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    密码：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    性别：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">value</span>=<span class="string">&quot;男&quot;</span>&gt;</span>男<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">value</span>=<span class="string">&quot;女&quot;</span>&gt;</span>女<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    年龄：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    邮箱：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;email&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testpojo&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testPOJO</span><span class="params">(User user)</span></span>&#123;</span><br><span class="line">    System.out.println(user);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//最终结果--&gt;User&#123;id=null, username=&#x27;张三&#x27;, password=&#x27;123&#x27;, age=23, sex=&#x27;男&#x27;, email=&#x27;123@qq.com&#x27;&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="7、解决获取请求参数的乱码问题"><a href="#7、解决获取请求参数的乱码问题" class="headerlink" title="7、解决获取请求参数的乱码问题"></a>7、解决获取请求参数的乱码问题</h3><p>解决获取请求参数的乱码问题，可以使用SpringMVC提供的编码过滤器CharacterEncodingFilter，但是必须在web.xml中进行注册</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置springMVC的编码过滤器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>forceResponseEncoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注：</p>
<p>SpringMVC中处理编码的过滤器一定要配置到其他过滤器之前，否则无效</p>
</blockquote>
<h1 id="五、域对象共享数据"><a href="#五、域对象共享数据" class="headerlink" title="五、域对象共享数据"></a>五、域对象共享数据</h1><h3 id="1、使用ServletAPI向request域对象共享数据"><a href="#1、使用ServletAPI向request域对象共享数据" class="headerlink" title="1、使用ServletAPI向request域对象共享数据"></a>1、使用ServletAPI向request域对象共享数据</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testServletAPI&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testServletAPI</span><span class="params">(HttpServletRequest request)</span></span>&#123;</span><br><span class="line">    request.setAttribute(<span class="string">&quot;testScope&quot;</span>, <span class="string">&quot;hello,servletAPI&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2、使用ModelAndView向request域对象共享数据"><a href="#2、使用ModelAndView向request域对象共享数据" class="headerlink" title="2、使用ModelAndView向request域对象共享数据"></a>2、使用ModelAndView向request域对象共享数据</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testModelAndView&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ModelAndView <span class="title">testModelAndView</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ModelAndView有Model和View的功能</span></span><br><span class="line"><span class="comment">     * Model主要用于向请求域共享数据</span></span><br><span class="line"><span class="comment">     * View主要用于设置视图，实现页面跳转</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ModelAndView mav = <span class="keyword">new</span> ModelAndView();</span><br><span class="line">    <span class="comment">//向请求域共享数据</span></span><br><span class="line">    mav.addObject(<span class="string">&quot;testScope&quot;</span>, <span class="string">&quot;hello,ModelAndView&quot;</span>);</span><br><span class="line">    <span class="comment">//设置视图，实现页面跳转</span></span><br><span class="line">    mav.setViewName(<span class="string">&quot;success&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> mav;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3、使用Model向request域对象共享数据"><a href="#3、使用Model向request域对象共享数据" class="headerlink" title="3、使用Model向request域对象共享数据"></a>3、使用Model向request域对象共享数据</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testModel&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testModel</span><span class="params">(Model model)</span></span>&#123;</span><br><span class="line">    model.addAttribute(<span class="string">&quot;testScope&quot;</span>, <span class="string">&quot;hello,Model&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4、使用map向request域对象共享数据"><a href="#4、使用map向request域对象共享数据" class="headerlink" title="4、使用map向request域对象共享数据"></a>4、使用map向request域对象共享数据</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testMap&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testMap</span><span class="params">(Map&lt;String, Object&gt; map)</span></span>&#123;</span><br><span class="line">    map.put(<span class="string">&quot;testScope&quot;</span>, <span class="string">&quot;hello,Map&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5、使用ModelMap向request域对象共享数据"><a href="#5、使用ModelMap向request域对象共享数据" class="headerlink" title="5、使用ModelMap向request域对象共享数据"></a>5、使用ModelMap向request域对象共享数据</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testModelMap&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testModelMap</span><span class="params">(ModelMap modelMap)</span></span>&#123;</span><br><span class="line">    modelMap.addAttribute(<span class="string">&quot;testScope&quot;</span>, <span class="string">&quot;hello,ModelMap&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6、Model、ModelMap、Map的关系"><a href="#6、Model、ModelMap、Map的关系" class="headerlink" title="6、Model、ModelMap、Map的关系"></a>6、Model、ModelMap、Map的关系</h3><p>Model、ModelMap、Map类型的参数其实本质上都是 BindingAwareModelMap 类型的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public interface Model&#123;&#125;</span><br><span class="line">public class ModelMap extends LinkedHashMap&lt;String, Object&gt; &#123;&#125;</span><br><span class="line">public class ExtendedModelMap extends ModelMap implements Model &#123;&#125;</span><br><span class="line">public class BindingAwareModelMap extends ExtendedModelMap &#123;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7、向session域共享数据"><a href="#7、向session域共享数据" class="headerlink" title="7、向session域共享数据"></a>7、向session域共享数据</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testSession&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testSession</span><span class="params">(HttpSession session)</span></span>&#123;</span><br><span class="line">    session.setAttribute(<span class="string">&quot;testSessionScope&quot;</span>, <span class="string">&quot;hello,session&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="8、向application域共享数据"><a href="#8、向application域共享数据" class="headerlink" title="8、向application域共享数据"></a>8、向application域共享数据</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testApplication&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testApplication</span><span class="params">(HttpSession session)</span></span>&#123;</span><br><span class="line">	ServletContext application = session.getServletContext();</span><br><span class="line">    application.setAttribute(<span class="string">&quot;testApplicationScope&quot;</span>, <span class="string">&quot;hello,application&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="六、SpringMVC的视图"><a href="#六、SpringMVC的视图" class="headerlink" title="六、SpringMVC的视图"></a>六、SpringMVC的视图</h1><p>SpringMVC中的视图是View接口，视图的作用渲染数据，将模型Model中的数据展示给用户</p>
<p>SpringMVC视图的种类很多，默认有转发视图和重定向视图</p>
<p>当工程引入jstl的依赖，转发视图会自动转换为JstlView</p>
<p>若使用的视图技术为Thymeleaf，在SpringMVC的配置文件中配置了Thymeleaf的视图解析器，由此视图解析器解析之后所得到的是ThymeleafView</p>
<h3 id="1、ThymeleafView"><a href="#1、ThymeleafView" class="headerlink" title="1、ThymeleafView"></a>1、ThymeleafView</h3><p>当控制器方法中所设置的视图名称没有任何前缀时，此时的视图名称会被SpringMVC配置文件中所配置的视图解析器解析，视图名称拼接视图前缀和视图后缀所得到的最终路径，会通过转发的方式实现跳转</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testHello&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testHello</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/03/03/SpringMVC%E7%AC%94%E8%AE%B0/img002.png"></p>
<h3 id="2、转发视图"><a href="#2、转发视图" class="headerlink" title="2、转发视图"></a>2、转发视图</h3><p>SpringMVC中默认的转发视图是InternalResourceView</p>
<p>SpringMVC中创建转发视图的情况：</p>
<p>当控制器方法中所设置的视图名称以”forward:”为前缀时，创建InternalResourceView视图，此时的视图名称不会被SpringMVC配置文件中所配置的视图解析器解析，而是会将前缀”forward:”去掉，剩余部分作为最终路径通过转发的方式实现跳转</p>
<p>例如”forward:/“，”forward:/employee”</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testForward&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testForward</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;forward:/testHello&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/03/03/SpringMVC%E7%AC%94%E8%AE%B0/img003.png" alt="image-20210706201316593"></p>
<h3 id="3、重定向视图"><a href="#3、重定向视图" class="headerlink" title="3、重定向视图"></a>3、重定向视图</h3><p>SpringMVC中默认的重定向视图是RedirectView</p>
<p>当控制器方法中所设置的视图名称以”redirect:”为前缀时，创建RedirectView视图，此时的视图名称不会被SpringMVC配置文件中所配置的视图解析器解析，而是会将前缀”redirect:”去掉，剩余部分作为最终路径通过重定向的方式实现跳转</p>
<p>例如”redirect:/“，”redirect:/employee”</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testRedirect&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testRedirect</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;redirect:/testHello&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/03/03/SpringMVC%E7%AC%94%E8%AE%B0/img004.png" alt="image-20210706201602267"></p>
<blockquote>
<p>注：</p>
<p>重定向视图在解析时，会先将redirect:前缀去掉，然后会判断剩余部分是否以/开头，若是则会自动拼接上下文路径</p>
</blockquote>
<h3 id="4、视图控制器view-controller"><a href="#4、视图控制器view-controller" class="headerlink" title="4、视图控制器view-controller"></a>4、视图控制器view-controller</h3><p>当控制器方法中，仅仅用来实现页面跳转，即只需要设置视图名称时，可以将处理器方法使用view-controller标签进行表示</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">	path：设置处理的请求地址</span></span><br><span class="line"><span class="comment">	view-name：设置请求地址所对应的视图名称</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:view-controller</span> <span class="attr">path</span>=<span class="string">&quot;/testView&quot;</span> <span class="attr">view-name</span>=<span class="string">&quot;success&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">mvc:view-controller</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注：</p>
<p>当SpringMVC中设置任何一个view-controller时，其他控制器中的请求映射将全部失效，此时需要在SpringMVC的核心配置文件中设置开启mvc注解驱动的标签：</p>
<p>&lt;mvc:annotation-driven /&gt;</p>
</blockquote>
<h1 id="七、RESTful"><a href="#七、RESTful" class="headerlink" title="七、RESTful"></a>七、RESTful</h1><h3 id="1、RESTful简介"><a href="#1、RESTful简介" class="headerlink" title="1、RESTful简介"></a>1、RESTful简介</h3><p>REST：<strong>Re</strong>presentational <strong>S</strong>tate <strong>T</strong>ransfer，表现层资源状态转移。</p>
<h5 id="a-gt-资源"><a href="#a-gt-资源" class="headerlink" title="a&gt;资源"></a>a&gt;资源</h5><p>资源是一种看待服务器的方式，即，将服务器看作是由很多离散的资源组成。每个资源是服务器上一个可命名的抽象概念。因为资源是一个抽象的概念，所以它不仅仅能代表服务器文件系统中的一个文件、数据库中的一张表等等具体的东西，可以将资源设计的要多抽象有多抽象，只要想象力允许而且客户端应用开发者能够理解。与面向对象设计类似，资源是以名词为核心来组织的，首先关注的是名词。一个资源可以由一个或多个URI来标识。URI既是资源的名称，也是资源在Web上的地址。对某个资源感兴趣的客户端应用，可以通过资源的URI与其进行交互。</p>
<h5 id="b-gt-资源的表述"><a href="#b-gt-资源的表述" class="headerlink" title="b&gt;资源的表述"></a>b&gt;资源的表述</h5><p>资源的表述是一段对于资源在某个特定时刻的状态的描述。可以在客户端-服务器端之间转移（交换）。资源的表述可以有多种格式，例如HTML/XML/JSON/纯文本/图片/视频/音频等等。资源的表述格式可以通过协商机制来确定。请求-响应方向的表述通常使用不同的格式。</p>
<h5 id="c-gt-状态转移"><a href="#c-gt-状态转移" class="headerlink" title="c&gt;状态转移"></a>c&gt;状态转移</h5><p>状态转移说的是：在客户端和服务器端之间转移（transfer）代表资源状态的表述。通过转移和操作资源的表述，来间接实现操作资源的目的。</p>
<h3 id="2、RESTful的实现"><a href="#2、RESTful的实现" class="headerlink" title="2、RESTful的实现"></a>2、RESTful的实现</h3><p>具体说，就是 HTTP 协议里面，四个表示操作方式的动词：GET、POST、PUT、DELETE。</p>
<p>它们分别对应四种基本操作：GET 用来获取资源，POST 用来新建资源，PUT 用来更新资源，DELETE 用来删除资源。</p>
<p>REST 风格提倡 URL 地址使用统一的风格设计，从前到后各个单词使用斜杠分开，不使用问号键值对方式携带请求参数，而是将要发送给服务器的数据作为 URL 地址的一部分，以保证整体风格的一致性。</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>传统方式</th>
<th>REST风格</th>
</tr>
</thead>
<tbody><tr>
<td>查询操作</td>
<td>getUserById?id=1</td>
<td>user/1–&gt;get请求方式</td>
</tr>
<tr>
<td>保存操作</td>
<td>saveUser</td>
<td>user–&gt;post请求方式</td>
</tr>
<tr>
<td>删除操作</td>
<td>deleteUser?id=1</td>
<td>user/1–&gt;delete请求方式</td>
</tr>
<tr>
<td>更新操作</td>
<td>updateUser</td>
<td>user–&gt;put请求方式</td>
</tr>
</tbody></table>
<h3 id="3、HiddenHttpMethodFilter"><a href="#3、HiddenHttpMethodFilter" class="headerlink" title="3、HiddenHttpMethodFilter"></a>3、HiddenHttpMethodFilter</h3><p>由于浏览器只支持发送get和post方式的请求，那么该如何发送put和delete请求呢？</p>
<p>SpringMVC 提供了 <strong>HiddenHttpMethodFilter</strong> 帮助我们<strong>将 POST 请求转换为 DELETE 或 PUT 请求</strong></p>
<p><strong>HiddenHttpMethodFilter</strong> 处理put和delete请求的条件：</p>
<p>a&gt;当前请求的请求方式必须为post</p>
<p>b&gt;当前请求必须传输请求参数_method</p>
<p>满足以上条件，<strong>HiddenHttpMethodFilter</strong> 过滤器就会将当前请求的请求方式转换为请求参数_method的值，因此请求参数_method的值才是最终的请求方式</p>
<p>在web.xml中注册<strong>HiddenHttpMethodFilter</strong> </p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>HiddenHttpMethodFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.HiddenHttpMethodFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>HiddenHttpMethodFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注：</p>
<p>目前为止，SpringMVC中提供了两个过滤器：CharacterEncodingFilter和HiddenHttpMethodFilter</p>
<p>在web.xml中注册时，必须先注册CharacterEncodingFilter，再注册HiddenHttpMethodFilter</p>
<p>原因：</p>
<ul>
<li><p>在 CharacterEncodingFilter 中通过 request.setCharacterEncoding(encoding) 方法设置字符集的</p>
</li>
<li><p>request.setCharacterEncoding(encoding) 方法要求前面不能有任何获取请求参数的操作</p>
</li>
<li><p>而 HiddenHttpMethodFilter 恰恰有一个获取请求方式的操作：</p>
</li>
<li><p>```<br>String paramValue = request.getParameter(this.methodParam);</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 八、RESTful案例</span><br><span class="line"></span><br><span class="line">### 1、准备工作</span><br><span class="line"></span><br><span class="line">和传统 CRUD 一样，实现对员工信息的增删改查。</span><br><span class="line"></span><br><span class="line">- 搭建环境</span><br><span class="line"></span><br><span class="line">- 准备实体类</span><br><span class="line"></span><br><span class="line"> ```java</span><br><span class="line"> package com.atguigu.mvc.bean;</span><br><span class="line"> </span><br><span class="line"> public class Employee &#123;</span><br><span class="line"> </span><br><span class="line">    private Integer id;</span><br><span class="line">    private String lastName;</span><br><span class="line"> </span><br><span class="line">    private String email;</span><br><span class="line">    //1 male, 0 female</span><br><span class="line">    private Integer gender;</span><br><span class="line">    </span><br><span class="line">    public Integer getId() &#123;</span><br><span class="line">       return id;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public void setId(Integer id) &#123;</span><br><span class="line">       this.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public String getLastName() &#123;</span><br><span class="line">       return lastName;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public void setLastName(String lastName) &#123;</span><br><span class="line">       this.lastName = lastName;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public String getEmail() &#123;</span><br><span class="line">       return email;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public void setEmail(String email) &#123;</span><br><span class="line">       this.email = email;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public Integer getGender() &#123;</span><br><span class="line">       return gender;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public void setGender(Integer gender) &#123;</span><br><span class="line">       this.gender = gender;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public Employee(Integer id, String lastName, String email, Integer gender) &#123;</span><br><span class="line">       super();</span><br><span class="line">       this.id = id;</span><br><span class="line">       this.lastName = lastName;</span><br><span class="line">       this.email = email;</span><br><span class="line">       this.gender = gender;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public Employee() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</blockquote>
<ul>
<li><p>准备dao模拟数据</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.mvc.dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.atguigu.mvc.bean.Employee;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Repository;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmployeeDao</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;Integer, Employee&gt; employees = <span class="keyword">null</span>;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">static</span>&#123;</span><br><span class="line">      employees = <span class="keyword">new</span> HashMap&lt;Integer, Employee&gt;();</span><br><span class="line"></span><br><span class="line">      employees.put(<span class="number">1001</span>, <span class="keyword">new</span> Employee(<span class="number">1001</span>, <span class="string">&quot;E-AA&quot;</span>, <span class="string">&quot;aa@163.com&quot;</span>, <span class="number">1</span>));</span><br><span class="line">      employees.put(<span class="number">1002</span>, <span class="keyword">new</span> Employee(<span class="number">1002</span>, <span class="string">&quot;E-BB&quot;</span>, <span class="string">&quot;bb@163.com&quot;</span>, <span class="number">1</span>));</span><br><span class="line">      employees.put(<span class="number">1003</span>, <span class="keyword">new</span> Employee(<span class="number">1003</span>, <span class="string">&quot;E-CC&quot;</span>, <span class="string">&quot;cc@163.com&quot;</span>, <span class="number">0</span>));</span><br><span class="line">      employees.put(<span class="number">1004</span>, <span class="keyword">new</span> Employee(<span class="number">1004</span>, <span class="string">&quot;E-DD&quot;</span>, <span class="string">&quot;dd@163.com&quot;</span>, <span class="number">0</span>));</span><br><span class="line">      employees.put(<span class="number">1005</span>, <span class="keyword">new</span> Employee(<span class="number">1005</span>, <span class="string">&quot;E-EE&quot;</span>, <span class="string">&quot;ee@163.com&quot;</span>, <span class="number">1</span>));</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> Integer initId = <span class="number">1006</span>;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">(Employee employee)</span></span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(employee.getId() == <span class="keyword">null</span>)&#123;</span><br><span class="line">         employee.setId(initId++);</span><br><span class="line">      &#125;</span><br><span class="line">      employees.put(employee.getId(), employee);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">public</span> Collection&lt;Employee&gt; <span class="title">getAll</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> employees.values();</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">public</span> Employee <span class="title">get</span><span class="params">(Integer id)</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> employees.get(id);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(Integer id)</span></span>&#123;</span><br><span class="line">      employees.remove(id);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2、功能清单"><a href="#2、功能清单" class="headerlink" title="2、功能清单"></a>2、功能清单</h3><table>
<thead>
<tr>
<th>功能</th>
<th>URL 地址</th>
<th>请求方式</th>
</tr>
</thead>
<tbody><tr>
<td>访问首页√</td>
<td>/</td>
<td>GET</td>
</tr>
<tr>
<td>查询全部数据√</td>
<td>/employee</td>
<td>GET</td>
</tr>
<tr>
<td>删除√</td>
<td>/employee/2</td>
<td>DELETE</td>
</tr>
<tr>
<td>跳转到添加数据页面√</td>
<td>/toAdd</td>
<td>GET</td>
</tr>
<tr>
<td>执行保存√</td>
<td>/employee</td>
<td>POST</td>
</tr>
<tr>
<td>跳转到更新数据页面√</td>
<td>/employee/2</td>
<td>GET</td>
</tr>
<tr>
<td>执行更新√</td>
<td>/employee</td>
<td>PUT</td>
</tr>
</tbody></table>
<h3 id="3、具体功能：访问首页"><a href="#3、具体功能：访问首页" class="headerlink" title="3、具体功能：访问首页"></a>3、具体功能：访问首页</h3><h5 id="a-gt-配置view-controller"><a href="#a-gt-配置view-controller" class="headerlink" title="a&gt;配置view-controller"></a>a&gt;配置view-controller</h5><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:view-controller</span> <span class="attr">path</span>=<span class="string">&quot;/&quot;</span> <span class="attr">view-name</span>=<span class="string">&quot;index&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="b-gt-创建页面"><a href="#b-gt-创建页面" class="headerlink" title="b&gt;创建页面"></a>b&gt;创建页面</h5><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span> <span class="attr">xmlns:th</span>=<span class="string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/employee&#125;&quot;</span>&gt;</span>访问员工信息<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="4、具体功能：查询所有员工数据"><a href="#4、具体功能：查询所有员工数据" class="headerlink" title="4、具体功能：查询所有员工数据"></a>4、具体功能：查询所有员工数据</h3><h5 id="a-gt-控制器方法"><a href="#a-gt-控制器方法" class="headerlink" title="a&gt;控制器方法"></a>a&gt;控制器方法</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value = &quot;/employee&quot;, method = RequestMethod.GET)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getEmployeeList</span><span class="params">(Model model)</span></span>&#123;</span><br><span class="line">    Collection&lt;Employee&gt; employeeList = employeeDao.getAll();</span><br><span class="line">    model.addAttribute(<span class="string">&quot;employeeList&quot;</span>, employeeList);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;employee_list&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="b-gt-创建employee-list-html"><a href="#b-gt-创建employee-list-html" class="headerlink" title="b&gt;创建employee_list.html"></a>b&gt;创建employee_list.html</h5><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span> <span class="attr">xmlns:th</span>=<span class="string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Employee Info<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">th:src</span>=<span class="string">&quot;@&#123;/static/js/vue.js&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">table</span> <span class="attr">border</span>=<span class="string">&quot;1&quot;</span> <span class="attr">cellpadding</span>=<span class="string">&quot;0&quot;</span> <span class="attr">cellspacing</span>=<span class="string">&quot;0&quot;</span> <span class="attr">style</span>=<span class="string">&quot;text-align: center;&quot;</span> <span class="attr">id</span>=<span class="string">&quot;dataTable&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span> <span class="attr">colspan</span>=<span class="string">&quot;5&quot;</span>&gt;</span>Employee Info<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span>&gt;</span>id<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span>&gt;</span>lastName<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span>&gt;</span>email<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span>&gt;</span>gender<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span>&gt;</span>options(<span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/toAdd&#125;&quot;</span>&gt;</span>add<span class="tag">&lt;/<span class="name">a</span>&gt;</span>)<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span> <span class="attr">th:each</span>=<span class="string">&quot;employee : $&#123;employeeList&#125;&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;employee.id&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;employee.lastName&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;employee.email&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;employee.gender&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">&quot;deleteA&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;deleteEmployee&quot;</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;&#x27;/employee/&#x27;+$&#123;employee.id&#125;&#125;&quot;</span>&gt;</span>delete<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;&#x27;/employee/&#x27;+$&#123;employee.id&#125;&#125;&quot;</span>&gt;</span>update<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="5、具体功能：删除"><a href="#5、具体功能：删除" class="headerlink" title="5、具体功能：删除"></a>5、具体功能：删除</h3><h5 id="a-gt-创建处理delete请求方式的表单"><a href="#a-gt-创建处理delete请求方式的表单" class="headerlink" title="a&gt;创建处理delete请求方式的表单"></a>a&gt;创建处理delete请求方式的表单</h5><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 作用：通过超链接控制表单的提交，将post请求转换为delete请求 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">&quot;delete_form&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- HiddenHttpMethodFilter要求：必须传输_method请求参数，并且值为最终的请求方式 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;_method&quot;</span> <span class="attr">value</span>=<span class="string">&quot;delete&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="b-gt-删除超链接绑定点击事件"><a href="#b-gt-删除超链接绑定点击事件" class="headerlink" title="b&gt;删除超链接绑定点击事件"></a>b&gt;删除超链接绑定点击事件</h5><p>引入vue.js</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">th:src</span>=<span class="string">&quot;@&#123;/static/js/vue.js&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>删除超链接</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">&quot;deleteA&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;deleteEmployee&quot;</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;&#x27;/employee/&#x27;+$&#123;employee.id&#125;&#125;&quot;</span>&gt;</span>delete<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>通过vue处理点击事件</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> vue = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">        <span class="attr">el</span>:<span class="string">&quot;#dataTable&quot;</span>,</span></span><br><span class="line"><span class="javascript">        <span class="attr">methods</span>:&#123;</span></span><br><span class="line"><span class="javascript">            <span class="comment">//event表示当前事件</span></span></span><br><span class="line"><span class="javascript">            <span class="attr">deleteEmployee</span>:<span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="comment">//通过id获取表单标签</span></span></span><br><span class="line"><span class="javascript">                <span class="keyword">var</span> delete_form = <span class="built_in">document</span>.getElementById(<span class="string">&quot;delete_form&quot;</span>);</span></span><br><span class="line"><span class="javascript">                <span class="comment">//将触发事件的超链接的href属性为表单的action属性赋值</span></span></span><br><span class="line"><span class="javascript">                delete_form.action = event.target.href;</span></span><br><span class="line"><span class="javascript">                <span class="comment">//提交表单</span></span></span><br><span class="line"><span class="javascript">                delete_form.submit();</span></span><br><span class="line"><span class="javascript">                <span class="comment">//阻止超链接的默认跳转行为</span></span></span><br><span class="line"><span class="javascript">                event.preventDefault();</span></span><br><span class="line"><span class="javascript">            &#125;</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">    &#125;);</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="c-gt-控制器方法"><a href="#c-gt-控制器方法" class="headerlink" title="c&gt;控制器方法"></a>c&gt;控制器方法</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value = &quot;/employee/&#123;id&#125;&quot;, method = RequestMethod.DELETE)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">deleteEmployee</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span></span>&#123;</span><br><span class="line">    employeeDao.delete(id);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;redirect:/employee&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6、具体功能：跳转到添加数据页面"><a href="#6、具体功能：跳转到添加数据页面" class="headerlink" title="6、具体功能：跳转到添加数据页面"></a>6、具体功能：跳转到添加数据页面</h3><h5 id="a-gt-配置view-controller-1"><a href="#a-gt-配置view-controller-1" class="headerlink" title="a&gt;配置view-controller"></a>a&gt;配置view-controller</h5><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:view-controller</span> <span class="attr">path</span>=<span class="string">&quot;/toAdd&quot;</span> <span class="attr">view-name</span>=<span class="string">&quot;employee_add&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">mvc:view-controller</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="b-gt-创建employee-add-html"><a href="#b-gt-创建employee-add-html" class="headerlink" title="b&gt;创建employee_add.html"></a>b&gt;创建employee_add.html</h5><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span> <span class="attr">xmlns:th</span>=<span class="string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Add Employee<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">th:action</span>=<span class="string">&quot;@&#123;/employee&#125;&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">    lastName:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;lastName&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    email:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;email&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    gender:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;gender&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span>&gt;</span>male</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;gender&quot;</span> <span class="attr">value</span>=<span class="string">&quot;0&quot;</span>&gt;</span>female<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;add&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="7、具体功能：执行保存"><a href="#7、具体功能：执行保存" class="headerlink" title="7、具体功能：执行保存"></a>7、具体功能：执行保存</h3><h5 id="a-gt-控制器方法-1"><a href="#a-gt-控制器方法-1" class="headerlink" title="a&gt;控制器方法"></a>a&gt;控制器方法</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value = &quot;/employee&quot;, method = RequestMethod.POST)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">addEmployee</span><span class="params">(Employee employee)</span></span>&#123;</span><br><span class="line">    employeeDao.save(employee);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;redirect:/employee&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="8、具体功能：跳转到更新数据页面"><a href="#8、具体功能：跳转到更新数据页面" class="headerlink" title="8、具体功能：跳转到更新数据页面"></a>8、具体功能：跳转到更新数据页面</h3><h5 id="a-gt-修改超链接"><a href="#a-gt-修改超链接" class="headerlink" title="a&gt;修改超链接"></a>a&gt;修改超链接</h5><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;&#x27;/employee/&#x27;+$&#123;employee.id&#125;&#125;&quot;</span>&gt;</span>update<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="b-gt-控制器方法"><a href="#b-gt-控制器方法" class="headerlink" title="b&gt;控制器方法"></a>b&gt;控制器方法</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value = &quot;/employee/&#123;id&#125;&quot;, method = RequestMethod.GET)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getEmployeeById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id, Model model)</span></span>&#123;</span><br><span class="line">    Employee employee = employeeDao.get(id);</span><br><span class="line">    model.addAttribute(<span class="string">&quot;employee&quot;</span>, employee);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;employee_update&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="c-gt-创建employee-update-html"><a href="#c-gt-创建employee-update-html" class="headerlink" title="c&gt;创建employee_update.html"></a>c&gt;创建employee_update.html</h5><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span> <span class="attr">xmlns:th</span>=<span class="string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Update Employee<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">th:action</span>=<span class="string">&quot;@&#123;/employee&#125;&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;_method&quot;</span> <span class="attr">value</span>=<span class="string">&quot;put&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;id&quot;</span> <span class="attr">th:value</span>=<span class="string">&quot;$&#123;employee.id&#125;&quot;</span>&gt;</span></span><br><span class="line">    lastName:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;lastName&quot;</span> <span class="attr">th:value</span>=<span class="string">&quot;$&#123;employee.lastName&#125;&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    email:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;email&quot;</span> <span class="attr">th:value</span>=<span class="string">&quot;$&#123;employee.email&#125;&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        th:field=&quot;$&#123;employee.gender&#125;&quot;可用于单选框或复选框的回显</span></span><br><span class="line"><span class="comment">        若单选框的value和employee.gender的值一致，则添加checked=&quot;checked&quot;属性</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    gender:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;gender&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span> <span class="attr">th:field</span>=<span class="string">&quot;$&#123;employee.gender&#125;&quot;</span>&gt;</span>male</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;gender&quot;</span> <span class="attr">value</span>=<span class="string">&quot;0&quot;</span> <span class="attr">th:field</span>=<span class="string">&quot;$&#123;employee.gender&#125;&quot;</span>&gt;</span>female<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;update&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="9、具体功能：执行更新"><a href="#9、具体功能：执行更新" class="headerlink" title="9、具体功能：执行更新"></a>9、具体功能：执行更新</h3><h5 id="a-gt-控制器方法-2"><a href="#a-gt-控制器方法-2" class="headerlink" title="a&gt;控制器方法"></a>a&gt;控制器方法</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value = &quot;/employee&quot;, method = RequestMethod.PUT)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">updateEmployee</span><span class="params">(Employee employee)</span></span>&#123;</span><br><span class="line">    employeeDao.save(employee);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;redirect:/employee&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="八、HttpMessageConverter"><a href="#八、HttpMessageConverter" class="headerlink" title="八、HttpMessageConverter"></a>八、HttpMessageConverter</h1><p>HttpMessageConverter，报文信息转换器，将请求报文转换为Java对象，或将Java对象转换为响应报文</p>
<p>HttpMessageConverter提供了两个注解和两个类型：@RequestBody，@ResponseBody，RequestEntity，</p>
<p>ResponseEntity</p>
<h3 id="1、-RequestBody"><a href="#1、-RequestBody" class="headerlink" title="1、@RequestBody"></a>1、@RequestBody</h3><p>@RequestBody可以获取请求体，需要在控制器方法设置一个形参，使用@RequestBody进行标识，当前请求的请求体就会为当前注解所标识的形参赋值</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">th:action</span>=<span class="string">&quot;@&#123;/testRequestBody&#125;&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">    用户名：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    密码：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testRequestBody&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testRequestBody</span><span class="params">(<span class="meta">@RequestBody</span> String requestBody)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;requestBody:&quot;</span>+requestBody);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<p>requestBody:username=admin&amp;password=123456</p>
<h3 id="2、RequestEntity"><a href="#2、RequestEntity" class="headerlink" title="2、RequestEntity"></a>2、RequestEntity</h3><p>RequestEntity封装请求报文的一种类型，需要在控制器方法的形参中设置该类型的形参，当前请求的请求报文就会赋值给该形参，可以通过getHeaders()获取请求头信息，通过getBody()获取请求体信息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testRequestEntity&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testRequestEntity</span><span class="params">(RequestEntity&lt;String&gt; requestEntity)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;requestHeader:&quot;</span>+requestEntity.getHeaders());</span><br><span class="line">    System.out.println(<span class="string">&quot;requestBody:&quot;</span>+requestEntity.getBody());</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：<br>requestHeader:[host:”localhost:8080”, connection:”keep-alive”, content-length:”27”, cache-control:”max-age=0”, sec-ch-ua:”” Not A;Brand”;v=”99”, “Chromium”;v=”90”, “Google Chrome”;v=”90””, sec-ch-ua-mobile:”?0”, upgrade-insecure-requests:”1”, origin:”<a href="http://localhost:8080&quot;">http://localhost:8080&quot;</a>, user-agent:”Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/90.0.4430.93 Safari/537.36”]<br>requestBody:username=admin&amp;password=123</p>
<h3 id="3、-ResponseBody"><a href="#3、-ResponseBody" class="headerlink" title="3、@ResponseBody"></a>3、@ResponseBody</h3><p>@ResponseBody用于标识一个控制器方法，可以将该方法的返回值直接作为响应报文的响应体响应到浏览器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testResponseBody&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testResponseBody</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：浏览器页面显示success</p>
<h3 id="4、SpringMVC处理json"><a href="#4、SpringMVC处理json" class="headerlink" title="4、SpringMVC处理json"></a>4、SpringMVC处理json</h3><p>@ResponseBody处理json的步骤：</p>
<p>a&gt;导入jackson的依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.12.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>b&gt;在SpringMVC的核心配置文件中开启mvc的注解驱动，此时在HandlerAdaptor中会自动装配一个消息转换器：MappingJackson2HttpMessageConverter，可以将响应到浏览器的Java对象转换为Json格式的字符串</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;mvc:annotation-driven /&gt;</span><br></pre></td></tr></table></figure>

<p>c&gt;在处理器方法上使用@ResponseBody注解进行标识</p>
<p>d&gt;将Java对象直接作为控制器方法的返回值返回，就会自动转换为Json格式的字符串</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testResponseUser&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">testResponseUser</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> User(<span class="number">1001</span>,<span class="string">&quot;admin&quot;</span>,<span class="string">&quot;123456&quot;</span>,<span class="number">23</span>,<span class="string">&quot;男&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>浏览器的页面中展示的结果：</p>
<p>{“id”:1001,”username”:”admin”,”password”:”123456”,”age”:23,”sex”:”男”}</p>
<h3 id="5、SpringMVC处理ajax"><a href="#5、SpringMVC处理ajax" class="headerlink" title="5、SpringMVC处理ajax"></a>5、SpringMVC处理ajax</h3><p>a&gt;请求超链接：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/testAjax&#125;&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;testAjax&quot;</span>&gt;</span>testAjax<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>b&gt;通过vue和axios处理点击事件：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">th:src</span>=<span class="string">&quot;@&#123;/static/js/vue.js&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">th:src</span>=<span class="string">&quot;@&#123;/static/js/axios.min.js&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> vue = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">        <span class="attr">el</span>:<span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line"><span class="javascript">        <span class="attr">methods</span>:&#123;</span></span><br><span class="line"><span class="javascript">            <span class="attr">testAjax</span>:<span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                axios(&#123;</span></span><br><span class="line"><span class="javascript">                    <span class="attr">method</span>:<span class="string">&quot;post&quot;</span>,</span></span><br><span class="line"><span class="javascript">                    <span class="attr">url</span>:event.target.href,</span></span><br><span class="line"><span class="javascript">                    <span class="attr">params</span>:&#123;</span></span><br><span class="line"><span class="javascript">                        <span class="attr">username</span>:<span class="string">&quot;admin&quot;</span>,</span></span><br><span class="line"><span class="javascript">                        <span class="attr">password</span>:<span class="string">&quot;123456&quot;</span></span></span><br><span class="line"><span class="javascript">                    &#125;</span></span><br><span class="line"><span class="javascript">                &#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                    alert(response.data);</span></span><br><span class="line"><span class="javascript">                &#125;);</span></span><br><span class="line"><span class="javascript">                event.preventDefault();</span></span><br><span class="line"><span class="javascript">            &#125;</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">    &#125;);</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>c&gt;控制器方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testAjax&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testAjax</span><span class="params">(String username, String password)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;username:&quot;</span>+username+<span class="string">&quot;,password:&quot;</span>+password);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;hello,ajax&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6、-RestController注解"><a href="#6、-RestController注解" class="headerlink" title="6、@RestController注解"></a>6、@RestController注解</h3><p>@RestController注解是springMVC提供的一个复合注解，标识在控制器的类上，就相当于为类添加了@Controller注解，并且为其中的每个方法添加了@ResponseBody注解</p>
<h3 id="7、ResponseEntity"><a href="#7、ResponseEntity" class="headerlink" title="7、ResponseEntity"></a>7、ResponseEntity</h3><p>ResponseEntity用于控制器方法的返回值类型，该控制器方法的返回值就是响应到浏览器的响应报文</p>
<h1 id="九、文件上传和下载"><a href="#九、文件上传和下载" class="headerlink" title="九、文件上传和下载"></a>九、文件上传和下载</h1><h3 id="1、文件下载"><a href="#1、文件下载" class="headerlink" title="1、文件下载"></a>1、文件下载</h3><p>使用ResponseEntity实现下载文件的功能</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testDown&quot;)</span></span><br><span class="line"><span class="keyword">public</span> ResponseEntity&lt;<span class="keyword">byte</span>[]&gt; testResponseEntity(HttpSession session) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">//获取ServletContext对象</span></span><br><span class="line">    ServletContext servletContext = session.getServletContext();</span><br><span class="line">    <span class="comment">//获取服务器中文件的真实路径</span></span><br><span class="line">    String realPath = servletContext.getRealPath(<span class="string">&quot;/static/img/1.jpg&quot;</span>);</span><br><span class="line">    <span class="comment">//创建输入流</span></span><br><span class="line">    InputStream is = <span class="keyword">new</span> FileInputStream(realPath);</span><br><span class="line">    <span class="comment">//创建字节数组</span></span><br><span class="line">    <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[is.available()];</span><br><span class="line">    <span class="comment">//将流读到字节数组中</span></span><br><span class="line">    is.read(bytes);</span><br><span class="line">    <span class="comment">//创建HttpHeaders对象设置响应头信息</span></span><br><span class="line">    MultiValueMap&lt;String, String&gt; headers = <span class="keyword">new</span> HttpHeaders();</span><br><span class="line">    <span class="comment">//设置要下载方式以及下载文件的名字</span></span><br><span class="line">    headers.add(<span class="string">&quot;Content-Disposition&quot;</span>, <span class="string">&quot;attachment;filename=1.jpg&quot;</span>);</span><br><span class="line">    <span class="comment">//设置响应状态码</span></span><br><span class="line">    HttpStatus statusCode = HttpStatus.OK;</span><br><span class="line">    <span class="comment">//创建ResponseEntity对象</span></span><br><span class="line">    ResponseEntity&lt;<span class="keyword">byte</span>[]&gt; responseEntity = <span class="keyword">new</span> ResponseEntity&lt;&gt;(bytes, headers, statusCode);</span><br><span class="line">    <span class="comment">//关闭输入流</span></span><br><span class="line">    is.close();</span><br><span class="line">    <span class="keyword">return</span> responseEntity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2、文件上传"><a href="#2、文件上传" class="headerlink" title="2、文件上传"></a>2、文件上传</h3><p>文件上传要求form表单的请求方式必须为post，并且添加属性enctype=”multipart/form-data”</p>
<p>SpringMVC中将上传的文件封装到MultipartFile对象中，通过此对象可以获取文件相关信息</p>
<p>上传步骤：</p>
<p>a&gt;添加依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/commons-fileupload/commons-fileupload --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-fileupload<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-fileupload<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>b&gt;在SpringMVC的配置文件中添加配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--必须通过文件解析器的解析才能将文件转换为MultipartFile对象--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;multipartResolver&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>c&gt;控制器方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testUp&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testUp</span><span class="params">(MultipartFile photo, HttpSession session)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">//获取上传的文件的文件名</span></span><br><span class="line">    String fileName = photo.getOriginalFilename();</span><br><span class="line">    <span class="comment">//处理文件重名问题</span></span><br><span class="line">    String hzName = fileName.substring(fileName.lastIndexOf(<span class="string">&quot;.&quot;</span>));</span><br><span class="line">    fileName = UUID.randomUUID().toString() + hzName;</span><br><span class="line">    <span class="comment">//获取服务器中photo目录的路径</span></span><br><span class="line">    ServletContext servletContext = session.getServletContext();</span><br><span class="line">    String photoPath = servletContext.getRealPath(<span class="string">&quot;photo&quot;</span>);</span><br><span class="line">    File file = <span class="keyword">new</span> File(photoPath);</span><br><span class="line">    <span class="keyword">if</span>(!file.exists())&#123;</span><br><span class="line">        file.mkdir();</span><br><span class="line">    &#125;</span><br><span class="line">    String finalPath = photoPath + File.separator + fileName;</span><br><span class="line">    <span class="comment">//实现上传功能</span></span><br><span class="line">    photo.transferTo(<span class="keyword">new</span> File(finalPath));</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="十、拦截器"><a href="#十、拦截器" class="headerlink" title="十、拦截器"></a>十、拦截器</h1><h3 id="1、拦截器的配置"><a href="#1、拦截器的配置" class="headerlink" title="1、拦截器的配置"></a>1、拦截器的配置</h3><p>SpringMVC中的拦截器用于拦截控制器方法的执行</p>
<p>SpringMVC中的拦截器需要实现HandlerInterceptor</p>
<p>SpringMVC的拦截器必须在SpringMVC的配置文件中进行配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.atguigu.interceptor.FirstInterceptor&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;firstInterceptor&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">ref</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 以上两种配置方式都是对DispatcherServlet所处理的所有的请求进行拦截 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:mapping</span> <span class="attr">path</span>=<span class="string">&quot;/**&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:exclude-mapping</span> <span class="attr">path</span>=<span class="string">&quot;/testRequestEntity&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;firstInterceptor&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">ref</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">	以上配置方式可以通过ref或bean标签设置拦截器，通过mvc:mapping设置需要拦截的请求，通过mvc:exclude-mapping设置需要排除的请求，即不需要拦截的请求</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="2、拦截器的三个抽象方法"><a href="#2、拦截器的三个抽象方法" class="headerlink" title="2、拦截器的三个抽象方法"></a>2、拦截器的三个抽象方法</h3><p>SpringMVC中的拦截器有三个抽象方法：</p>
<p>preHandle：控制器方法执行之前执行preHandle()，其boolean类型的返回值表示是否拦截或放行，返回true为放行，即调用控制器方法；返回false表示拦截，即不调用控制器方法</p>
<p>postHandle：控制器方法执行之后执行postHandle()</p>
<p>afterComplation：处理完视图和模型数据，渲染视图完毕之后执行afterComplation()</p>
<h3 id="3、多个拦截器的执行顺序"><a href="#3、多个拦截器的执行顺序" class="headerlink" title="3、多个拦截器的执行顺序"></a>3、多个拦截器的执行顺序</h3><p>a&gt;若每个拦截器的preHandle()都返回true</p>
<p>此时多个拦截器的执行顺序和拦截器在SpringMVC的配置文件的配置顺序有关：</p>
<p>preHandle()会按照配置的顺序执行，而postHandle()和afterComplation()会按照配置的反序执行</p>
<p>b&gt;若某个拦截器的preHandle()返回了false</p>
<p>preHandle()返回false和它之前的拦截器的preHandle()都会执行，postHandle()都不执行，返回false的拦截器之前的拦截器的afterComplation()会执行</p>
<h1 id="十一、异常处理器"><a href="#十一、异常处理器" class="headerlink" title="十一、异常处理器"></a>十一、异常处理器</h1><h3 id="1、基于配置的异常处理"><a href="#1、基于配置的异常处理" class="headerlink" title="1、基于配置的异常处理"></a>1、基于配置的异常处理</h3><p>SpringMVC提供了一个处理控制器方法执行过程中所出现的异常的接口：HandlerExceptionResolver</p>
<p>HandlerExceptionResolver接口的实现类有：DefaultHandlerExceptionResolver和SimpleMappingExceptionResolver</p>
<p>SpringMVC提供了自定义的异常处理器SimpleMappingExceptionResolver，使用方式：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.handler.SimpleMappingExceptionResolver&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;exceptionMappings&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">props</span>&gt;</span></span><br><span class="line">        	<span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        		properties的键表示处理器方法执行过程中出现的异常</span></span><br><span class="line"><span class="comment">        		properties的值表示若出现指定异常时，设置一个新的视图名称，跳转到指定页面</span></span><br><span class="line"><span class="comment">        	--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;java.lang.ArithmeticException&quot;</span>&gt;</span>error<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    	exceptionAttribute属性设置一个属性名，将出现的异常信息在请求域中进行共享</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;exceptionAttribute&quot;</span> <span class="attr">value</span>=<span class="string">&quot;ex&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="2、基于注解的异常处理"><a href="#2、基于注解的异常处理" class="headerlink" title="2、基于注解的异常处理"></a>2、基于注解的异常处理</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//@ControllerAdvice将当前类标识为异常处理的组件</span></span><br><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExceptionController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//@ExceptionHandler用于设置所标识方法处理的异常</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(ArithmeticException.class)</span></span><br><span class="line">    <span class="comment">//ex表示当前请求处理中出现的异常对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">handleArithmeticException</span><span class="params">(Exception ex, Model model)</span></span>&#123;</span><br><span class="line">        model.addAttribute(<span class="string">&quot;ex&quot;</span>, ex);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;error&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="十二、注解配置SpringMVC"><a href="#十二、注解配置SpringMVC" class="headerlink" title="十二、注解配置SpringMVC"></a>十二、注解配置SpringMVC</h1><p>使用配置类和注解代替web.xml和SpringMVC配置文件的功能</p>
<h3 id="1、创建初始化类，代替web-xml"><a href="#1、创建初始化类，代替web-xml" class="headerlink" title="1、创建初始化类，代替web.xml"></a>1、创建初始化类，代替web.xml</h3><p>在Servlet3.0环境中，容器会在类路径中查找实现javax.servlet.ServletContainerInitializer接口的类，如果找到的话就用它来配置Servlet容器。<br>Spring提供了这个接口的实现，名为SpringServletContainerInitializer，这个类反过来又会查找实现WebApplicationInitializer的类并将配置的任务交给它们来完成。Spring3.2引入了一个便利的WebApplicationInitializer基础实现，名为AbstractAnnotationConfigDispatcherServletInitializer，当我们的类扩展了AbstractAnnotationConfigDispatcherServletInitializer并将其部署到Servlet3.0容器的时候，容器会自动发现它，并用它来配置Servlet上下文。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebInit</span> <span class="keyword">extends</span> <span class="title">AbstractAnnotationConfigDispatcherServletInitializer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 指定spring的配置类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt;[] getRootConfigClasses() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Class[]&#123;SpringConfig.class&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 指定SpringMVC的配置类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt;[] getServletConfigClasses() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Class[]&#123;WebConfig.class&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 指定DispatcherServlet的映射规则，即url-pattern</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> String[] getServletMappings() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String[]&#123;<span class="string">&quot;/&quot;</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加过滤器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Filter[] getServletFilters() &#123;</span><br><span class="line">        CharacterEncodingFilter encodingFilter = <span class="keyword">new</span> CharacterEncodingFilter();</span><br><span class="line">        encodingFilter.setEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        encodingFilter.setForceRequestEncoding(<span class="keyword">true</span>);</span><br><span class="line">        HiddenHttpMethodFilter hiddenHttpMethodFilter = <span class="keyword">new</span> HiddenHttpMethodFilter();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Filter[]&#123;encodingFilter, hiddenHttpMethodFilter&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2、创建SpringConfig配置类，代替spring的配置文件"><a href="#2、创建SpringConfig配置类，代替spring的配置文件" class="headerlink" title="2、创建SpringConfig配置类，代替spring的配置文件"></a>2、创建SpringConfig配置类，代替spring的配置文件</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringConfig</span> </span>&#123;</span><br><span class="line">	<span class="comment">//ssm整合之后，spring的配置信息写在此类中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3、创建WebConfig配置类，代替SpringMVC的配置文件"><a href="#3、创建WebConfig配置类，代替SpringMVC的配置文件" class="headerlink" title="3、创建WebConfig配置类，代替SpringMVC的配置文件"></a>3、创建WebConfig配置类，代替SpringMVC的配置文件</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="comment">//扫描组件</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.atguigu.mvc.controller&quot;)</span></span><br><span class="line"><span class="comment">//开启MVC注解驱动</span></span><br><span class="line"><span class="meta">@EnableWebMvc</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebConfig</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用默认的servlet处理静态资源</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configureDefaultServletHandling</span><span class="params">(DefaultServletHandlerConfigurer configurer)</span> </span>&#123;</span><br><span class="line">        configurer.enable();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//配置文件上传解析器</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CommonsMultipartResolver <span class="title">multipartResolver</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CommonsMultipartResolver();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//配置拦截器</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> </span>&#123;</span><br><span class="line">        FirstInterceptor firstInterceptor = <span class="keyword">new</span> FirstInterceptor();</span><br><span class="line">        registry.addInterceptor(firstInterceptor).addPathPatterns(<span class="string">&quot;/**&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//配置视图控制</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*@Override</span></span><br><span class="line"><span class="comment">    public void addViewControllers(ViewControllerRegistry registry) &#123;</span></span><br><span class="line"><span class="comment">        registry.addViewController(&quot;/&quot;).setViewName(&quot;index&quot;);</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//配置异常映射</span></span><br><span class="line">    <span class="comment">/*@Override</span></span><br><span class="line"><span class="comment">    public void configureHandlerExceptionResolvers(List&lt;HandlerExceptionResolver&gt; resolvers) &#123;</span></span><br><span class="line"><span class="comment">        SimpleMappingExceptionResolver exceptionResolver = new SimpleMappingExceptionResolver();</span></span><br><span class="line"><span class="comment">        Properties prop = new Properties();</span></span><br><span class="line"><span class="comment">        prop.setProperty(&quot;java.lang.ArithmeticException&quot;, &quot;error&quot;);</span></span><br><span class="line"><span class="comment">        //设置异常映射</span></span><br><span class="line"><span class="comment">        exceptionResolver.setExceptionMappings(prop);</span></span><br><span class="line"><span class="comment">        //设置共享异常信息的键</span></span><br><span class="line"><span class="comment">        exceptionResolver.setExceptionAttribute(&quot;ex&quot;);</span></span><br><span class="line"><span class="comment">        resolvers.add(exceptionResolver);</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//配置生成模板解析器</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ITemplateResolver <span class="title">templateResolver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        WebApplicationContext webApplicationContext = ContextLoader.getCurrentWebApplicationContext();</span><br><span class="line">        <span class="comment">// ServletContextTemplateResolver需要一个ServletContext作为构造参数，可通过WebApplicationContext 的方法获得</span></span><br><span class="line">        ServletContextTemplateResolver templateResolver = <span class="keyword">new</span> ServletContextTemplateResolver(</span><br><span class="line">                webApplicationContext.getServletContext());</span><br><span class="line">        templateResolver.setPrefix(<span class="string">&quot;/WEB-INF/templates/&quot;</span>);</span><br><span class="line">        templateResolver.setSuffix(<span class="string">&quot;.html&quot;</span>);</span><br><span class="line">        templateResolver.setCharacterEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        templateResolver.setTemplateMode(TemplateMode.HTML);</span><br><span class="line">        <span class="keyword">return</span> templateResolver;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//生成模板引擎并为模板引擎注入模板解析器</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SpringTemplateEngine <span class="title">templateEngine</span><span class="params">(ITemplateResolver templateResolver)</span> </span>&#123;</span><br><span class="line">        SpringTemplateEngine templateEngine = <span class="keyword">new</span> SpringTemplateEngine();</span><br><span class="line">        templateEngine.setTemplateResolver(templateResolver);</span><br><span class="line">        <span class="keyword">return</span> templateEngine;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//生成视图解析器并未解析器注入模板引擎</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ViewResolver <span class="title">viewResolver</span><span class="params">(SpringTemplateEngine templateEngine)</span> </span>&#123;</span><br><span class="line">        ThymeleafViewResolver viewResolver = <span class="keyword">new</span> ThymeleafViewResolver();</span><br><span class="line">        viewResolver.setCharacterEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        viewResolver.setTemplateEngine(templateEngine);</span><br><span class="line">        <span class="keyword">return</span> viewResolver;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4、测试功能"><a href="#4、测试功能" class="headerlink" title="4、测试功能"></a>4、测试功能</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">index</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;index&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="十三、SpringMVC执行流程"><a href="#十三、SpringMVC执行流程" class="headerlink" title="十三、SpringMVC执行流程"></a>十三、SpringMVC执行流程</h1><h3 id="1、SpringMVC常用组件"><a href="#1、SpringMVC常用组件" class="headerlink" title="1、SpringMVC常用组件"></a>1、SpringMVC常用组件</h3><ul>
<li>DispatcherServlet：<strong>前端控制器</strong>，不需要工程师开发，由框架提供</li>
</ul>
<p>作用：统一处理请求和响应，整个流程控制的中心，由它调用其它组件处理用户的请求</p>
<ul>
<li>HandlerMapping：<strong>处理器映射器</strong>，不需要工程师开发，由框架提供</li>
</ul>
<p>作用：根据请求的url、method等信息查找Handler，即控制器方法</p>
<ul>
<li>Handler：<strong>处理器</strong>，需要工程师开发</li>
</ul>
<p>作用：在DispatcherServlet的控制下Handler对具体的用户请求进行处理</p>
<ul>
<li>HandlerAdapter：<strong>处理器适配器</strong>，不需要工程师开发，由框架提供</li>
</ul>
<p>作用：通过HandlerAdapter对处理器（控制器方法）进行执行</p>
<ul>
<li>ViewResolver：<strong>视图解析器</strong>，不需要工程师开发，由框架提供</li>
</ul>
<p>作用：进行视图解析，得到相应的视图，例如：ThymeleafView、InternalResourceView、RedirectView</p>
<ul>
<li>View：<strong>视图</strong></li>
</ul>
<p>作用：将模型数据通过页面展示给用户</p>
<h3 id="2、DispatcherServlet初始化过程"><a href="#2、DispatcherServlet初始化过程" class="headerlink" title="2、DispatcherServlet初始化过程"></a>2、DispatcherServlet初始化过程</h3><p>DispatcherServlet 本质上是一个 Servlet，所以天然的遵循 Servlet 的生命周期。所以宏观上是 Servlet 生命周期来进行调度。</p>
<p><img src="/2022/03/03/SpringMVC%E7%AC%94%E8%AE%B0/img005.png" alt="images"></p>
<h5 id="a-gt-初始化WebApplicationContext"><a href="#a-gt-初始化WebApplicationContext" class="headerlink" title="a&gt;初始化WebApplicationContext"></a>a&gt;初始化WebApplicationContext</h5><p>所在类：org.springframework.web.servlet.FrameworkServlet</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> WebApplicationContext <span class="title">initWebApplicationContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    WebApplicationContext rootContext =</span><br><span class="line">        WebApplicationContextUtils.getWebApplicationContext(getServletContext());</span><br><span class="line">    WebApplicationContext wac = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.webApplicationContext != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// A context instance was injected at construction time -&gt; use it</span></span><br><span class="line">        wac = <span class="keyword">this</span>.webApplicationContext;</span><br><span class="line">        <span class="keyword">if</span> (wac <span class="keyword">instanceof</span> ConfigurableWebApplicationContext) &#123;</span><br><span class="line">            ConfigurableWebApplicationContext cwac = (ConfigurableWebApplicationContext) wac;</span><br><span class="line">            <span class="keyword">if</span> (!cwac.isActive()) &#123;</span><br><span class="line">                <span class="comment">// The context has not yet been refreshed -&gt; provide services such as</span></span><br><span class="line">                <span class="comment">// setting the parent context, setting the application context id, etc</span></span><br><span class="line">                <span class="keyword">if</span> (cwac.getParent() == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// The context instance was injected without an explicit parent -&gt; set</span></span><br><span class="line">                    <span class="comment">// the root application context (if any; may be null) as the parent</span></span><br><span class="line">                    cwac.setParent(rootContext);</span><br><span class="line">                &#125;</span><br><span class="line">                configureAndRefreshWebApplicationContext(cwac);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (wac == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// No context instance was injected at construction time -&gt; see if one</span></span><br><span class="line">        <span class="comment">// has been registered in the servlet context. If one exists, it is assumed</span></span><br><span class="line">        <span class="comment">// that the parent context (if any) has already been set and that the</span></span><br><span class="line">        <span class="comment">// user has performed any initialization such as setting the context id</span></span><br><span class="line">        wac = findWebApplicationContext();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (wac == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// No context instance is defined for this servlet -&gt; create a local one</span></span><br><span class="line">        <span class="comment">// 创建WebApplicationContext</span></span><br><span class="line">        wac = createWebApplicationContext(rootContext);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.refreshEventReceived) &#123;</span><br><span class="line">        <span class="comment">// Either the context is not a ConfigurableApplicationContext with refresh</span></span><br><span class="line">        <span class="comment">// support or the context injected at construction time had already been</span></span><br><span class="line">        <span class="comment">// refreshed -&gt; trigger initial onRefresh manually here.</span></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>.onRefreshMonitor) &#123;</span><br><span class="line">            <span class="comment">// 刷新WebApplicationContext</span></span><br><span class="line">            onRefresh(wac);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.publishContext) &#123;</span><br><span class="line">        <span class="comment">// Publish the context as a servlet context attribute.</span></span><br><span class="line">        <span class="comment">// 将IOC容器在应用域共享</span></span><br><span class="line">        String attrName = getServletContextAttributeName();</span><br><span class="line">        getServletContext().setAttribute(attrName, wac);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> wac;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="b-gt-创建WebApplicationContext"><a href="#b-gt-创建WebApplicationContext" class="headerlink" title="b&gt;创建WebApplicationContext"></a>b&gt;创建WebApplicationContext</h5><p>所在类：org.springframework.web.servlet.FrameworkServlet</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> WebApplicationContext <span class="title">createWebApplicationContext</span><span class="params">(<span class="meta">@Nullable</span> ApplicationContext parent)</span> </span>&#123;</span><br><span class="line">    Class&lt;?&gt; contextClass = getContextClass();</span><br><span class="line">    <span class="keyword">if</span> (!ConfigurableWebApplicationContext.class.isAssignableFrom(contextClass)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ApplicationContextException(</span><br><span class="line">            <span class="string">&quot;Fatal initialization error in servlet with name &#x27;&quot;</span> + getServletName() +</span><br><span class="line">            <span class="string">&quot;&#x27;: custom WebApplicationContext class [&quot;</span> + contextClass.getName() +</span><br><span class="line">            <span class="string">&quot;] is not of type ConfigurableWebApplicationContext&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 通过反射创建 IOC 容器对象</span></span><br><span class="line">    ConfigurableWebApplicationContext wac =</span><br><span class="line">        (ConfigurableWebApplicationContext) BeanUtils.instantiateClass(contextClass);</span><br><span class="line"></span><br><span class="line">    wac.setEnvironment(getEnvironment());</span><br><span class="line">    <span class="comment">// 设置父容器</span></span><br><span class="line">    wac.setParent(parent);</span><br><span class="line">    String configLocation = getContextConfigLocation();</span><br><span class="line">    <span class="keyword">if</span> (configLocation != <span class="keyword">null</span>) &#123;</span><br><span class="line">        wac.setConfigLocation(configLocation);</span><br><span class="line">    &#125;</span><br><span class="line">    configureAndRefreshWebApplicationContext(wac);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> wac;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="c-gt-DispatcherServlet初始化策略"><a href="#c-gt-DispatcherServlet初始化策略" class="headerlink" title="c&gt;DispatcherServlet初始化策略"></a>c&gt;DispatcherServlet初始化策略</h5><p>FrameworkServlet创建WebApplicationContext后，刷新容器，调用onRefresh(wac)，此方法在DispatcherServlet中进行了重写，调用了initStrategies(context)方法，初始化策略，即初始化DispatcherServlet的各个组件</p>
<p>所在类：org.springframework.web.servlet.DispatcherServlet</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initStrategies</span><span class="params">(ApplicationContext context)</span> </span>&#123;</span><br><span class="line">   initMultipartResolver(context);</span><br><span class="line">   initLocaleResolver(context);</span><br><span class="line">   initThemeResolver(context);</span><br><span class="line">   initHandlerMappings(context);</span><br><span class="line">   initHandlerAdapters(context);</span><br><span class="line">   initHandlerExceptionResolvers(context);</span><br><span class="line">   initRequestToViewNameTranslator(context);</span><br><span class="line">   initViewResolvers(context);</span><br><span class="line">   initFlashMapManager(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3、DispatcherServlet调用组件处理请求"><a href="#3、DispatcherServlet调用组件处理请求" class="headerlink" title="3、DispatcherServlet调用组件处理请求"></a>3、DispatcherServlet调用组件处理请求</h3><h5 id="a-gt-processRequest"><a href="#a-gt-processRequest" class="headerlink" title="a&gt;processRequest()"></a>a&gt;processRequest()</h5><p>FrameworkServlet重写HttpServlet中的service()和doXxx()，这些方法中调用了processRequest(request, response)</p>
<p>所在类：org.springframework.web.servlet.FrameworkServlet</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">processRequest</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">    Throwable failureCause = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    LocaleContext previousLocaleContext = LocaleContextHolder.getLocaleContext();</span><br><span class="line">    LocaleContext localeContext = buildLocaleContext(request);</span><br><span class="line"></span><br><span class="line">    RequestAttributes previousAttributes = RequestContextHolder.getRequestAttributes();</span><br><span class="line">    ServletRequestAttributes requestAttributes = buildRequestAttributes(request, response, previousAttributes);</span><br><span class="line"></span><br><span class="line">    WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);</span><br><span class="line">    asyncManager.registerCallableInterceptor(FrameworkServlet.class.getName(), <span class="keyword">new</span> RequestBindingInterceptor());</span><br><span class="line"></span><br><span class="line">    initContextHolders(request, localeContext, requestAttributes);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="comment">// 执行服务，doService()是一个抽象方法，在DispatcherServlet中进行了重写</span></span><br><span class="line">        doService(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (ServletException | IOException ex) &#123;</span><br><span class="line">        failureCause = ex;</span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        failureCause = ex;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NestedServletException(<span class="string">&quot;Request processing failed&quot;</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        resetContextHolders(request, previousLocaleContext, previousAttributes);</span><br><span class="line">        <span class="keyword">if</span> (requestAttributes != <span class="keyword">null</span>) &#123;</span><br><span class="line">            requestAttributes.requestCompleted();</span><br><span class="line">        &#125;</span><br><span class="line">        logResult(request, response, failureCause, asyncManager);</span><br><span class="line">        publishRequestHandledEvent(request, response, startTime, failureCause);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="b-gt-doService"><a href="#b-gt-doService" class="headerlink" title="b&gt;doService()"></a>b&gt;doService()</h5><p>所在类：org.springframework.web.servlet.DispatcherServlet</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doService</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    logRequest(request);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Keep a snapshot of the request attributes in case of an include,</span></span><br><span class="line">    <span class="comment">// to be able to restore the original attributes after the include.</span></span><br><span class="line">    Map&lt;String, Object&gt; attributesSnapshot = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (WebUtils.isIncludeRequest(request)) &#123;</span><br><span class="line">        attributesSnapshot = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        Enumeration&lt;?&gt; attrNames = request.getAttributeNames();</span><br><span class="line">        <span class="keyword">while</span> (attrNames.hasMoreElements()) &#123;</span><br><span class="line">            String attrName = (String) attrNames.nextElement();</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.cleanupAfterInclude || attrName.startsWith(DEFAULT_STRATEGIES_PREFIX)) &#123;</span><br><span class="line">                attributesSnapshot.put(attrName, request.getAttribute(attrName));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Make framework objects available to handlers and view objects.</span></span><br><span class="line">    request.setAttribute(WEB_APPLICATION_CONTEXT_ATTRIBUTE, getWebApplicationContext());</span><br><span class="line">    request.setAttribute(LOCALE_RESOLVER_ATTRIBUTE, <span class="keyword">this</span>.localeResolver);</span><br><span class="line">    request.setAttribute(THEME_RESOLVER_ATTRIBUTE, <span class="keyword">this</span>.themeResolver);</span><br><span class="line">    request.setAttribute(THEME_SOURCE_ATTRIBUTE, getThemeSource());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.flashMapManager != <span class="keyword">null</span>) &#123;</span><br><span class="line">        FlashMap inputFlashMap = <span class="keyword">this</span>.flashMapManager.retrieveAndUpdate(request, response);</span><br><span class="line">        <span class="keyword">if</span> (inputFlashMap != <span class="keyword">null</span>) &#123;</span><br><span class="line">            request.setAttribute(INPUT_FLASH_MAP_ATTRIBUTE, Collections.unmodifiableMap(inputFlashMap));</span><br><span class="line">        &#125;</span><br><span class="line">        request.setAttribute(OUTPUT_FLASH_MAP_ATTRIBUTE, <span class="keyword">new</span> FlashMap());</span><br><span class="line">        request.setAttribute(FLASH_MAP_MANAGER_ATTRIBUTE, <span class="keyword">this</span>.flashMapManager);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    RequestPath requestPath = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.parseRequestPath &amp;&amp; !ServletRequestPathUtils.hasParsedRequestPath(request)) &#123;</span><br><span class="line">        requestPath = ServletRequestPathUtils.parseAndCache(request);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 处理请求和响应</span></span><br><span class="line">        doDispatch(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!WebAsyncUtils.getAsyncManager(request).isConcurrentHandlingStarted()) &#123;</span><br><span class="line">            <span class="comment">// Restore the original attribute snapshot, in case of an include.</span></span><br><span class="line">            <span class="keyword">if</span> (attributesSnapshot != <span class="keyword">null</span>) &#123;</span><br><span class="line">                restoreAttributesAfterInclude(request, attributesSnapshot);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (requestPath != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ServletRequestPathUtils.clearParsedRequestPath(request);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="c-gt-doDispatch"><a href="#c-gt-doDispatch" class="headerlink" title="c&gt;doDispatch()"></a>c&gt;doDispatch()</h5><p>所在类：org.springframework.web.servlet.DispatcherServlet</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doDispatch</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    HttpServletRequest processedRequest = request;</span><br><span class="line">    HandlerExecutionChain mappedHandler = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">boolean</span> multipartRequestParsed = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ModelAndView mv = <span class="keyword">null</span>;</span><br><span class="line">        Exception dispatchException = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            processedRequest = checkMultipart(request);</span><br><span class="line">            multipartRequestParsed = (processedRequest != request);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Determine handler for the current request.</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            	mappedHandler：调用链</span></span><br><span class="line"><span class="comment">                包含handler、interceptorList、interceptorIndex</span></span><br><span class="line"><span class="comment">            	handler：浏览器发送的请求所匹配的控制器方法</span></span><br><span class="line"><span class="comment">            	interceptorList：处理控制器方法的所有拦截器集合</span></span><br><span class="line"><span class="comment">            	interceptorIndex：拦截器索引，控制拦截器afterCompletion()的执行</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            mappedHandler = getHandler(processedRequest);</span><br><span class="line">            <span class="keyword">if</span> (mappedHandler == <span class="keyword">null</span>) &#123;</span><br><span class="line">                noHandlerFound(processedRequest, response);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Determine handler adapter for the current request.</span></span><br><span class="line">           	<span class="comment">// 通过控制器方法创建相应的处理器适配器，调用所对应的控制器方法</span></span><br><span class="line">            HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Process last-modified header, if supported by the handler.</span></span><br><span class="line">            String method = request.getMethod();</span><br><span class="line">            <span class="keyword">boolean</span> isGet = <span class="string">&quot;GET&quot;</span>.equals(method);</span><br><span class="line">            <span class="keyword">if</span> (isGet || <span class="string">&quot;HEAD&quot;</span>.equals(method)) &#123;</span><br><span class="line">                <span class="keyword">long</span> lastModified = ha.getLastModified(request, mappedHandler.getHandler());</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">new</span> ServletWebRequest(request, response).checkNotModified(lastModified) &amp;&amp; isGet) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">			</span><br><span class="line">            <span class="comment">// 调用拦截器的preHandle()</span></span><br><span class="line">            <span class="keyword">if</span> (!mappedHandler.applyPreHandle(processedRequest, response)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Actually invoke the handler.</span></span><br><span class="line">            <span class="comment">// 由处理器适配器调用具体的控制器方法，最终获得ModelAndView对象</span></span><br><span class="line">            mv = ha.handle(processedRequest, response, mappedHandler.getHandler());</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            applyDefaultViewName(processedRequest, mv);</span><br><span class="line">            <span class="comment">// 调用拦截器的postHandle()</span></span><br><span class="line">            mappedHandler.applyPostHandle(processedRequest, response, mv);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            dispatchException = ex;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Throwable err) &#123;</span><br><span class="line">            <span class="comment">// As of 4.3, we&#x27;re processing Errors thrown from handler methods as well,</span></span><br><span class="line">            <span class="comment">// making them available for @ExceptionHandler methods and other scenarios.</span></span><br><span class="line">            dispatchException = <span class="keyword">new</span> NestedServletException(<span class="string">&quot;Handler dispatch failed&quot;</span>, err);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 后续处理：处理模型数据和渲染视图</span></span><br><span class="line">        processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">        triggerAfterCompletion(processedRequest, response, mappedHandler, ex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable err) &#123;</span><br><span class="line">        triggerAfterCompletion(processedRequest, response, mappedHandler,</span><br><span class="line">                               <span class="keyword">new</span> NestedServletException(<span class="string">&quot;Handler processing failed&quot;</span>, err));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line">            <span class="comment">// Instead of postHandle and afterCompletion</span></span><br><span class="line">            <span class="keyword">if</span> (mappedHandler != <span class="keyword">null</span>) &#123;</span><br><span class="line">                mappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Clean up any resources used by a multipart request.</span></span><br><span class="line">            <span class="keyword">if</span> (multipartRequestParsed) &#123;</span><br><span class="line">                cleanupMultipart(processedRequest);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="d-gt-processDispatchResult"><a href="#d-gt-processDispatchResult" class="headerlink" title="d&gt;processDispatchResult()"></a>d&gt;processDispatchResult()</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processDispatchResult</span><span class="params">(HttpServletRequest request, HttpServletResponse response,</span></span></span><br><span class="line"><span class="params"><span class="function">                                   <span class="meta">@Nullable</span> HandlerExecutionChain mappedHandler, <span class="meta">@Nullable</span> ModelAndView mv,</span></span></span><br><span class="line"><span class="params"><span class="function">                                   <span class="meta">@Nullable</span> Exception exception)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> errorView = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (exception != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (exception <span class="keyword">instanceof</span> ModelAndViewDefiningException) &#123;</span><br><span class="line">            logger.debug(<span class="string">&quot;ModelAndViewDefiningException encountered&quot;</span>, exception);</span><br><span class="line">            mv = ((ModelAndViewDefiningException) exception).getModelAndView();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            Object handler = (mappedHandler != <span class="keyword">null</span> ? mappedHandler.getHandler() : <span class="keyword">null</span>);</span><br><span class="line">            mv = processHandlerException(request, response, handler, exception);</span><br><span class="line">            errorView = (mv != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Did the handler return a view to render?</span></span><br><span class="line">    <span class="keyword">if</span> (mv != <span class="keyword">null</span> &amp;&amp; !mv.wasCleared()) &#123;</span><br><span class="line">        <span class="comment">// 处理模型数据和渲染视图</span></span><br><span class="line">        render(mv, request, response);</span><br><span class="line">        <span class="keyword">if</span> (errorView) &#123;</span><br><span class="line">            WebUtils.clearErrorRequestAttributes(request);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">            logger.trace(<span class="string">&quot;No view rendering, null ModelAndView returned.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (WebAsyncUtils.getAsyncManager(request).isConcurrentHandlingStarted()) &#123;</span><br><span class="line">        <span class="comment">// Concurrent handling started during a forward</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mappedHandler != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// Exception (if any) is already handled..</span></span><br><span class="line">        <span class="comment">// 调用拦截器的afterCompletion()</span></span><br><span class="line">        mappedHandler.triggerAfterCompletion(request, response, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4、SpringMVC的执行流程"><a href="#4、SpringMVC的执行流程" class="headerlink" title="4、SpringMVC的执行流程"></a>4、SpringMVC的执行流程</h3><ol>
<li><p>用户向服务器发送请求，请求被SpringMVC 前端控制器 DispatcherServlet捕获。</p>
</li>
<li><p>DispatcherServlet对请求URL进行解析，得到请求资源标识符（URI），判断请求URI对应的映射：</p>
</li>
</ol>
<p>a) 不存在</p>
<p>i. 再判断是否配置了mvc:default-servlet-handler</p>
<p>ii. 如果没配置，则控制台报映射查找不到，客户端展示404错误</p>
<p><img src="/2022/03/03/SpringMVC%E7%AC%94%E8%AE%B0/img006.png" alt="image-20210709214911404"></p>
<p><img src="/2022/03/03/SpringMVC%E7%AC%94%E8%AE%B0/img007.png" alt="image-20210709214947432"></p>
<p>iii. 如果有配置，则访问目标资源（一般为静态资源，如：JS,CSS,HTML），找不到客户端也会展示404错误</p>
<p><img src="/2022/03/03/SpringMVC%E7%AC%94%E8%AE%B0/img008.png" alt="image-20210709215255693"></p>
<p><img src="/2022/03/03/SpringMVC%E7%AC%94%E8%AE%B0/img009.png" alt="image-20210709215336097"></p>
<p>b) 存在则执行下面的流程</p>
<ol start="3">
<li><p>根据该URI，调用HandlerMapping获得该Handler配置的所有相关的对象（包括Handler对象以及Handler对象对应的拦截器），最后以HandlerExecutionChain执行链对象的形式返回。</p>
</li>
<li><p>DispatcherServlet 根据获得的Handler，选择一个合适的HandlerAdapter。</p>
</li>
<li><p>如果成功获得HandlerAdapter，此时将开始执行拦截器的preHandler(…)方法【正向】</p>
</li>
<li><p>提取Request中的模型数据，填充Handler入参，开始执行Handler（Controller)方法，处理请求。在填充Handler的入参过程中，根据你的配置，Spring将帮你做一些额外的工作：</p>
</li>
</ol>
<p>a) HttpMessageConveter： 将请求消息（如Json、xml等数据）转换成一个对象，将对象转换为指定的响应信息</p>
<p>b) 数据转换：对请求消息进行数据转换。如String转换成Integer、Double等</p>
<p>c) 数据格式化：对请求消息进行数据格式化。 如将字符串转换成格式化数字或格式化日期等</p>
<p>d) 数据验证： 验证数据的有效性（长度、格式等），验证结果存储到BindingResult或Error中</p>
<ol start="7">
<li><p>Handler执行完成后，向DispatcherServlet 返回一个ModelAndView对象。</p>
</li>
<li><p>此时将开始执行拦截器的postHandle(…)方法【逆向】。</p>
</li>
<li><p>根据返回的ModelAndView（此时会判断是否存在异常：如果存在异常，则执行HandlerExceptionResolver进行异常处理）选择一个适合的ViewResolver进行视图解析，根据Model和View，来渲染视图。</p>
</li>
<li><p>渲染视图完毕执行拦截器的afterCompletion(…)方法【逆向】。</p>
</li>
<li><p>将渲染结果返回给客户端。</p>
</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>Typora+PicGo-Core+gitee建立图床</title>
    <url>/2021/09/03/Typora+PicGo-Core%E5%BB%BA%E7%AB%8B%E5%9B%BE%E5%BA%8A/</url>
    <content><![CDATA[<p>Typora+PicGo-Core+gitee建立图床(强烈建议不要使用github建立,因为就算图像上传成功,typora也会因为网络问题读取不到图片,很麻烦)</p>
<span id="more"></span>

<h1 id="typora设置"><a href="#typora设置" class="headerlink" title="typora设置"></a>typora设置</h1><p>typora点击文件,选择偏好设置,点击图像.</p>
<p>如图所示:</p>
<ol>
<li>选择picgo-core</li>
<li>点击下载更新,按照提示下载即可</li>
<li>点击,然后选择上传图片</li>
<li>勾选如图所示规则</li>
</ol>
<p><img src="https://gitee.com/zlpxiaokeai/img/raw/master/img/image-20210903103056849.png" alt="image-20210903103056849"></p>
<h1 id="PicGo-Core插件下载和配置文件"><a href="#PicGo-Core插件下载和配置文件" class="headerlink" title="PicGo-Core插件下载和配置文件"></a>PicGo-Core插件下载和配置文件</h1><h2 id="node-js安装"><a href="#node-js安装" class="headerlink" title="node.js安装"></a>node.js安装</h2><p>为后续顺利安装插件，先安装好node.js环境；到node.js官网:<a href="https://nodejs.org/en/%E4%B8%8B%E8%BD%BD%E6%88%96%E8%80%85%E7%82%B9%E5%87%BBhttps://nodejs.org/dist/%E8%BF%9B%E5%8E%BB%E5%8F%AF%E9%80%89%E6%8B%A9%E5%90%84%E7%89%88%E6%9C%AC%E8%BF%9B%E8%A1%8C%E7%9B%B8%E5%BA%94%E7%9A%84%E4%B8%8B%E8%BD%BD">https://nodejs.org/en/下载或者点击https://nodejs.org/dist/进去可选择各版本进行相应的下载</a></p>
<p>检查PATH环境变量是否配置了Node.js，在cmd窗口输入命令“path”查下是否有node.js路径；</p>
<p><img src="https://gitee.com/zlpxiaokeai/img/raw/master/img/image-20210903103621840.png" alt="image-20210903103621840"></p>
<p>我们可以看到PATH环境变量已经包含node.js,在cmd窗口继续输入命令“node –version”会输出版本信息，为以下安装插件的node.js环境就准备完毕了！</p>
<p><img src="https://gitee.com/zlpxiaokeai/img/raw/master/img/image-20210903103707330.png" alt="image-20210903103707330"></p>
<h2 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h2><p>分别安装gitee-uploader，github-plus插件来支持gitee，github图床上传.</p>
<p>首先确认picdo-core安装的位置在那儿,获取路径方式如下.</p>
<ol>
<li>首先依次点击typora,文件,偏好设置,图像,到达如图所示位置</li>
<li>点击验证图片上传选项</li>
<li>下面第二个图红线圈出的位置即为picdo-core安装位置</li>
</ol>
<p><img src="https://gitee.com/zlpxiaokeai/img/raw/master/img/image-20210903103852867.png" alt="image-20210903103852867"></p>
<p><img src="https://gitee.com/zlpxiaokeai/img/raw/master/img/image-20210903104101668.png" alt="image-20210903104101668"></p>
<p>然后在picgo安装的路径下运行cmd窗口安装插件（此处就用到了以上node.js环境支持）；</p>
<p><img src="https://gitee.com/zlpxiaokeai/img/raw/master/img/image-20210903104407557.png" alt="image-20210903104407557"></p>
<p>如图所示在上方输入cmd,点击回车即可在此文件夹运行cmd窗口.</p>
<p>依次运行下面的命令:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">.\picgo.exe install gitee-uploader   #gitee的插件</span><br><span class="line"></span><br><span class="line">./picgo install super-prefix  #　上传前文件重命名</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="创建gitee仓库"><a href="#创建gitee仓库" class="headerlink" title="创建gitee仓库"></a>创建gitee仓库</h2><p>仓库是用来存放上传的图片的。</p>
<ol>
<li>填写仓库名称</li>
<li>设置开源</li>
<li>选中模板</li>
</ol>
<p><img src="https://gitee.com/zlpxiaokeai/img/raw/master/img/image-20210903105641128.png" alt="image-20210903105641128"></p>
<h2 id="获取gitee-token-令牌"><a href="#获取gitee-token-令牌" class="headerlink" title="获取gitee token(令牌)"></a>获取gitee token(令牌)</h2><p>生成自己Gitee的token，用于下面的配置，使得Picgo-core可以操作你的仓库；</p>
<p>申请token:</p>
<ol>
<li>点击gitee里面自己的头像</li>
<li>点击设置</li>
<li>点击私人令牌</li>
</ol>
<p><img src="https://gitee.com/zlpxiaokeai/img/raw/master/img/image-20210903110011057.png" alt="image-20210903110011057"></p>
<p>点击生成令牌</p>
<p><img src="https://gitee.com/zlpxiaokeai/img/raw/master/img/image-20210903110132505.png" alt="image-20210903110132505"></p>
<ol>
<li>私人令牌描述自己随便写即可</li>
<li>一定要勾选projects,这样picgo才能上传图片到你的gitee刚刚生成的库里面</li>
<li>点击提交</li>
<li>保存生成的token,下面要用到,一定要先复制好,这个token只会出现这一次</li>
</ol>
<p><img src="https://gitee.com/zlpxiaokeai/img/raw/master/img/image-20210903110231791.png" alt="image-20210903110231791"></p>
<h2 id="配置-picgo-config-json文件"><a href="#配置-picgo-config-json文件" class="headerlink" title="配置~/.picgo/config.json文件"></a>配置~/.picgo/config.json文件</h2><p>如下方式打开配置文件</p>
<p><img src="https://gitee.com/zlpxiaokeai/img/raw/master/img/image-20210904105157434.png" alt="image-20210903105157434"></p>
<p>配置如下信息</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;picBed&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;uploader&quot;</span>: <span class="string">&quot;gitee&quot;</span>, <span class="comment">// 代表当前的上传图床</span></span><br><span class="line">    <span class="attr">&quot;gitee&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;repo&quot;</span>: <span class="string">&quot;用户名/仓库名称 &quot;</span>,    <span class="comment">//  必填</span></span><br><span class="line">      <span class="attr">&quot;token&quot;</span>: <span class="string">&quot;——————————&quot;</span>,    <span class="comment">// gitee 私人令牌,刚刚获取的token 必填</span></span><br><span class="line">      <span class="attr">&quot;path&quot;</span>: <span class="string">&quot;img/&quot;</span>, <span class="comment">// 自定义存储路径，比如 img/ </span></span><br><span class="line">      <span class="attr">&quot;customUrl&quot;</span>: <span class="string">&quot;&quot;</span>, <span class="comment">// 没有自己的域名的话，可以默认为空，不填写</span></span><br><span class="line">      <span class="attr">&quot;branch&quot;</span>: <span class="string">&quot;master&quot;</span> <span class="comment">// 分支名，默认是 master</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;picgoPlugins&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;picgo-plugin-gitee-uploader&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">&quot;picgo-plugin-super-prefix&quot;</span>: <span class="literal">true</span></span><br><span class="line">  &#125;, <span class="comment">// 为插件预留</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Typora</category>
        <category>PicGo</category>
      </categories>
      <tags>
        <tag>Typora</tag>
        <tag>PicGo</tag>
        <tag>gitee</tag>
      </tags>
  </entry>
  <entry>
    <title>git笔记</title>
    <url>/2021/09/04/git%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="Git的四个区域"><a href="#Git的四个区域" class="headerlink" title="Git的四个区域"></a>Git的四个区域</h1><p><strong>工作区</strong>(Workspace)</p>
<p>进行代码开发的的地方,也就是代码所在的文件夹，是你当前看到的，也是<strong>最新的</strong>。</p>
<p>平常我们开发就是拷贝远程仓库中的一个分支，基于该分支进行开发。在开发过程中就是对工作区的操作。</p>
<span id="more"></span>

<p><strong>暂存区</strong>(Stage)</p>
<p>.git目录下的index文件, 暂存区会记录<code>git add</code>添加文件的相关信息(文件名、大小、timestamp…)，不保存文件实体, 通过id指向每个文件实体。可以使用<code>git status</code>查看暂存区的状态。暂存区标记了你当前工作区中，哪些内容是被git管理的。</p>
<p>当你完成某个需求或功能后需要提交到远程仓库，那么第一步就是通过<code>git add</code>先提交到暂存区，被git管理。</p>
<p><strong>本地仓库(Repository)</strong></p>
<p>保存了对象被提交 过的各个版本，<strong>比起工作区和暂存区的内容，它要更旧一些</strong>。</p>
<p><code>git commit</code>后同步index的目录树到本地仓库，方便从下一步通过<code>git push</code>同步本地仓库与远程仓库的同步。</p>
<p><strong>远程仓库(Remote)</strong></p>
<p>远程仓库的内容可能被分布在多个地点的处于协作关系的本地仓库修改，因此它可能与本地仓库同步，也可能不同步，但是它的内容是最旧的。</p>
<p><img src="https://gitee.com/zlpxiaokeai/img/raw/master/img/image-20210904173327012.png" alt="image-20210904173327012"></p>
<p><strong>总结</strong></p>
<ol>
<li>任何对象都是在工作区中诞生和被修改；</li>
<li>任何修改都是从进入index区才开始被版本控制；</li>
<li><strong>只有把修改提交到本地仓库，该修改才能在仓库中留下痕迹(也就是commit之后)；</strong></li>
<li>与协作者分享本地的修改，可以把它们push到远程仓库来共享。</li>
</ol>
<h1 id="git常用命令"><a href="#git常用命令" class="headerlink" title="git常用命令"></a>git常用命令</h1><p><img src="https://gitee.com/zlpxiaokeai/img/raw/master/img/image-20210904191305153.png" alt="image-20210904191305153"></p>
<h2 id="设置用户签名"><a href="#设置用户签名" class="headerlink" title="设置用户签名"></a>设置用户签名</h2><p>在命令行输入：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git config --global user.name <span class="string">&quot;Your Name&quot;</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git config --global user.email <span class="string">&quot;email@example.com&quot;</span></span></span><br></pre></td></tr></table></figure>

<h2 id="初始化本地库"><a href="#初始化本地库" class="headerlink" title="初始化本地库"></a>初始化本地库</h2><p>创建一个空文件,右键执行git bash here</p>
<p><img src="https://gitee.com/zlpxiaokeai/img/raw/master/img/image-20210904191808364.png" alt="image-20210904191808364"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/zlpxiaokeai/img/raw/master/img/image-20210904192019305.png" alt="image-20210904192019305"></p>
<h2 id="切换到旧版本"><a href="#切换到旧版本" class="headerlink" title="切换到旧版本"></a>切换到旧版本</h2><ul>
<li><p>git checkout ：把整个git仓库文件回退到 commit 参数指定的版本</p>
</li>
<li><p>git checkout [] [–] ：回退 filepath 文件为 commit 参数指定的版本</p>
</li>
<li><p>git reset ：把git的HEAD指针指向到 commit 对应的版本，本地文件内容不会被回退</p>
</li>
<li><p>git reset –hard ：把git的HEAD指针指向到 commit 对应的版本，本地文件内容也会被回退</p>
</li>
</ul>
<h1 id="git-dif"><a href="#git-dif" class="headerlink" title="git dif"></a>git dif</h1><p>work tree (工作区) </p>
<p>index(缓冲区)</p>
<p>repository(本地仓库)</p>
<ol>
<li>git diff：是查看working tree与index的差别的。</li>
<li>git diff –cached：是查看index与repository的差别的。</li>
<li>git diff HEAD：是查看working tree和repository的差别的。其中：HEAD代表的是最近的一次commit的信息。</li>
</ol>
<p>如图所示，有区别则将两次对比的结果显示在输出中。对比没差别，就不显示。</p>
<p><img src="https://gitee.com/zlpxiaokeai/img/raw/master/img/image-20210904201909286.png" alt="image-20210904201909286"></p>
<h1 id="git-log-和git-reflog区别"><a href="#git-log-和git-reflog区别" class="headerlink" title="git log 和git reflog区别"></a>git log 和git reflog区别</h1><p>区别:</p>
<ul>
<li><p>git log可以显示所有提交过的版本信息，<strong>不包括已经被删除的 commit 记录和 reset 的操作</strong>。</p>
</li>
<li><p>git reflog是显示所有的操作记录，包括提交，回退的操作。一般用来找出操作记录中的版本号，进行回退.</p>
</li>
</ul>
<p><strong>例子</strong></p>
<p>如图所示,当前已经执行了三次提交,并且Head指针指在了第三次提交处.</p>
<p><img src="https://gitee.com/zlpxiaokeai/img/raw/master/img/image-20210904193632666.png" alt="image-20210904193632666"></p>
<p>如果此时执行如下指令:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git reset --hard 38a6bd891e86644b3772388a122eebb97329b22e</span><br><span class="line">git log</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以看到 log里面没有显示之前的third commit操作的信息了.而此时如果想退回third 的那个版本,我们该怎么获取版本号嘞,此时就可以使用git reflog命令.</p>
<p><img src="https://gitee.com/zlpxiaokeai/img/raw/master/img/image-20210904194023699.png"></p>
<p>执行如下命令,则会显示所有的操作记录，包括提交，回退，合并，删除分支等等的操作。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git reflog</span><br></pre></td></tr></table></figure>

<p>可以看到其中显示了third commit 的版本号。通过使用此版本号，我们可以执行命令跳回第三个版本。</p>
<p><img src="https://gitee.com/zlpxiaokeai/img/raw/master/img/image-20210904194652751.png" alt="image-20210904194652751"></p>
<p>同时其中还记录了我们刚刚的reset操作。</p>
<p><img src="https://gitee.com/zlpxiaokeai/img/raw/master/img/image-20210904194859950.png" alt="image-20210904194859950"></p>
<p>另外可<a href="https://blog.csdn.net/chenpuzhen/article/details/92084229">参考git log和git reflog的区别</a>.</p>
<p>#撤销修改</p>
<ol>
<li>当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令<code>git checkout -- file</code>。</li>
<li>当你不但改乱了工作区某个文件的内容，<strong>还添加到了暂存区时</strong>，想丢弃修改，分两步，第一步用命令<code>git reset HEAD &lt;file&gt;</code>，就回到了场景1，第二步按场景1操作。</li>
<li><strong>已经提交了不合适的修改到版本库(即本地库)时</strong>，想要撤销本次提交，参考<a href="https://www.liaoxuefeng.com/wiki/896043488029600/897013573512192">版本回退</a>一节，不过前提是没有推送到远程库。</li>
</ol>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.bilibili.com/video/BV1vy4y1s7k6?spm_id_from=pageDriver">尚硅谷 git视频</a>,  <a href="https://blog.csdn.net/zhongshun0928/article/details/119159273">视频配套他人笔记1</a><a href="https://blog.csdn.net/unique_perfect/article/details/104833391">视频配套他人笔记2</a></p>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>java泛型方法中不同T的作用</title>
    <url>/2021/12/17/java%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95%E4%B8%AD%E4%B8%8D%E5%90%8CT%E7%9A%84%E4%BD%9C%E7%94%A8/</url>
    <content><![CDATA[<h1 id="java泛型方法中不同T的作用"><a href="#java泛型方法中不同T的作用" class="headerlink" title="java泛型方法中不同T的作用"></a>java泛型方法中不同T的作用</h1><p>public <T> T getMapper(Class<T> type)</T></T></p>
<p>第一个<T>表示这个方法是一个泛型的方法，可以用<E>  T getMapper，只是起一个标识的作用</E></T></p>
<p>第二个T 表示是这个方法返回的类型</p>
<p>第三个Class<T>表示获取T类型的class</T></p>
<span id="more"></span>

<p><img src="https://gitee.com/zlpxiaokeai/img/raw/master/img/v2-42d56cc6f0a6dffd4489136a7fbd55fb_r.jpg" alt="preview"></p>
<p>参考：<a href="https://www.zhihu.com/question/418960665/answer/1448957325">https://www.zhihu.com/question/418960665/answer/1448957325</a> [君慕贤] 回答。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>private的访问权限是本类，而不是本对象</title>
    <url>/2021/09/22/private%E7%9A%84%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90%E6%98%AF%E6%9C%AC%E7%B1%BB%EF%BC%8C%E8%80%8C%E4%B8%8D%E6%98%AF%E6%9C%AC%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<p>如下面代码所示, object向下转型为student类,在Student类中equals方法中就可以访问私有属性name和age,也即<strong>证明了private的访问权限是本类，而不是本对象.</strong></p>
<span id="more"></span>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span>  <span class="title">Student</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span>  String name;</span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == o) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Student student = (Student) o;</span><br><span class="line">        <span class="keyword">return</span> age == student.age &amp;&amp;</span><br><span class="line">                Objects.equals(name, student.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title>typora使用技巧</title>
    <url>/2021/09/03/typora%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<p>#Typora中文输入状态下英文符号输出</p>
<p>Typora可以使用ctrl + . 在中文输入状态下英文符号输出，ctrl + . 即可改回中文输入状态输出中文符号。</p>
<span id="more"></span>

<p>sdfasdf</p>
]]></content>
      <categories>
        <category>typora</category>
      </categories>
      <tags>
        <tag>typora</tag>
      </tags>
  </entry>
  <entry>
    <title>命令行语法格式中常用符号的含义</title>
    <url>/2021/09/04/%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%AF%AD%E6%B3%95%E6%A0%BC%E5%BC%8F%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%AC%A6%E5%8F%B7%E7%9A%84%E5%90%AB%E4%B9%89/</url>
    <content><![CDATA[<p>在描述命令行参数的时候，对其格式有些约定俗成的写法，各系统之间也有差别。一般采用的格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">命令&lt;必选参数1|必选参数2&gt; [-option &#123;必选参数1|必选参数2|必选参数3&#125;] [可选参数…]&#123;(默认参数)|参数|参数&#125;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p><strong>命令格式中常用的几个符号含义如下</strong>：</p>
<p>　　尖括号&lt; &gt;：必选参数，实际使用时应将其替换为所需要的参数</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">　　命令语法：git help &lt;name&gt;</span><br><span class="line">　　</span><br><span class="line">　　实际使用：git help config 或 git help branch 或 ... (name被替换为实际的内容)</span><br></pre></td></tr></table></figure>

<p>　　大括号{ }：必选参数，内部使用，包含此处允许使用的参数</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">　　命令语法：git stash &#123;apply | pop&#125;</span><br><span class="line"></span><br><span class="line">　　实际使用：git stash apply 或 git stash pop (只能在必选参数apply或pop中选一个)</span><br></pre></td></tr></table></figure>

<p>　　方括号[ ]：可选参数，可写可不写</p>
<p>　　小括号( )：指明参数的默认值，只用于{ }中</p>
<p>　　竖线|：用于分隔多个互斥参数，含义为“或”，使用时只能选择其中的一个</p>
<p>　　省略号…：任意多个参数</p>
<p><strong>说明：</strong></p>
<p>大括号和尖括号的区别为：大括号中只能选择所列举的必选参数（或之一），尖括号中却需要根据实际替换必选参数</p>
<p>参考<a href="https://www.cnblogs.com/uakora/p/11809501.html">命令行符号的意义</a></p>
]]></content>
      <categories>
        <category>命令行</category>
      </categories>
      <tags>
        <tag>命令</tag>
      </tags>
  </entry>
  <entry>
    <title>单例模式为什么两次if判断</title>
    <url>/2021/12/22/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%A4%E6%AC%A1if%E5%88%A4%E6%96%AD/</url>
    <content><![CDATA[<p>内层判断：如果内层不加if判断，当有多个进程进入第一个判断内,也就是（1）的地方，就会实例化多次.</p>
<p>外层判断：当线程1走完了内层判断，对象实例化了，线程3也调用了getInstace（）函数，如果没有加外层的判断线程3还是要继续等待线程2的完成，而加上外层判断，就不需要等待了，直接返回了实例化的对象，提高了效率。</p>
<p>外层的判断是为了提高效率，内层的判断就是保证只实例化一次实例。</p>
<span id="more"></span>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonPattern</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> SingletonPattern instance ;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonPattern</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonPattern <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//外层判断:</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == instance) &#123;</span><br><span class="line">            <span class="comment">//(1)</span></span><br><span class="line">            <span class="keyword">synchronized</span> (SingletonPattern.class) &#123;</span><br><span class="line">                <span class="comment">//内层判断:</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">null</span> == instance)</span><br><span class="line">                instance = <span class="keyword">new</span> SingletonPattern();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>  instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>得到需要资源的绝对路径方法</title>
    <url>/2021/11/23/%E5%BE%97%E5%88%B0%E9%9C%80%E8%A6%81%E8%B5%84%E6%BA%90%E7%9A%84%E7%BB%9D%E5%AF%B9%E8%B7%AF%E5%BE%84%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h1 id="得到需要资源的绝对路径方法"><a href="#得到需要资源的绝对路径方法" class="headerlink" title="得到需要资源的绝对路径方法"></a>得到需要资源的绝对路径方法</h1><p>下面是一些得到classpath和当前类的绝对路径的一些方法。你可能需要使用其中的一些方法来得到你需要的资源的绝对路径。</p>
<span id="more"></span>

<ol>
<li>this.getClass().getResource（””）<br>得到的是当前类class文件的URI目录。不包括自己！<br>如：file：/D：/workspace/jbpmtest3/bin/com/test/</li>
<li>this.getClass().getResource（”/“）<br>得到的是当前的classpath的 绝对URI路径  。<br>如：file：/D：/workspace/jbpmtest3/bin/</li>
<li>this.getClass()  . getClassLoader().getResource（””）<br>得到的也是当前ClassPath的 绝对URI路径  。<br>如：file：/D：/workspace/jbpmtest3/bin/</li>
<li>ClassLoader.getSystemResource（””）<br>得到的也是当前ClassPath的 绝对URI路径  。<br>如：file：/D：/workspace/jbpmtest3/bin/</li>
<li>Thread.currentThread().getContextClassLoader ().getResource（””）<br>得到的也是当前ClassPath的 绝对URI路径  。<br>如：file：/D：/workspace/jbpmtest3/bin/</li>
<li>ServletActionContext.getServletContext().getRealPath(“/”)<br>Web应用程序  中，得到Web应用程序的根目录的绝对路径。这样，我们只需要提供相对于Web应用程序根目录的路径，就可以构建出定位资源的绝对路径。</li>
</ol>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 编译后，项目根路径，写法1</span></span><br><span class="line">String url1 = ConnectionTest.class.getClassLoader().getResource(<span class="string">&quot;&quot;</span>).toString();</span><br><span class="line">System.out.println(url1);</span><br><span class="line"><span class="comment">// 编译后，项目根路径，写法2</span></span><br><span class="line">String url2 = ConnectionTest.class.getResource(<span class="string">&quot;/&quot;</span>).toString();</span><br><span class="line">System.out.println(url2);</span><br><span class="line"><span class="comment">// 编译后，文件根路径</span></span><br><span class="line">String url3 = ConnectionTest.class.getResource(<span class="string">&quot;&quot;</span>).toString();</span><br><span class="line">System.out.println(url3);</span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line">file:/E:/code/jdbc/target/test-classes/</span><br><span class="line">file:/E:/code/jdbc/target/test-classes/</span><br><span class="line">file:/E:/code/jdbc/target/test-classes/org/example/</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>JDBC核心技术</title>
    <url>/2021/11/22/%E5%B0%9A%E7%A1%85%E8%B0%B7_%E5%AE%8B%E7%BA%A2%E5%BA%B7_JDBC/</url>
    <content><![CDATA[<h1 id="JDBC核心技术"><a href="#JDBC核心技术" class="headerlink" title="JDBC核心技术"></a>JDBC核心技术</h1><p>讲师：宋红康</p>
<p>微博：尚硅谷-宋红康</p>
<hr>
<h2 id="第1章：JDBC概述"><a href="#第1章：JDBC概述" class="headerlink" title="第1章：JDBC概述"></a>第1章：JDBC概述</h2><h3 id="1-1-数据的持久化"><a href="#1-1-数据的持久化" class="headerlink" title="1.1 数据的持久化"></a>1.1 数据的持久化</h3><ul>
<li><p>持久化(persistence)：<strong>把数据保存到可掉电式存储设备中以供之后使用</strong>。大多数情况下，特别是企业级应用，<strong>数据持久化意味着将内存中的数据保存到硬盘</strong>上加以”固化”<strong>，而持久化的实现过程大多通过各种关系数据库来完成</strong>。</p>
</li>
<li><p>持久化的主要应用是将内存中的数据存储在关系型数据库中，当然也可以存储在磁盘文件、XML数据文件中。</p>
<span id="more"></span>

<p><img src="https://gitee.com/zlpxiaokeai/img/raw/master/img/1566741430592.png" alt="1566741430592"> </p>
</li>
</ul>
<h3 id="1-2-Java中的数据存储技术"><a href="#1-2-Java中的数据存储技术" class="headerlink" title="1.2 Java中的数据存储技术"></a>1.2 Java中的数据存储技术</h3><ul>
<li><p>在Java中，数据库存取技术可分为如下几类：</p>
<ul>
<li><p><strong>JDBC</strong>直接访问数据库</p>
</li>
<li><p>JDO (Java Data Object )技术</p>
</li>
<li><p><strong>第三方O/R工具</strong>，如Hibernate, Mybatis 等</p>
</li>
</ul>
</li>
<li><p>JDBC是java访问数据库的基石，JDO、Hibernate、MyBatis等只是更好的封装了JDBC。</p>
</li>
</ul>
<h3 id="1-3-JDBC介绍"><a href="#1-3-JDBC介绍" class="headerlink" title="1.3 JDBC介绍"></a>1.3 JDBC介绍</h3><ul>
<li>JDBC(Java Database Connectivity)是一个<strong>独立于特定数据库管理系统、通用的SQL数据库存取和操作的公共接口</strong>（一组API），定义了用来访问数据库的标准Java类库，（<strong>java.sql,javax.sql</strong>）使用这些类库可以以一种<strong>标准</strong>的方法、方便地访问数据库资源。</li>
<li><strong>JDBC：sun公司提供的一套API，使用这套API可以实现对数据库的管理操作。（获取连接、CRUD等）</strong></li>
<li>JDBC为访问不同的数据库提供了一种<strong>统一的途径</strong>，为开发者屏蔽了一些细节问题。</li>
<li>JDBC的目标是使Java程序员使用JDBC可以连接任何<strong>提供了JDBC驱动程序</strong>的数据库系统，这样就使得程序员无需对特定的数据库系统的特点有过多的了解，从而大大简化和加快了开发过程。</li>
<li>如果没有JDBC，那么Java程序访问数据库时是这样的：</li>
</ul>
<p><img src="https://gitee.com/zlpxiaokeai/img/raw/master/img/1555575760234.png" alt="1555575760234"></p>
<hr>
<ul>
<li>有了JDBC，Java程序访问数据库时是这样的：</li>
</ul>
<p><img src="https://gitee.com/zlpxiaokeai/img/raw/master/img/1555575981203.png" alt="1555575981203"></p>
<hr>
<ul>
<li>总结如下：</li>
</ul>
<p><img src="https://gitee.com/zlpxiaokeai/img/raw/master/img/1566741692804.png" alt="1566741692804"></p>
<h3 id="1-4-JDBC体系结构"><a href="#1-4-JDBC体系结构" class="headerlink" title="1.4 JDBC体系结构"></a>1.4 JDBC体系结构</h3><ul>
<li>JDBC接口（API）包括两个层次：<ul>
<li><strong>面向应用的API</strong>：Java API，抽象接口，供应用程序开发人员使用（连接数据库，执行SQL语句，获得结果）。</li>
<li> <strong>面向数据库的API</strong>：Java Driver API，供开发商开发数据库驱动程序用。</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>JDBC是sun公司提供一套用于数据库操作的接口，java程序员只需要面向这套接口编程即可。</strong></p>
<p><strong>不同的数据库厂商，需要针对这套接口，提供不同实现。不同的实现的集合，即为不同数据库的驱动。                                                                ————面向接口编程</strong></p>
</blockquote>
<h3 id="1-5-JDBC程序编写步骤"><a href="#1-5-JDBC程序编写步骤" class="headerlink" title="1.5 JDBC程序编写步骤"></a>1.5 JDBC程序编写步骤</h3><p><img src="https://gitee.com/zlpxiaokeai/img/raw/master/img/1565969323908.png" alt="1565969323908"></p>
<blockquote>
<p>补充：ODBC(<strong>Open Database Connectivity</strong>，开放式数据库连接)，是微软在Windows平台下推出的。使用者在程序中只需要调用ODBC API，由 ODBC 驱动程序将调用转换成为对特定的数据库的调用请求。</p>
</blockquote>
<h2 id="第2章：获取数据库连接"><a href="#第2章：获取数据库连接" class="headerlink" title="第2章：获取数据库连接"></a>第2章：获取数据库连接</h2><h3 id="2-1-要素一：Driver接口实现类"><a href="#2-1-要素一：Driver接口实现类" class="headerlink" title="2.1 要素一：Driver接口实现类"></a>2.1 要素一：Driver接口实现类</h3><h4 id="2-1-1-Driver接口介绍"><a href="#2-1-1-Driver接口介绍" class="headerlink" title="2.1.1 Driver接口介绍"></a>2.1.1 Driver接口介绍</h4><ul>
<li><p>java.sql.Driver 接口是所有 JDBC 驱动程序需要实现的接口。这个接口是提供给数据库厂商使用的，不同数据库厂商提供不同的实现。 </p>
</li>
<li><p>在程序中不需要直接去访问实现了 Driver 接口的类，而是由驱动程序管理器类(java.sql.DriverManager)去调用这些Driver实现。</p>
<ul>
<li>Oracle的驱动：<strong>oracle.jdbc.driver.OracleDriver</strong></li>
<li>mySql的驱动： <strong>com.mysql.jdbc.Driver</strong></li>
</ul>
</li>
</ul>
<p><img src="https://gitee.com/zlpxiaokeai/img/raw/master/img/1555576157618.png" alt="1555576157618"></p>
<p><img src="https://gitee.com/zlpxiaokeai/img/raw/master/img/1555576170074.png" alt="1555576170074"></p>
<ul>
<li>将上述jar包拷贝到Java工程的一个目录中，习惯上新建一个lib文件夹。</li>
</ul>
<p> <img src="https://gitee.com/zlpxiaokeai/img/raw/master/img/1566134718955.png" alt="1566134718955"></p>
<p>在驱动jar上右键–&gt;Build Path–&gt;Add to Build Path</p>
<p> <img src="https://gitee.com/zlpxiaokeai/img/raw/master/img/1566134781682.png" alt="1566134781682"></p>
<p>注意：如果是Dynamic Web Project（动态的web项目）话，则是把驱动jar放到WebContent（有的开发工具叫WebRoot）目录中的WEB-INF目录中的lib目录下即可</p>
<p> <img src="https://gitee.com/zlpxiaokeai/img/raw/master/img/1566135290460.png" alt="1566135290460"></p>
<h4 id="2-1-2-加载与注册JDBC驱动"><a href="#2-1-2-加载与注册JDBC驱动" class="headerlink" title="2.1.2 加载与注册JDBC驱动"></a>2.1.2 加载与注册JDBC驱动</h4><ul>
<li><p>加载驱动：加载 JDBC 驱动需调用 Class 类的静态方法 forName()，向其传递要加载的 JDBC 驱动的类名</p>
<ul>
<li><strong>Class.forName(“com.mysql.jdbc.Driver”);</strong></li>
</ul>
</li>
<li><p>注册驱动：DriverManager 类是驱动程序管理器类，负责管理驱动程序</p>
<ul>
<li><p><strong>使用DriverManager.registerDriver(com.mysql.jdbc.Driver)来注册驱动</strong></p>
</li>
<li><p>通常不用显式调用 DriverManager 类的 registerDriver() 方法来注册驱动程序类的实例，因为 Driver 接口的驱动程序类<strong>都</strong>包含了静态代码块，在这个静态代码块中，会调用 DriverManager.registerDriver() 方法来注册自身的一个实例。下图是MySQL的Driver实现类的源码：</p>
<p><img src="https://gitee.com/zlpxiaokeai/img/raw/master/img/1566136831283.png" alt="1566136831283"></p>
</li>
</ul>
</li>
</ul>
<h3 id="2-2-要素二：URL"><a href="#2-2-要素二：URL" class="headerlink" title="2.2 要素二：URL"></a>2.2 要素二：URL</h3><ul>
<li><p>JDBC URL 用于标识一个被注册的驱动程序，驱动程序管理器通过这个 URL 选择正确的驱动程序，从而建立到数据库的连接。</p>
</li>
<li><p>JDBC URL的标准由三部分组成，各部分间用冒号分隔。 </p>
<ul>
<li><strong>jdbc:子协议:子名称</strong></li>
<li><strong>协议</strong>：JDBC URL中的协议总是jdbc </li>
<li><strong>子协议</strong>：子协议用于标识一个数据库驱动程序</li>
<li><strong>子名称</strong>：一种标识数据库的方法。子名称可以依不同的子协议而变化，用子名称的目的是为了<strong>定位数据库</strong>提供足够的信息。包含<strong>主机名</strong>(对应服务端的ip地址)<strong>，端口号，数据库名</strong></li>
</ul>
</li>
<li><p>举例：</p>
<p><img src="https://gitee.com/zlpxiaokeai/img/raw/master/img/1555576477107.png" alt="1555576477107"></p>
</li>
<li><p><strong>几种常用数据库的 JDBC URL</strong></p>
<ul>
<li><p>MySQL的连接URL编写方式：</p>
<ul>
<li>jdbc:mysql://主机名称:mysql服务端口号/数据库名称?参数=值&amp;参数=值</li>
<li>jdbc:mysql://localhost:3306/atguigu</li>
<li>jdbc:mysql://localhost:3306/atguigu**?useUnicode=true&amp;characterEncoding=utf8**（如果JDBC程序与服务器端的字符集不一致，会导致乱码，那么可以通过参数指定服务器端的字符集）</li>
<li>jdbc:mysql://localhost:3306/atguigu?user=root&amp;password=123456</li>
</ul>
</li>
<li><p>Oracle 9i的连接URL编写方式：</p>
<ul>
<li>jdbc:oracle:thin:@主机名称:oracle服务端口号:数据库名称</li>
<li>jdbc:oracle:thin:@localhost:1521:atguigu</li>
</ul>
</li>
<li><p>SQLServer的连接URL编写方式：</p>
<ul>
<li><p>jdbc:sqlserver://主机名称:sqlserver服务端口号:DatabaseName=数据库名称</p>
</li>
<li><p>jdbc:sqlserver://localhost:1433:DatabaseName=atguigu</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="2-3-要素三：用户名和密码"><a href="#2-3-要素三：用户名和密码" class="headerlink" title="2.3 要素三：用户名和密码"></a>2.3 要素三：用户名和密码</h3><ul>
<li>user,password可以用“属性名=属性值”方式告诉数据库</li>
<li>可以调用 DriverManager 类的 getConnection() 方法建立到数据库的连接</li>
</ul>
<h3 id="2-4-数据库连接方式举例"><a href="#2-4-数据库连接方式举例" class="headerlink" title="2.4 数据库连接方式举例"></a>2.4 数据库连接方式举例</h3><h4 id="2-4-1-连接方式一-选学"><a href="#2-4-1-连接方式一-选学" class="headerlink" title="2.4.1 连接方式一 (选学)"></a>2.4.1 连接方式一 (选学)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testConnection1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">//1.提供java.sql.Driver接口实现类的对象</span></span><br><span class="line">           Driver driver = <span class="keyword">null</span>;</span><br><span class="line">           driver = <span class="keyword">new</span> com.mysql.jdbc.Driver();</span><br><span class="line"></span><br><span class="line">           <span class="comment">//2.提供url，指明具体操作的数据</span></span><br><span class="line">           String url = <span class="string">&quot;jdbc:mysql://localhost:3306/test&quot;</span>;</span><br><span class="line"></span><br><span class="line">           <span class="comment">//3.提供Properties的对象，指明用户名和密码</span></span><br><span class="line">           Properties info = <span class="keyword">new</span> Properties();</span><br><span class="line">           info.setProperty(<span class="string">&quot;user&quot;</span>, <span class="string">&quot;root&quot;</span>);</span><br><span class="line">           info.setProperty(<span class="string">&quot;password&quot;</span>, <span class="string">&quot;abc123&quot;</span>);</span><br><span class="line"></span><br><span class="line">           <span class="comment">//4.调用driver的connect()，获取连接</span></span><br><span class="line">           Connection conn = driver.connect(url, info);</span><br><span class="line">           System.out.println(conn);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>说明：上述代码中显式出现了第三方数据库的API</p>
</blockquote>
<h4 id="2-4-2-连接方式二-选学"><a href="#2-4-2-连接方式二-选学" class="headerlink" title="2.4.2 连接方式二 (选学)"></a>2.4.2 连接方式二 (选学)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testConnection2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">//1.实例化Driver</span></span><br><span class="line">           String className = <span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>;</span><br><span class="line">           Class clazz = Class.forName(className);</span><br><span class="line">           Driver driver = (Driver) clazz.newInstance();</span><br><span class="line"></span><br><span class="line">           <span class="comment">//2.提供url，指明具体操作的数据</span></span><br><span class="line">           String url = <span class="string">&quot;jdbc:mysql://localhost:3306/test&quot;</span>;</span><br><span class="line"></span><br><span class="line">           <span class="comment">//3.提供Properties的对象，指明用户名和密码</span></span><br><span class="line">           Properties info = <span class="keyword">new</span> Properties();</span><br><span class="line">           info.setProperty(<span class="string">&quot;user&quot;</span>, <span class="string">&quot;root&quot;</span>);</span><br><span class="line">           info.setProperty(<span class="string">&quot;password&quot;</span>, <span class="string">&quot;abc123&quot;</span>);</span><br><span class="line"></span><br><span class="line">           <span class="comment">//4.调用driver的connect()，获取连接</span></span><br><span class="line">           Connection conn = driver.connect(url, info);</span><br><span class="line">           System.out.println(conn);</span><br><span class="line"></span><br><span class="line">       &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>说明：相较于方式一，这里使用反射实例化Driver，不在代码中体现第三方数据库的API。体现了面向接口编程思想。</p>
</blockquote>
<h4 id="2-4-3-连接方式三-选学"><a href="#2-4-3-连接方式三-选学" class="headerlink" title="2.4.3 连接方式三 (选学)"></a>2.4.3 连接方式三 (选学)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testConnection3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">//1.数据库连接的4个基本要素：</span></span><br><span class="line">           String url = <span class="string">&quot;jdbc:mysql://localhost:3306/test&quot;</span>;</span><br><span class="line">           String user = <span class="string">&quot;root&quot;</span>;</span><br><span class="line">           String password = <span class="string">&quot;abc123&quot;</span>;</span><br><span class="line">           String driverName = <span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>;</span><br><span class="line"></span><br><span class="line">           <span class="comment">//2.实例化Driver</span></span><br><span class="line">           Class clazz = Class.forName(driverName);</span><br><span class="line">           Driver driver = (Driver) clazz.newInstance();</span><br><span class="line">           <span class="comment">//3.注册驱动</span></span><br><span class="line">           DriverManager.registerDriver(driver);</span><br><span class="line">           <span class="comment">//4.获取连接</span></span><br><span class="line">           Connection conn = DriverManager.getConnection(url, user, password);</span><br><span class="line">           System.out.println(conn);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>说明：使用DriverManager实现数据库的连接。体会获取连接必要的4个基本要素。</p>
</blockquote>
<h4 id="2-4-4-连接方式四-选学"><a href="#2-4-4-连接方式四-选学" class="headerlink" title="2.4.4 连接方式四 (选学)"></a>2.4.4 连接方式四 (选学)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testConnection4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">//1.数据库连接的4个基本要素：</span></span><br><span class="line">           String url = <span class="string">&quot;jdbc:mysql://localhost:3306/test&quot;</span>;</span><br><span class="line">           String user = <span class="string">&quot;root&quot;</span>;</span><br><span class="line">           String password = <span class="string">&quot;abc123&quot;</span>;</span><br><span class="line">           String driverName = <span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>;</span><br><span class="line"></span><br><span class="line">           <span class="comment">//2.加载驱动 （①实例化Driver ②注册驱动）</span></span><br><span class="line">           Class.forName(driverName);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">           <span class="comment">//Driver driver = (Driver) clazz.newInstance();</span></span><br><span class="line">           <span class="comment">//3.注册驱动</span></span><br><span class="line">           <span class="comment">//DriverManager.registerDriver(driver);</span></span><br><span class="line">           <span class="comment">/*</span></span><br><span class="line"><span class="comment">           可以注释掉上述代码的原因，是因为在mysql的Driver类中声明有：</span></span><br><span class="line"><span class="comment">           static &#123;</span></span><br><span class="line"><span class="comment">               try &#123;</span></span><br><span class="line"><span class="comment">                   DriverManager.registerDriver(new Driver());</span></span><br><span class="line"><span class="comment">               &#125; catch (SQLException var1) &#123;</span></span><br><span class="line"><span class="comment">                   throw new RuntimeException(&quot;Can&#x27;t register driver!&quot;);</span></span><br><span class="line"><span class="comment">               &#125;</span></span><br><span class="line"><span class="comment">           &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">           <span class="comment">//3.获取连接</span></span><br><span class="line">           Connection conn = DriverManager.getConnection(url, user, password);</span><br><span class="line">           System.out.println(conn);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>说明：不必显式的注册驱动了。因为在DriverManager的源码中已经存在静态代码块，实现了驱动的注册。</p>
</blockquote>
<h4 id="2-4-5-连接方式五-最终版"><a href="#2-4-5-连接方式五-最终版" class="headerlink" title="2.4.5 连接方式五(最终版)"></a>2.4.5 连接方式五(最终版)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">testConnection5</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">   	<span class="comment">//1.加载配置文件</span></span><br><span class="line">       InputStream is = ConnectionTest.class.getClassLoader().getResourceAsStream(<span class="string">&quot;jdbc.properties&quot;</span>);</span><br><span class="line">       Properties pros = <span class="keyword">new</span> Properties();</span><br><span class="line">       pros.load(is);</span><br><span class="line">       </span><br><span class="line">       <span class="comment">//2.读取配置信息</span></span><br><span class="line">       String user = pros.getProperty(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">       String password = pros.getProperty(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">       String url = pros.getProperty(<span class="string">&quot;url&quot;</span>);</span><br><span class="line">       String driverClass = pros.getProperty(<span class="string">&quot;driverClass&quot;</span>);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//3.加载驱动</span></span><br><span class="line">       Class.forName(driverClass);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//4.获取连接</span></span><br><span class="line">       Connection conn = DriverManager.getConnection(url,user,password);</span><br><span class="line">       System.out.println(conn);</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>其中，配置文件声明在工程的src目录下：【jdbc.properties】</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">user</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">password</span>=<span class="string">abc123</span></span><br><span class="line"><span class="attr">url</span>=<span class="string">jdbc:mysql://localhost:3306/test</span></span><br><span class="line"><span class="attr">driverClass</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>说明：使用配置文件的方式保存配置信息，在代码中加载配置文件</p>
<p><strong>使用配置文件的好处：</strong></p>
<p>①实现了代码和数据的分离，如果需要修改配置信息，直接在配置文件中修改，不需要深入代码<br>②如果修改了配置信息，省去重新编译的过程。</p>
</blockquote>
<h2 id="第3章：使用PreparedStatement实现CRUD操作"><a href="#第3章：使用PreparedStatement实现CRUD操作" class="headerlink" title="第3章：使用PreparedStatement实现CRUD操作"></a>第3章：使用PreparedStatement实现CRUD操作</h2><h3 id="3-1-操作和访问数据库"><a href="#3-1-操作和访问数据库" class="headerlink" title="3.1 操作和访问数据库"></a>3.1 操作和访问数据库</h3><ul>
<li><p>数据库连接被用于向数据库服务器发送命令和 SQL 语句，并接受数据库服务器返回的结果。其实一个数据库连接就是一个Socket连接。</p>
</li>
<li><p>在 java.sql 包中有 3 个接口分别定义了对数据库的调用的不同方式：</p>
<ul>
<li>Statement：用于执行静态 SQL 语句并返回它所生成结果的对象。 </li>
<li>PrepatedStatement：SQL 语句被预编译并存储在此对象中，可以使用此对象多次高效地执行该语句。</li>
<li>CallableStatement：用于执行 SQL 存储过程</li>
</ul>
<p><img src="https://gitee.com/zlpxiaokeai/img/raw/master/img/1566573842140.png" alt="1566573842140"></p>
</li>
</ul>
<h3 id="3-2-使用Statement操作数据表的弊端"><a href="#3-2-使用Statement操作数据表的弊端" class="headerlink" title="3.2 使用Statement操作数据表的弊端"></a>3.2 使用Statement操作数据表的弊端</h3><ul>
<li><p>通过调用 Connection 对象的 createStatement() 方法创建该对象。该对象用于执行静态的 SQL 语句，并且返回执行结果。</p>
</li>
<li><p>Statement 接口中定义了下列方法用于执行 SQL 语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> excuteUpdate(String <span class="keyword">sql</span>)：执行更新操作<span class="keyword">INSERT</span>、UPDATE、<span class="keyword">DELETE</span></span><br><span class="line">ResultSet executeQuery(String <span class="keyword">sql</span>)：执行查询操作<span class="keyword">SELECT</span></span><br></pre></td></tr></table></figure></li>
<li><p>但是使用Statement操作数据表存在弊端：</p>
<ul>
<li><strong>问题一：存在拼串操作，繁琐</strong></li>
<li><strong>问题二：存在SQL注入问题</strong></li>
</ul>
</li>
<li><p>SQL 注入是利用某些系统没有对用户输入的数据进行充分的检查，而在用户输入数据中注入非法的 SQL 语句段或命令(如：SELECT user, password FROM user_table WHERE user=’a’ OR 1 = ‘ AND password = ‘ OR ‘1’ = ‘1’) ，从而利用系统的 SQL 引擎完成恶意行为的做法。</p>
</li>
<li><p>对于 Java 而言，要防范 SQL 注入，只要用 PreparedStatement(从Statement扩展而来) 取代 Statement 就可以了。</p>
</li>
<li><p>代码演示：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StatementTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 使用Statement的弊端：需要拼写sql语句，并且存在SQL注入的问题</span></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testLogin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		Scanner scan = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"></span><br><span class="line">		System.out.print(<span class="string">&quot;用户名：&quot;</span>);</span><br><span class="line">		String userName = scan.nextLine();</span><br><span class="line">		System.out.print(<span class="string">&quot;密   码：&quot;</span>);</span><br><span class="line">		String password = scan.nextLine();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// SELECT user,password FROM user_table WHERE USER = &#x27;1&#x27; or &#x27; AND PASSWORD = &#x27;=&#x27;1&#x27; or &#x27;1&#x27; = &#x27;1&#x27;;</span></span><br><span class="line">		String sql = <span class="string">&quot;SELECT user,password FROM user_table WHERE USER = &#x27;&quot;</span> + userName + <span class="string">&quot;&#x27; AND PASSWORD = &#x27;&quot;</span> + password</span><br><span class="line">				+ <span class="string">&quot;&#x27;&quot;</span>;</span><br><span class="line">		User user = get(sql, User.class);</span><br><span class="line">		<span class="keyword">if</span> (user != <span class="keyword">null</span>) &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;登陆成功!&quot;</span>);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;用户名或密码错误！&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 使用Statement实现对数据表的查询操作</span></span><br><span class="line">	<span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">get</span><span class="params">(String sql, Class&lt;T&gt; clazz)</span> </span>&#123;</span><br><span class="line">		T t = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">		Connection conn = <span class="keyword">null</span>;</span><br><span class="line">		Statement st = <span class="keyword">null</span>;</span><br><span class="line">		ResultSet rs = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">// 1.加载配置文件</span></span><br><span class="line">			InputStream is = StatementTest.class.getClassLoader().getResourceAsStream(<span class="string">&quot;jdbc.properties&quot;</span>);</span><br><span class="line">			Properties pros = <span class="keyword">new</span> Properties();</span><br><span class="line">			pros.load(is);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 2.读取配置信息</span></span><br><span class="line">			String user = pros.getProperty(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">			String password = pros.getProperty(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">			String url = pros.getProperty(<span class="string">&quot;url&quot;</span>);</span><br><span class="line">			String driverClass = pros.getProperty(<span class="string">&quot;driverClass&quot;</span>);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 3.加载驱动</span></span><br><span class="line">			Class.forName(driverClass);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 4.获取连接</span></span><br><span class="line">			conn = DriverManager.getConnection(url, user, password);</span><br><span class="line"></span><br><span class="line">			st = conn.createStatement();</span><br><span class="line"></span><br><span class="line">			rs = st.executeQuery(sql);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 获取结果集的元数据</span></span><br><span class="line">			ResultSetMetaData rsmd = rs.getMetaData();</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 获取结果集的列数</span></span><br><span class="line">			<span class="keyword">int</span> columnCount = rsmd.getColumnCount();</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (rs.next()) &#123;</span><br><span class="line"></span><br><span class="line">				t = clazz.newInstance();</span><br><span class="line"></span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; columnCount; i++) &#123;</span><br><span class="line">					<span class="comment">// //1. 获取列的名称</span></span><br><span class="line">					<span class="comment">// String columnName = rsmd.getColumnName(i+1);</span></span><br><span class="line"></span><br><span class="line">					<span class="comment">// 1. 获取列的别名</span></span><br><span class="line">					String columnName = rsmd.getColumnLabel(i + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">					<span class="comment">// 2. 根据列名获取对应数据表中的数据</span></span><br><span class="line">					Object columnVal = rs.getObject(columnName);</span><br><span class="line"></span><br><span class="line">					<span class="comment">// 3. 将数据表中得到的数据，封装进对象</span></span><br><span class="line">					Field field = clazz.getDeclaredField(columnName);</span><br><span class="line">					field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">					field.set(t, columnVal);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">return</span> t;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			<span class="comment">// 关闭资源</span></span><br><span class="line">			<span class="keyword">if</span> (rs != <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					rs.close();</span><br><span class="line">				&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (st != <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					st.close();</span><br><span class="line">				&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (conn != <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					conn.close();</span><br><span class="line">				&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>综上：</p>
<p><img src="https://gitee.com/zlpxiaokeai/img/raw/master/img/1566569819744.png" alt="1566569819744"></p>
<h3 id="3-3-PreparedStatement的使用"><a href="#3-3-PreparedStatement的使用" class="headerlink" title="3.3 PreparedStatement的使用"></a>3.3 PreparedStatement的使用</h3><h4 id="3-3-1-PreparedStatement介绍"><a href="#3-3-1-PreparedStatement介绍" class="headerlink" title="3.3.1 PreparedStatement介绍"></a>3.3.1 PreparedStatement介绍</h4><ul>
<li><p>可以通过调用 Connection 对象的 <strong>preparedStatement(String sql)</strong> 方法获取 PreparedStatement 对象</p>
</li>
<li><p><strong>PreparedStatement 接口是 Statement 的子接口，它表示一条预编译过的 SQL 语句</strong></p>
</li>
<li><p>PreparedStatement 对象所代表的 SQL 语句中的参数用问号(?)来表示，调用 PreparedStatement 对象的 setXxx() 方法来设置这些参数. setXxx() 方法有两个参数，第一个参数是要设置的 SQL 语句中的参数的索引(从 1 开始)，第二个是设置的 SQL 语句中的参数的值</p>
</li>
</ul>
<h4 id="3-3-2-PreparedStatement-vs-Statement"><a href="#3-3-2-PreparedStatement-vs-Statement" class="headerlink" title="3.3.2 PreparedStatement vs Statement"></a>3.3.2 PreparedStatement vs Statement</h4><ul>
<li><p>代码的可读性和可维护性。</p>
</li>
<li><p><strong>PreparedStatement 能最大可能提高性能：</strong></p>
<ul>
<li>DBServer会对<strong>预编译</strong>语句提供性能优化。因为预编译语句有可能被重复调用，所以<u>语句在被DBServer的编译器编译后的执行代码被缓存下来，那么下次调用时只要是相同的预编译语句就不需要编译，只要将参数直接传入编译过的语句执行代码中就会得到执行。</u></li>
<li>在statement语句中,即使是相同操作但因为数据内容不一样,所以整个语句本身不能匹配,没有缓存语句的意义.事实是没有数据库会对普通语句编译后的执行代码缓存。这样<u>每执行一次都要对传入的语句编译一次。</u></li>
<li>(语法检查，语义检查，翻译成二进制命令，缓存)</li>
</ul>
</li>
<li><p>PreparedStatement 可以防止 SQL 注入 </p>
</li>
</ul>
<h4 id="3-3-3-Java与SQL对应数据类型转换表"><a href="#3-3-3-Java与SQL对应数据类型转换表" class="headerlink" title="3.3.3 Java与SQL对应数据类型转换表"></a>3.3.3 Java与SQL对应数据类型转换表</h4><table>
<thead>
<tr>
<th>Java类型</th>
<th>SQL类型</th>
</tr>
</thead>
<tbody><tr>
<td>boolean</td>
<td>BIT</td>
</tr>
<tr>
<td>byte</td>
<td>TINYINT</td>
</tr>
<tr>
<td>short</td>
<td>SMALLINT</td>
</tr>
<tr>
<td>int</td>
<td>INTEGER</td>
</tr>
<tr>
<td>long</td>
<td>BIGINT</td>
</tr>
<tr>
<td>String</td>
<td>CHAR,VARCHAR,LONGVARCHAR</td>
</tr>
<tr>
<td>byte   array</td>
<td>BINARY  ,    VAR BINARY</td>
</tr>
<tr>
<td>java.sql.Date</td>
<td>DATE</td>
</tr>
<tr>
<td>java.sql.Time</td>
<td>TIME</td>
</tr>
<tr>
<td>java.sql.Timestamp</td>
<td>TIMESTAMP</td>
</tr>
</tbody></table>
<h4 id="3-3-4-使用PreparedStatement实现增、删、改操作"><a href="#3-3-4-使用PreparedStatement实现增、删、改操作" class="headerlink" title="3.3.4 使用PreparedStatement实现增、删、改操作"></a>3.3.4 使用PreparedStatement实现增、删、改操作</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//通用的增、删、改操作（体现一：增、删、改 ； 体现二：针对于不同的表）</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(String sql,Object ... args)</span></span>&#123;</span><br><span class="line">	Connection conn = <span class="keyword">null</span>;</span><br><span class="line">	PreparedStatement ps = <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="comment">//1.获取数据库的连接</span></span><br><span class="line">		conn = JDBCUtils.getConnection();</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//2.获取PreparedStatement的实例 (或：预编译sql语句)</span></span><br><span class="line">		ps = conn.prepareStatement(sql);</span><br><span class="line">		<span class="comment">//3.填充占位符</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; args.length;i++)&#123;</span><br><span class="line">			ps.setObject(i + <span class="number">1</span>, args[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//4.执行sql语句</span></span><br><span class="line">		ps.execute();</span><br><span class="line">	&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">		</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">	&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">		<span class="comment">//5.关闭资源</span></span><br><span class="line">		JDBCUtils.closeResource(conn, ps);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="3-3-5-使用PreparedStatement实现查询操作"><a href="#3-3-5-使用PreparedStatement实现查询操作" class="headerlink" title="3.3.5 使用PreparedStatement实现查询操作"></a>3.3.5 使用PreparedStatement实现查询操作</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通用的针对于不同表的查询:返回一个对象 (version 1.0)</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getInstance</span><span class="params">(Class&lt;T&gt; clazz, String sql, Object... args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	Connection conn = <span class="keyword">null</span>;</span><br><span class="line">	PreparedStatement ps = <span class="keyword">null</span>;</span><br><span class="line">	ResultSet rs = <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="comment">// 1.获取数据库连接</span></span><br><span class="line">		conn = JDBCUtils.getConnection();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 2.预编译sql语句，得到PreparedStatement对象</span></span><br><span class="line">		ps = conn.prepareStatement(sql);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 3.填充占位符</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; args.length; i++) &#123;</span><br><span class="line">			ps.setObject(i + <span class="number">1</span>, args[i]);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 4.执行executeQuery(),得到结果集：ResultSet</span></span><br><span class="line">		rs = ps.executeQuery();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 5.得到结果集的元数据：ResultSetMetaData</span></span><br><span class="line">		ResultSetMetaData rsmd = rs.getMetaData();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 6.1通过ResultSetMetaData得到columnCount,columnLabel；通过ResultSet得到列值</span></span><br><span class="line">		<span class="keyword">int</span> columnCount = rsmd.getColumnCount();</span><br><span class="line">		<span class="keyword">if</span> (rs.next()) &#123;</span><br><span class="line">			T t = clazz.newInstance();</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; columnCount; i++) &#123;<span class="comment">// 遍历每一个列</span></span><br><span class="line"></span><br><span class="line">				<span class="comment">// 获取列值</span></span><br><span class="line">				Object columnVal = rs.getObject(i + <span class="number">1</span>);</span><br><span class="line">				<span class="comment">// 获取列的别名:列的别名，使用类的属性名充当</span></span><br><span class="line">				String columnLabel = rsmd.getColumnLabel(i + <span class="number">1</span>);</span><br><span class="line">				<span class="comment">// 6.2使用反射，给对象的相应属性赋值</span></span><br><span class="line">				Field field = clazz.getDeclaredField(columnLabel);</span><br><span class="line">				field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">				field.set(t, columnVal);</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">return</span> t;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">		e.printStackTrace();</span><br><span class="line">	&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">		<span class="comment">// 7.关闭资源</span></span><br><span class="line">		JDBCUtils.closeResource(conn, ps, rs);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>说明：使用PreparedStatement实现的查询操作可以替换Statement实现的查询操作，解决Statement拼串和SQL注入问题。</p>
</blockquote>
<h3 id="3-4-ResultSet与ResultSetMetaData"><a href="#3-4-ResultSet与ResultSetMetaData" class="headerlink" title="3.4 ResultSet与ResultSetMetaData"></a>3.4 ResultSet与ResultSetMetaData</h3><h4 id="3-4-1-ResultSet"><a href="#3-4-1-ResultSet" class="headerlink" title="3.4.1 ResultSet"></a>3.4.1 ResultSet</h4><ul>
<li><p>查询需要调用PreparedStatement 的 executeQuery() 方法，查询结果是一个ResultSet 对象</p>
</li>
<li><p>ResultSet 对象以逻辑表格的形式封装了执行数据库操作的结果集，ResultSet 接口由数据库厂商提供实现</p>
</li>
<li><p>ResultSet 返回的实际上就是一张数据表。有一个指针指向数据表的第一条记录的前面。</p>
</li>
<li><p>ResultSet 对象维护了一个指向当前数据行的<strong>游标</strong>，初始的时候，游标在第一行之前，可以通过 ResultSet 对象的 next() 方法移动到下一行。调用 next()方法检测下一行是否有效。若有效，该方法返回 true，且指针下移。相当于Iterator对象的 hasNext() 和 next() 方法的结合体。</p>
</li>
<li><p>当指针指向一行时, 可以通过调用 getXxx(int index) 或 getXxx(int columnName) 获取每一列的值。</p>
<ul>
<li>例如: getInt(1), getString(“name”)</li>
<li><strong>注意：Java与数据库交互涉及到的相关Java API中的索引都从1开始。</strong></li>
</ul>
</li>
<li><p>ResultSet 接口的常用方法：</p>
<ul>
<li><p>boolean next()</p>
</li>
<li><p>getString()</p>
</li>
<li><p>…</p>
</li>
</ul>
<p><img src="https://gitee.com/zlpxiaokeai/img/raw/master/img/1555580152530.png" alt="1555580152530"></p>
</li>
</ul>
<h4 id="3-4-2-ResultSetMetaData"><a href="#3-4-2-ResultSetMetaData" class="headerlink" title="3.4.2 ResultSetMetaData"></a>3.4.2 ResultSetMetaData</h4><ul>
<li><p>可用于获取关于 ResultSet 对象中列的类型和属性信息的对象</p>
</li>
<li><p>ResultSetMetaData meta = rs.getMetaData();</p>
<ul>
<li><p><strong>getColumnName</strong>(int column)：获取指定列的名称</p>
</li>
<li><p><strong>getColumnLabel</strong>(int column)：获取指定列的别名</p>
</li>
<li><p><strong>getColumnCount</strong>()：返回当前 ResultSet 对象中的列数。 </p>
</li>
<li><p>getColumnTypeName(int column)：检索指定列的数据库特定的类型名称。 </p>
</li>
<li><p>getColumnDisplaySize(int column)：指示指定列的最大标准宽度，以字符为单位。 </p>
</li>
<li><p><strong>isNullable</strong>(int column)：指示指定列中的值是否可以为 null。 </p>
</li>
<li><p> isAutoIncrement(int column)：指示是否自动为指定列进行编号，这样这些列仍然是只读的。 </p>
</li>
</ul>
</li>
</ul>
<p><img src="https://gitee.com/zlpxiaokeai/img/raw/master/img/1555579494691.png" alt="1555579494691"></p>
<p><strong>问题1：得到结果集后, 如何知道该结果集中有哪些列 ？ 列名是什么？</strong></p>
<p>​     需要使用一个描述 ResultSet 的对象， 即 ResultSetMetaData</p>
<p><strong>问题2：关于ResultSetMetaData</strong></p>
<ol>
<li><strong>如何获取 ResultSetMetaData</strong>： 调用 ResultSet 的 getMetaData() 方法即可</li>
<li><strong>获取 ResultSet 中有多少列</strong>：调用 ResultSetMetaData 的 getColumnCount() 方法</li>
<li><strong>获取 ResultSet 每一列的列的别名是什么</strong>：调用 ResultSetMetaData 的getColumnLabel() 方法</li>
</ol>
<p><img src="https://gitee.com/zlpxiaokeai/img/raw/master/img/1555579816884.png" alt="1555579816884"></p>
<h3 id="3-5-资源的释放"><a href="#3-5-资源的释放" class="headerlink" title="3.5 资源的释放"></a>3.5 资源的释放</h3><ul>
<li>释放ResultSet, Statement,Connection。</li>
<li>数据库连接（Connection）是非常稀有的资源，用完后必须马上释放，如果Connection不能及时正确的关闭将导致系统宕机。Connection的使用原则是<strong>尽量晚创建，尽量早的释放。</strong></li>
<li>可以在finally中关闭，保证及时其他代码出现异常，资源也一定能被关闭。</li>
</ul>
<h3 id="3-6-JDBC-API小结"><a href="#3-6-JDBC-API小结" class="headerlink" title="3.6 JDBC API小结"></a>3.6 JDBC API小结</h3><ul>
<li><p>两种思想</p>
<ul>
<li><p>面向接口编程的思想</p>
</li>
<li><p>ORM思想(object relational mapping)</p>
<ul>
<li>一个数据表对应一个java类</li>
<li>表中的一条记录对应java类的一个对象</li>
<li>表中的一个字段对应java类的一个属性</li>
</ul>
</li>
</ul>
<blockquote>
<p>sql是需要结合列名和表的属性名来写。注意起别名。</p>
</blockquote>
</li>
<li><p>两种技术</p>
<ul>
<li>JDBC结果集的元数据：ResultSetMetaData<ul>
<li>获取列数：getColumnCount()</li>
<li>获取列的别名：getColumnLabel()</li>
</ul>
</li>
<li>通过反射，创建指定类的对象，获取指定的属性并赋值</li>
</ul>
</li>
</ul>
<hr>
<h2 id="章节练习"><a href="#章节练习" class="headerlink" title="章节练习"></a>章节练习</h2><p><strong>练习题1：从控制台向数据库的表customers中插入一条数据，表结构如下：</strong></p>
<p><img src="https://gitee.com/zlpxiaokeai/img/raw/master/img/1555580275036.png" alt="1555580275036"></p>
<p><strong>练习题2：创立数据库表 examstudent，表结构如下：</strong></p>
<p><img src="https://gitee.com/zlpxiaokeai/img/raw/master/img/1555580735377.png" alt="1555580735377"></p>
<p>向数据表中添加如下数据：</p>
<p><img src="https://gitee.com/zlpxiaokeai/img/raw/master/img/1555580763636.png" alt="1555580763636"></p>
<p><strong>代码实现1：插入一个新的student 信息</strong></p>
<p>请输入考生的详细信息</p>
<p>Type:<br>IDCard:<br>ExamCard:<br>StudentName:<br>Location:<br>Grade:</p>
<p>信息录入成功!</p>
<p><strong>代码实现2：在 IDEA中建立 java 程序：输入身份证号或准考证号可以查询到学生的基本信息。结果如下：</strong></p>
<p><img src="https://gitee.com/zlpxiaokeai/img/raw/master/img/1555580937490.png" alt="1555580937490"></p>
<p><strong>代码实现3：完成学生信息的删除功能</strong></p>
<p><img src="/2021/11/22/%E5%B0%9A%E7%A1%85%E8%B0%B7_%E5%AE%8B%E7%BA%A2%E5%BA%B7_JDBC/1555580965019.png" alt="1555580965019"></p>
<hr>
<h2 id="第4章-操作BLOB类型字段-选学"><a href="#第4章-操作BLOB类型字段-选学" class="headerlink" title="第4章 操作BLOB类型字段(选学)"></a>第4章 操作BLOB类型字段(选学)</h2><h3 id="4-1-MySQL-BLOB类型"><a href="#4-1-MySQL-BLOB类型" class="headerlink" title="4.1 MySQL BLOB类型"></a>4.1 MySQL BLOB类型</h3><ul>
<li><p>MySQL中，BLOB是一个二进制大型对象，是一个可以存储大量数据的容器，它能容纳不同大小的数据。</p>
</li>
<li><p>插入BLOB类型的数据必须使用PreparedStatement，因为BLOB类型的数据无法使用字符串拼接写的。</p>
</li>
<li><p>MySQL的四种BLOB类型(除了在存储的最大信息量上不同外，他们是等同的)</p>
</li>
</ul>
<p><img src="https://gitee.com/zlpxiaokeai/img/raw/master/img/1555581069798.png" alt="1555581069798"></p>
<ul>
<li>实际使用中根据需要存入的数据大小定义不同的BLOB类型。</li>
<li>需要注意的是：如果存储的文件过大，数据库的性能会下降。</li>
<li>如果在指定了相关的Blob类型以后，还报错：xxx too large，那么在mysql的安装目录下，找my.ini文件加上如下的配置参数： <strong>max_allowed_packet=16M</strong>。同时注意：修改了my.ini文件之后，需要重新启动mysql服务。</li>
</ul>
<h3 id="4-2-向数据表中插入大数据类型"><a href="#4-2-向数据表中插入大数据类型" class="headerlink" title="4.2 向数据表中插入大数据类型"></a>4.2 向数据表中插入大数据类型</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取连接</span></span><br><span class="line">Connection conn = JDBCUtils.getConnection();</span><br><span class="line">		</span><br><span class="line">String sql = <span class="string">&quot;insert into customers(name,email,birth,photo)values(?,?,?,?)&quot;</span>;</span><br><span class="line">PreparedStatement ps = conn.prepareStatement(sql);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 填充占位符</span></span><br><span class="line">ps.setString(<span class="number">1</span>, <span class="string">&quot;徐海强&quot;</span>);</span><br><span class="line">ps.setString(<span class="number">2</span>, <span class="string">&quot;xhq@126.com&quot;</span>);</span><br><span class="line">ps.setDate(<span class="number">3</span>, <span class="keyword">new</span> Date(<span class="keyword">new</span> java.util.Date().getTime()));</span><br><span class="line"><span class="comment">// 操作Blob类型的变量</span></span><br><span class="line">FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;xhq.png&quot;</span>);</span><br><span class="line">ps.setBlob(<span class="number">4</span>, fis);</span><br><span class="line"><span class="comment">//执行</span></span><br><span class="line">ps.execute();</span><br><span class="line">		</span><br><span class="line">fis.close();</span><br><span class="line">JDBCUtils.closeResource(conn, ps);</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="4-3-修改数据表中的Blob类型字段"><a href="#4-3-修改数据表中的Blob类型字段" class="headerlink" title="4.3 修改数据表中的Blob类型字段"></a>4.3 修改数据表中的Blob类型字段</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Connection conn = JDBCUtils.getConnection();</span><br><span class="line">String sql = <span class="string">&quot;update customers set photo = ? where id = ?&quot;</span>;</span><br><span class="line">PreparedStatement ps = conn.prepareStatement(sql);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 填充占位符</span></span><br><span class="line"><span class="comment">// 操作Blob类型的变量</span></span><br><span class="line">FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;coffee.png&quot;</span>);</span><br><span class="line">ps.setBlob(<span class="number">1</span>, fis);</span><br><span class="line">ps.setInt(<span class="number">2</span>, <span class="number">25</span>);</span><br><span class="line"></span><br><span class="line">ps.execute();</span><br><span class="line"></span><br><span class="line">fis.close();</span><br><span class="line">JDBCUtils.closeResource(conn, ps);</span><br></pre></td></tr></table></figure>



<h3 id="4-4-从数据表中读取大数据类型"><a href="#4-4-从数据表中读取大数据类型" class="headerlink" title="4.4 从数据表中读取大数据类型"></a>4.4 从数据表中读取大数据类型</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String sql = <span class="string">&quot;SELECT id, name, email, birth, photo FROM customer WHERE id = ?&quot;</span>;</span><br><span class="line">conn = getConnection();</span><br><span class="line">ps = conn.prepareStatement(sql);</span><br><span class="line">ps.setInt(<span class="number">1</span>, <span class="number">8</span>);</span><br><span class="line">rs = ps.executeQuery();</span><br><span class="line"><span class="keyword">if</span>(rs.next())&#123;</span><br><span class="line">	Integer id = rs.getInt(<span class="number">1</span>);</span><br><span class="line">    String name = rs.getString(<span class="number">2</span>);</span><br><span class="line">	String email = rs.getString(<span class="number">3</span>);</span><br><span class="line">    Date birth = rs.getDate(<span class="number">4</span>);</span><br><span class="line">	Customer cust = <span class="keyword">new</span> Customer(id, name, email, birth);</span><br><span class="line">    System.out.println(cust); </span><br><span class="line">    <span class="comment">//读取Blob类型的字段</span></span><br><span class="line">	Blob photo = rs.getBlob(<span class="number">5</span>);</span><br><span class="line">	InputStream is = photo.getBinaryStream();</span><br><span class="line">	OutputStream os = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;c.jpg&quot;</span>);</span><br><span class="line">	<span class="keyword">byte</span> [] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">	<span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>((len = is.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">		os.write(buffer, <span class="number">0</span>, len);</span><br><span class="line">	&#125;</span><br><span class="line">    JDBCUtils.closeResource(conn, ps, rs);</span><br><span class="line">		</span><br><span class="line">	<span class="keyword">if</span>(is != <span class="keyword">null</span>)&#123;</span><br><span class="line">		is.close();</span><br><span class="line">	&#125;</span><br><span class="line">		</span><br><span class="line">	<span class="keyword">if</span>(os !=  <span class="keyword">null</span>)&#123;</span><br><span class="line">		os.close();</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="第5章-批量插入-选学"><a href="#第5章-批量插入-选学" class="headerlink" title="第5章 批量插入(选学)"></a>第5章 批量插入(选学)</h2><h3 id="5-1-批量执行SQL语句"><a href="#5-1-批量执行SQL语句" class="headerlink" title="5.1 批量执行SQL语句"></a>5.1 批量执行SQL语句</h3><p>当需要成批插入或者更新记录时，可以采用Java的批量<strong>更新</strong>机制，这一机制允许多条语句一次性提交给数据库批量处理。通常情况下比单独提交处理更有效率</p>
<p>JDBC的批量处理语句包括下面三个方法：</p>
<ul>
<li><strong>addBatch(String)：添加需要批量处理的SQL语句或是参数；</strong></li>
<li><strong>executeBatch()：执行批量处理语句；</strong></li>
<li><strong>clearBatch():清空缓存的数据</strong></li>
</ul>
<p>通常我们会遇到两种批量执行SQL语句的情况：</p>
<ul>
<li>多条SQL语句的批量处理；</li>
<li>一个SQL语句的批量传参；</li>
</ul>
<h3 id="5-2-高效的批量插入"><a href="#5-2-高效的批量插入" class="headerlink" title="5.2 高效的批量插入"></a>5.2 高效的批量插入</h3><p>举例：向数据表中插入20000条数据</p>
<ul>
<li>数据库中提供一个goods表。创建如下：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> goods(</span><br><span class="line">id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY AUTO_INCREMENT,</span><br><span class="line">NAME <span class="type">VARCHAR</span>(<span class="number">20</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>



<h4 id="5-2-1-实现层次一：使用Statement"><a href="#5-2-1-实现层次一：使用Statement" class="headerlink" title="5.2.1 实现层次一：使用Statement"></a>5.2.1 实现层次一：使用Statement</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Connection conn = JDBCUtils.getConnection();</span><br><span class="line">Statement st = conn.createStatement();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">20000</span>;i++)&#123;</span><br><span class="line">	String sql = <span class="string">&quot;insert into goods(name) values(&#x27;name_&#x27; + &quot;</span>+ i +<span class="string">&quot;)&quot;</span>;</span><br><span class="line">	st.executeUpdate(sql);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="5-2-2-实现层次二：使用PreparedStatement"><a href="#5-2-2-实现层次二：使用PreparedStatement" class="headerlink" title="5.2.2 实现层次二：使用PreparedStatement"></a>5.2.2 实现层次二：使用PreparedStatement</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">		</span><br><span class="line">Connection conn = JDBCUtils.getConnection();</span><br><span class="line">		</span><br><span class="line">String sql = <span class="string">&quot;insert into goods(name)values(?)&quot;</span>;</span><br><span class="line">PreparedStatement ps = conn.prepareStatement(sql);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">20000</span>;i++)&#123;</span><br><span class="line">	ps.setString(<span class="number">1</span>, <span class="string">&quot;name_&quot;</span> + i);</span><br><span class="line">	ps.executeUpdate();</span><br><span class="line">&#125;</span><br><span class="line">		</span><br><span class="line"><span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">System.out.println(<span class="string">&quot;花费的时间为：&quot;</span> + (end - start));<span class="comment">//82340</span></span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">JDBCUtils.closeResource(conn, ps);</span><br></pre></td></tr></table></figure>

<h4 id="5-2-3-实现层次三"><a href="#5-2-3-实现层次三" class="headerlink" title="5.2.3 实现层次三"></a>5.2.3 实现层次三</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 修改1： 使用 addBatch() / executeBatch() / clearBatch()</span></span><br><span class="line"><span class="comment"> * 修改2：mysql服务器默认是关闭批处理的，我们需要通过一个参数，让mysql开启批处理的支持。</span></span><br><span class="line"><span class="comment"> * 		 ?rewriteBatchedStatements=true 写在配置文件的url后面</span></span><br><span class="line"><span class="comment"> * 修改3：使用更新的mysql 驱动：mysql-connector-java-5.1.37-bin.jar</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testInsert1</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">	<span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">		</span><br><span class="line">	Connection conn = JDBCUtils.getConnection();</span><br><span class="line">		</span><br><span class="line">	String sql = <span class="string">&quot;insert into goods(name)values(?)&quot;</span>;</span><br><span class="line">	PreparedStatement ps = conn.prepareStatement(sql);</span><br><span class="line">		</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">1000000</span>;i++)&#123;</span><br><span class="line">		ps.setString(<span class="number">1</span>, <span class="string">&quot;name_&quot;</span> + i);</span><br><span class="line">			</span><br><span class="line">		<span class="comment">//1.“攒”sql</span></span><br><span class="line">		ps.addBatch();</span><br><span class="line">		<span class="keyword">if</span>(i % <span class="number">500</span> == <span class="number">0</span>)&#123;</span><br><span class="line">			<span class="comment">//2.执行</span></span><br><span class="line">			ps.executeBatch();</span><br><span class="line">			<span class="comment">//3.清空</span></span><br><span class="line">			ps.clearBatch();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">		</span><br><span class="line">	<span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">	System.out.println(<span class="string">&quot;花费的时间为：&quot;</span> + (end - start));<span class="comment">//20000条：625                                                                         //1000000条:14733  </span></span><br><span class="line">		</span><br><span class="line">	JDBCUtils.closeResource(conn, ps);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-2-4-实现层次四"><a href="#5-2-4-实现层次四" class="headerlink" title="5.2.4 实现层次四"></a>5.2.4 实现层次四</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 层次四：在层次三的基础上操作</span></span><br><span class="line"><span class="comment">* 使用Connection 的 setAutoCommit(false)  /  commit()</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testInsert2</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">	<span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">		</span><br><span class="line">	Connection conn = JDBCUtils.getConnection();</span><br><span class="line">		</span><br><span class="line">	<span class="comment">//1.设置为不自动提交数据</span></span><br><span class="line">	conn.setAutoCommit(<span class="keyword">false</span>);</span><br><span class="line">		</span><br><span class="line">	String sql = <span class="string">&quot;insert into goods(name)values(?)&quot;</span>;</span><br><span class="line">	PreparedStatement ps = conn.prepareStatement(sql);</span><br><span class="line">		</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">1000000</span>;i++)&#123;</span><br><span class="line">		ps.setString(<span class="number">1</span>, <span class="string">&quot;name_&quot;</span> + i);</span><br><span class="line">			</span><br><span class="line">		<span class="comment">//1.“攒”sql</span></span><br><span class="line">		ps.addBatch();</span><br><span class="line">			</span><br><span class="line">		<span class="keyword">if</span>(i % <span class="number">500</span> == <span class="number">0</span>)&#123;</span><br><span class="line">			<span class="comment">//2.执行</span></span><br><span class="line">			ps.executeBatch();</span><br><span class="line">			<span class="comment">//3.清空</span></span><br><span class="line">			ps.clearBatch();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">		</span><br><span class="line">	<span class="comment">//2.提交数据</span></span><br><span class="line">	conn.commit();</span><br><span class="line">		</span><br><span class="line">	<span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">	System.out.println(<span class="string">&quot;花费的时间为：&quot;</span> + (end - start));<span class="comment">//1000000条:4978 </span></span><br><span class="line">		</span><br><span class="line">	JDBCUtils.closeResource(conn, ps);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="第6章：-数据库事务"><a href="#第6章：-数据库事务" class="headerlink" title="第6章： 数据库事务"></a>第6章： 数据库事务</h2><h3 id="6-1-数据库事务介绍"><a href="#6-1-数据库事务介绍" class="headerlink" title="6.1 数据库事务介绍"></a>6.1 数据库事务介绍</h3><ul>
<li><p><strong>事务：一组逻辑操作单元,使数据从一种状态变换到另一种状态。</strong></p>
</li>
<li><p><strong>事务处理（事务操作）：</strong>保证所有事务都作为一个工作单元来执行，即使出现了故障，都不能改变这种执行方式。当在一个事务中执行多个操作时，要么所有的事务都**被提交(commit)<strong>，那么这些修改就永久地保存下来；要么数据库管理系统将放弃所作的所有修改，整个事务</strong>回滚(rollback)**到最初状态。</p>
</li>
<li><p>为确保数据库中数据的<strong>一致性</strong>，数据的操纵应当是离散的成组的逻辑单元：当它全部完成时，数据的一致性可以保持，而当这个单元中的一部分操作失败，整个事务应全部视为错误，所有从起始点以后的操作应全部回退到开始状态。 </p>
</li>
</ul>
<h3 id="6-2-JDBC事务处理"><a href="#6-2-JDBC事务处理" class="headerlink" title="6.2 JDBC事务处理"></a>6.2 JDBC事务处理</h3><ul>
<li><p>数据一旦提交，就不可回滚。</p>
</li>
<li><p>数据什么时候意味着提交？</p>
<ul>
<li><strong>当一个连接对象被创建时，默认情况下是自动提交事务</strong>：每次执行一个 SQL 语句时，如果执行成功，就会向数据库自动提交，而不能回滚。</li>
<li><strong>关闭数据库连接，数据就会自动的提交。</strong>如果多个操作，每个操作使用的是自己单独的连接，则无法保证事务。即同一个事务的多个操作必须在同一个连接下。</li>
</ul>
</li>
<li><p><strong>JDBC程序中为了让多个 SQL 语句作为一个事务执行：</strong></p>
<ul>
<li>调用 Connection 对象的 <strong>setAutoCommit(false);</strong> 以取消自动提交事务</li>
<li>在所有的 SQL 语句都成功执行后，调用 <strong>commit();</strong> 方法提交事务</li>
<li>在出现异常时，调用 <strong>rollback();</strong> 方法回滚事务</li>
</ul>
<blockquote>
<p>若此时 Connection 没有被关闭，还可能被重复使用，则需要恢复其自动提交状态 setAutoCommit(true)。尤其是在使用数据库连接池技术时，执行close()方法前，建议恢复自动提交状态。</p>
</blockquote>
</li>
</ul>
<p>【案例：用户AA向用户BB转账100】</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testJDBCTransaction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Connection conn = <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="comment">// 1.获取数据库连接</span></span><br><span class="line">		conn = JDBCUtils.getConnection();</span><br><span class="line">		<span class="comment">// 2.开启事务</span></span><br><span class="line">		conn.setAutoCommit(<span class="keyword">false</span>);</span><br><span class="line">		<span class="comment">// 3.进行数据库操作</span></span><br><span class="line">		String sql1 = <span class="string">&quot;update user_table set balance = balance - 100 where user = ?&quot;</span>;</span><br><span class="line">		update(conn, sql1, <span class="string">&quot;AA&quot;</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 模拟网络异常</span></span><br><span class="line">		<span class="comment">//System.out.println(10 / 0);</span></span><br><span class="line"></span><br><span class="line">		String sql2 = <span class="string">&quot;update user_table set balance = balance + 100 where user = ?&quot;</span>;</span><br><span class="line">		update(conn, sql2, <span class="string">&quot;BB&quot;</span>);</span><br><span class="line">		<span class="comment">// 4.若没有异常，则提交事务</span></span><br><span class="line">		conn.commit();</span><br><span class="line">	&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">		<span class="comment">// 5.若有异常，则回滚事务</span></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			conn.rollback();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (SQLException e1) &#123;</span><br><span class="line">			e1.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">//6.恢复每次DML操作的自动提交功能</span></span><br><span class="line">			conn.setAutoCommit(<span class="keyword">true</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">//7.关闭连接</span></span><br><span class="line">		JDBCUtils.closeResource(conn, <span class="keyword">null</span>, <span class="keyword">null</span>); </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>其中，对数据库操作的方法为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用事务以后的通用的增删改操作（version 2.0）</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Connection conn ,String sql, Object... args)</span> </span>&#123;</span><br><span class="line">	PreparedStatement ps = <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="comment">// 1.获取PreparedStatement的实例 (或：预编译sql语句)</span></span><br><span class="line">		ps = conn.prepareStatement(sql);</span><br><span class="line">		<span class="comment">// 2.填充占位符</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; args.length; i++) &#123;</span><br><span class="line">			ps.setObject(i + <span class="number">1</span>, args[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 3.执行sql语句</span></span><br><span class="line">		ps.execute();</span><br><span class="line">	&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">	&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">		<span class="comment">// 4.关闭资源</span></span><br><span class="line">		JDBCUtils.closeResource(<span class="keyword">null</span>, ps);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="6-3-事务的ACID属性"><a href="#6-3-事务的ACID属性" class="headerlink" title="6.3 事务的ACID属性"></a>6.3 事务的ACID属性</h3><ol>
<li><p><strong>原子性（Atomicity）</strong><br> 原子性是指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。 </p>
</li>
<li><p><strong>一致性（Consistency）</strong><br> 事务必须使数据库从一个一致性状态变换到另外一个一致性状态。</p>
</li>
<li><p><strong>隔离性（Isolation）</strong><br> 事务的隔离性是指一个事务的执行不能被其他事务干扰，即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。</p>
</li>
<li><p><strong>持久性（Durability）</strong><br> 持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来的其他操作和数据库故障不应该对其有任何影响。</p>
</li>
</ol>
<h4 id="6-3-1-数据库的并发问题"><a href="#6-3-1-数据库的并发问题" class="headerlink" title="6.3.1 数据库的并发问题"></a>6.3.1 数据库的并发问题</h4><ul>
<li>对于同时运行的多个事务, 当这些事务访问数据库中相同的数据时, 如果没有采取必要的隔离机制, 就会导致各种并发问题:<ul>
<li><strong>脏读</strong>: 对于两个事务 T1, T2, T1 读取了已经被 T2 更新但还<strong>没有被提交</strong>的字段。之后, 若 T2 回滚, T1读取的内容就是临时且无效的。</li>
<li><strong>不可重复读</strong>: 对于两个事务T1, T2, T1 读取了一个字段, 然后 T2 <strong>更新</strong>了该字段。之后, T1再次读取同一个字段, 值就不同了。</li>
<li><strong>幻读</strong>: 对于两个事务T1, T2, T1 从一个表中读取了一个字段, 然后 T2 在该表中<strong>插入</strong>了一些新的行。之后, 如果 T1 再次读取同一个表, 就会多出几行。</li>
</ul>
</li>
<li><strong>数据库事务的隔离性</strong>: 数据库系统必须具有隔离并发运行各个事务的能力, 使它们不会相互影响, 避免各种并发问题。</li>
<li>说明：不可重复读的和幻读很容易混淆，不可重复读侧重于修改，幻读侧重于新增或删除。解决不可重复读的问题只需锁住满足条件的行，解决幻读需要锁表</li>
<li>一个事务与其他事务隔离的程度称为隔离级别。数据库规定了多种事务隔离级别, 不同隔离级别对应不同的干扰程度, <strong>隔离级别越高, 数据一致性就越好, 但并发性越弱。</strong></li>
</ul>
<h4 id="6-3-2-四种隔离级别"><a href="#6-3-2-四种隔离级别" class="headerlink" title="6.3.2 四种隔离级别"></a>6.3.2 四种隔离级别</h4><ul>
<li><p>数据库提供的4种事务隔离级别：</p>
<p><img src="https://gitee.com/zlpxiaokeai/img/raw/master/img/1555586275271.png" alt="1555586275271"></p>
<ul>
<li>表格从上至下，一致性越来越好，但是并发性越来越差。</li>
</ul>
</li>
<li><p>Oracle 支持的 2 种事务隔离级别：<strong>READ COMMITED</strong>, SERIALIZABLE。 Oracle 默认的事务隔离级别为: <strong>READ COMMITED</strong> 。</p>
</li>
</ul>
<ul>
<li>Mysql 支持 4 种事务隔离级别。Mysql 默认的事务隔离级别为: <strong>REPEATABLE READ。</strong></li>
</ul>
<h4 id="6-3-3-在MySql中设置隔离级别"><a href="#6-3-3-在MySql中设置隔离级别" class="headerlink" title="6.3.3 在MySql中设置隔离级别"></a>6.3.3 在MySql中设置隔离级别</h4><ul>
<li><p>每启动一个 mysql 程序, 就会获得一个单独的数据库连接. 每个数据库连接都有一个全局变量 @@tx_isolation, 表示当前的事务隔离级别。</p>
</li>
<li><p>查看当前的隔离级别: </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT @@tx_isolation;</span><br></pre></td></tr></table></figure></li>
<li><p>设置当前 mySQL 连接的隔离级别:  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set  transaction isolation level read committed;</span><br></pre></td></tr></table></figure></li>
<li><p>设置数据库系统的全局的隔离级别:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set global transaction isolation level read committed;</span><br></pre></td></tr></table></figure></li>
<li><p>补充操作：</p>
<ul>
<li><p>创建mysql数据库用户：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create user tom identified by &#x27;abc123&#x27;;</span><br></pre></td></tr></table></figure></li>
<li><p>授予权限</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#授予通过网络方式登录的tom用户，对所有库所有表的全部权限，密码设为abc123.</span><br><span class="line">grant all privileges on *.* to tom@&#x27;%&#x27;  identified by &#x27;abc123&#x27;; </span><br><span class="line"></span><br><span class="line"> #给tom用户使用本地命令行方式，授予atguigudb这个库下的所有表的插删改查的权限。</span><br><span class="line">grant select,insert,delete,update on atguigudb.* to tom@localhost identified by &#x27;abc123&#x27;; </span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="第7章：DAO及相关实现类"><a href="#第7章：DAO及相关实现类" class="headerlink" title="第7章：DAO及相关实现类"></a>第7章：DAO及相关实现类</h2><ul>
<li>DAO：Data Access Object访问数据信息的类和接口，包括了对数据的CRUD（Create、Retrival、Update、Delete），而不包含任何业务相关的信息。有时也称作：BaseDAO</li>
<li>作用：为了实现功能的模块化，更有利于代码的维护和升级。</li>
<li>下面是尚硅谷JavaWeb阶段书城项目中DAO使用的体现：</li>
</ul>
<p><img src="https://gitee.com/zlpxiaokeai/img/raw/master/img/1566726681515.png" alt="1566726681515"></p>
<ul>
<li>层次结构：</li>
</ul>
<p><img src="https://gitee.com/zlpxiaokeai/img/raw/master/img/1566745811244.png" alt="1566745811244"></p>
<h3 id="【BaseDAO-java】"><a href="#【BaseDAO-java】" class="headerlink" title="【BaseDAO.java】"></a>【BaseDAO.java】</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.bookstore.dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.ParameterizedType;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Type;</span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.dbutils.QueryRunner;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.dbutils.handlers.BeanHandler;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.dbutils.handlers.BeanListHandler;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.dbutils.handlers.ScalarHandler;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定义一个用来被继承的对数据库进行基本操作的Dao</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> HanYanBing</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseDao</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> QueryRunner queryRunner = <span class="keyword">new</span> QueryRunner();</span><br><span class="line">	<span class="comment">// 定义一个变量来接收泛型的类型</span></span><br><span class="line">	<span class="keyword">private</span> Class&lt;T&gt; type;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取T的Class对象，获取泛型的类型，泛型是在被子类继承时才确定</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">BaseDao</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 获取子类的类型</span></span><br><span class="line">		Class clazz = <span class="keyword">this</span>.getClass();</span><br><span class="line">		<span class="comment">// 获取父类的类型</span></span><br><span class="line">		<span class="comment">// getGenericSuperclass()用来获取当前类的父类的类型</span></span><br><span class="line">		<span class="comment">// ParameterizedType表示的是带泛型的类型</span></span><br><span class="line">		ParameterizedType parameterizedType = (ParameterizedType) clazz.getGenericSuperclass();</span><br><span class="line">		<span class="comment">// 获取具体的泛型类型 getActualTypeArguments获取具体的泛型的类型</span></span><br><span class="line">		<span class="comment">// 这个方法会返回一个Type的数组</span></span><br><span class="line">		Type[] types = parameterizedType.getActualTypeArguments();</span><br><span class="line">		<span class="comment">// 获取具体的泛型的类型·</span></span><br><span class="line">		<span class="keyword">this</span>.type = (Class&lt;T&gt;) types[<span class="number">0</span>];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 通用的增删改操作</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> sql</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> params</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">update</span><span class="params">(Connection conn,String sql, Object... params)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			count = queryRunner.update(conn, sql, params);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; </span><br><span class="line">		<span class="keyword">return</span> count;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 获取一个对象</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> sql</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> params</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> T <span class="title">getBean</span><span class="params">(Connection conn,String sql, Object... params)</span> </span>&#123;</span><br><span class="line">		T t = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			t = queryRunner.query(conn, sql, <span class="keyword">new</span> BeanHandler&lt;T&gt;(type), params);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; </span><br><span class="line">		<span class="keyword">return</span> t;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 获取所有对象</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> sql</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> params</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> List&lt;T&gt; <span class="title">getBeanList</span><span class="params">(Connection conn,String sql, Object... params)</span> </span>&#123;</span><br><span class="line">		List&lt;T&gt; list = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			list = queryRunner.query(conn, sql, <span class="keyword">new</span> BeanListHandler&lt;T&gt;(type), params);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; </span><br><span class="line">		<span class="keyword">return</span> list;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 获取一个但一值得方法，专门用来执行像 select count(*)...这样的sql语句</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> sql</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> params</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">getValue</span><span class="params">(Connection conn,String sql, Object... params)</span> </span>&#123;</span><br><span class="line">		Object count = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">// 调用queryRunner的query方法获取一个单一的值</span></span><br><span class="line">			count = queryRunner.query(conn, sql, <span class="keyword">new</span> ScalarHandler&lt;&gt;(), params);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; </span><br><span class="line">		<span class="keyword">return</span> count;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="【BookDAO-java】"><a href="#【BookDAO-java】" class="headerlink" title="【BookDAO.java】"></a>【BookDAO.java】</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.bookstore.dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.atguigu.bookstore.beans.Book;</span><br><span class="line"><span class="keyword">import</span> com.atguigu.bookstore.beans.Page;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BookDao</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 从数据库中查询出所有的记录</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function">List&lt;Book&gt; <span class="title">getBooks</span><span class="params">(Connection conn)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 向数据库中插入一条记录</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> book</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">saveBook</span><span class="params">(Connection conn,Book book)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 从数据库中根据图书的id删除一条记录</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> bookId</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">deleteBookById</span><span class="params">(Connection conn,String bookId)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 根据图书的id从数据库中查询出一条记录</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> bookId</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function">Book <span class="title">getBookById</span><span class="params">(Connection conn,String bookId)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 根据图书的id从数据库中更新一条记录</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> book</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">updateBook</span><span class="params">(Connection conn,Book book)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 获取带分页的图书信息</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> page：是只包含了用户输入的pageNo属性的page对象</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> 返回的Page对象是包含了所有属性的Page对象</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function">Page&lt;Book&gt; <span class="title">getPageBooks</span><span class="params">(Connection conn,Page&lt;Book&gt; page)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 获取带分页和价格范围的图书信息</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> page：是只包含了用户输入的pageNo属性的page对象</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> 返回的Page对象是包含了所有属性的Page对象</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function">Page&lt;Book&gt; <span class="title">getPageBooksByPrice</span><span class="params">(Connection conn,Page&lt;Book&gt; page, <span class="keyword">double</span> minPrice, <span class="keyword">double</span> maxPrice)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="【UserDAO-java】"><a href="#【UserDAO-java】" class="headerlink" title="【UserDAO.java】"></a>【UserDAO.java】</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.bookstore.dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.atguigu.bookstore.beans.User;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 根据User对象中的用户名和密码从数据库中获取一条记录</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> user</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> User 数据库中有记录 null 数据库中无此记录</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function">User <span class="title">getUser</span><span class="params">(Connection conn,User user)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 根据User对象中的用户名从数据库中获取一条记录</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> user</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> true 数据库中有记录 false 数据库中无此记录</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">checkUsername</span><span class="params">(Connection conn,User user)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 向数据库中插入User对象</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> user</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">saveUser</span><span class="params">(Connection conn,User user)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="【BookDaoImpl-java】"><a href="#【BookDaoImpl-java】" class="headerlink" title="【BookDaoImpl.java】"></a>【BookDaoImpl.java】</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.bookstore.dao.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.atguigu.bookstore.beans.Book;</span><br><span class="line"><span class="keyword">import</span> com.atguigu.bookstore.beans.Page;</span><br><span class="line"><span class="keyword">import</span> com.atguigu.bookstore.dao.BaseDao;</span><br><span class="line"><span class="keyword">import</span> com.atguigu.bookstore.dao.BookDao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookDaoImpl</span> <span class="keyword">extends</span> <span class="title">BaseDao</span>&lt;<span class="title">Book</span>&gt; <span class="keyword">implements</span> <span class="title">BookDao</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> List&lt;Book&gt; <span class="title">getBooks</span><span class="params">(Connection conn)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 调用BaseDao中得到一个List的方法</span></span><br><span class="line">		List&lt;Book&gt; beanList = <span class="keyword">null</span>;</span><br><span class="line">		<span class="comment">// 写sql语句</span></span><br><span class="line">		String sql = <span class="string">&quot;select id,title,author,price,sales,stock,img_path imgPath from books&quot;</span>;</span><br><span class="line">		beanList = getBeanList(conn,sql);</span><br><span class="line">		<span class="keyword">return</span> beanList;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveBook</span><span class="params">(Connection conn,Book book)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 写sql语句</span></span><br><span class="line">		String sql = <span class="string">&quot;insert into books(title,author,price,sales,stock,img_path) values(?,?,?,?,?,?)&quot;</span>;</span><br><span class="line">		<span class="comment">// 调用BaseDao中通用的增删改的方法</span></span><br><span class="line">		update(conn,sql, book.getTitle(), book.getAuthor(), book.getPrice(), book.getSales(), book.getStock(),book.getImgPath());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteBookById</span><span class="params">(Connection conn,String bookId)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 写sql语句</span></span><br><span class="line">		String sql = <span class="string">&quot;DELETE FROM books WHERE id = ?&quot;</span>;</span><br><span class="line">		<span class="comment">// 调用BaseDao中通用增删改的方法</span></span><br><span class="line">		update(conn,sql, bookId);</span><br><span class="line">			</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Book <span class="title">getBookById</span><span class="params">(Connection conn,String bookId)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 调用BaseDao中获取一个对象的方法</span></span><br><span class="line">		Book book = <span class="keyword">null</span>;</span><br><span class="line">		<span class="comment">// 写sql语句</span></span><br><span class="line">		String sql = <span class="string">&quot;select id,title,author,price,sales,stock,img_path imgPath from books where id = ?&quot;</span>;</span><br><span class="line">		book = getBean(conn,sql, bookId);</span><br><span class="line">		<span class="keyword">return</span> book;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateBook</span><span class="params">(Connection conn,Book book)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 写sql语句</span></span><br><span class="line">		String sql = <span class="string">&quot;update books set title = ? , author = ? , price = ? , sales = ? , stock = ? where id = ?&quot;</span>;</span><br><span class="line">		<span class="comment">// 调用BaseDao中通用的增删改的方法</span></span><br><span class="line">		update(conn,sql, book.getTitle(), book.getAuthor(), book.getPrice(), book.getSales(), book.getStock(), book.getId());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Page&lt;Book&gt; <span class="title">getPageBooks</span><span class="params">(Connection conn,Page&lt;Book&gt; page)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 获取数据库中图书的总记录数</span></span><br><span class="line">		String sql = <span class="string">&quot;select count(*) from books&quot;</span>;</span><br><span class="line">		<span class="comment">// 调用BaseDao中获取一个单一值的方法</span></span><br><span class="line">		<span class="keyword">long</span> totalRecord = (<span class="keyword">long</span>) getValue(conn,sql);</span><br><span class="line">		<span class="comment">// 将总记录数设置都page对象中</span></span><br><span class="line">		page.setTotalRecord((<span class="keyword">int</span>) totalRecord);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 获取当前页中的记录存放的List</span></span><br><span class="line">		String sql2 = <span class="string">&quot;select id,title,author,price,sales,stock,img_path imgPath from books limit ?,?&quot;</span>;</span><br><span class="line">		<span class="comment">// 调用BaseDao中获取一个集合的方法</span></span><br><span class="line">		List&lt;Book&gt; beanList = getBeanList(conn,sql2, (page.getPageNo() - <span class="number">1</span>) * Page.PAGE_SIZE, Page.PAGE_SIZE);</span><br><span class="line">		<span class="comment">// 将这个List设置到page对象中</span></span><br><span class="line">		page.setList(beanList);</span><br><span class="line">		<span class="keyword">return</span> page;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Page&lt;Book&gt; <span class="title">getPageBooksByPrice</span><span class="params">(Connection conn,Page&lt;Book&gt; page, <span class="keyword">double</span> minPrice, <span class="keyword">double</span> maxPrice)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 获取数据库中图书的总记录数</span></span><br><span class="line">		String sql = <span class="string">&quot;select count(*) from books where price between ? and ?&quot;</span>;</span><br><span class="line">		<span class="comment">// 调用BaseDao中获取一个单一值的方法</span></span><br><span class="line">		<span class="keyword">long</span> totalRecord = (<span class="keyword">long</span>) getValue(conn,sql,minPrice,maxPrice);</span><br><span class="line">		<span class="comment">// 将总记录数设置都page对象中</span></span><br><span class="line">		page.setTotalRecord((<span class="keyword">int</span>) totalRecord);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 获取当前页中的记录存放的List</span></span><br><span class="line">		String sql2 = <span class="string">&quot;select id,title,author,price,sales,stock,img_path imgPath from books where price between ? and ? limit ?,?&quot;</span>;</span><br><span class="line">		<span class="comment">// 调用BaseDao中获取一个集合的方法</span></span><br><span class="line">		List&lt;Book&gt; beanList = getBeanList(conn,sql2, minPrice , maxPrice , (page.getPageNo() - <span class="number">1</span>) * Page.PAGE_SIZE, Page.PAGE_SIZE);</span><br><span class="line">		<span class="comment">// 将这个List设置到page对象中</span></span><br><span class="line">		page.setList(beanList);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span> page;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="【UserDaoImpl-java】"><a href="#【UserDaoImpl-java】" class="headerlink" title="【UserDaoImpl.java】"></a>【UserDaoImpl.java】</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.bookstore.dao.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.atguigu.bookstore.beans.User;</span><br><span class="line"><span class="keyword">import</span> com.atguigu.bookstore.dao.BaseDao;</span><br><span class="line"><span class="keyword">import</span> com.atguigu.bookstore.dao.UserDao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDaoImpl</span> <span class="keyword">extends</span> <span class="title">BaseDao</span>&lt;<span class="title">User</span>&gt; <span class="keyword">implements</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> User <span class="title">getUser</span><span class="params">(Connection conn,User user)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 调用BaseDao中获取一个对象的方法</span></span><br><span class="line">		User bean = <span class="keyword">null</span>;</span><br><span class="line">		<span class="comment">// 写sql语句</span></span><br><span class="line">		String sql = <span class="string">&quot;select id,username,password,email from users where username = ? and password = ?&quot;</span>;</span><br><span class="line">		bean = getBean(conn,sql, user.getUsername(), user.getPassword());</span><br><span class="line">		<span class="keyword">return</span> bean;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkUsername</span><span class="params">(Connection conn,User user)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 调用BaseDao中获取一个对象的方法</span></span><br><span class="line">		User bean = <span class="keyword">null</span>;</span><br><span class="line">		<span class="comment">// 写sql语句</span></span><br><span class="line">		String sql = <span class="string">&quot;select id,username,password,email from users where username = ?&quot;</span>;</span><br><span class="line">		bean = getBean(conn,sql, user.getUsername());</span><br><span class="line">		<span class="keyword">return</span> bean != <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveUser</span><span class="params">(Connection conn,User user)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//写sql语句</span></span><br><span class="line">		String sql = <span class="string">&quot;insert into users(username,password,email) values(?,?,?)&quot;</span>;</span><br><span class="line">		<span class="comment">//调用BaseDao中通用的增删改的方法</span></span><br><span class="line">		update(conn,sql, user.getUsername(),user.getPassword(),user.getEmail());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="【Book-java】"><a href="#【Book-java】" class="headerlink" title="【Book.java】"></a>【Book.java】</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.bookstore.beans;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 图书类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> songhongkang</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Book</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> Integer id;</span><br><span class="line">	<span class="keyword">private</span> String title; <span class="comment">// 书名</span></span><br><span class="line">	<span class="keyword">private</span> String author; <span class="comment">// 作者</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">double</span> price; <span class="comment">// 价格</span></span><br><span class="line">	<span class="keyword">private</span> Integer sales; <span class="comment">// 销量</span></span><br><span class="line">	<span class="keyword">private</span> Integer stock; <span class="comment">// 库存</span></span><br><span class="line">	<span class="keyword">private</span> String imgPath = <span class="string">&quot;static/img/default.jpg&quot;</span>; <span class="comment">// 封面图片的路径</span></span><br><span class="line">	<span class="comment">//构造器，get()，set()，toString()方法略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="【Page-java】"><a href="#【Page-java】" class="headerlink" title="【Page.java】"></a>【Page.java】</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.bookstore.beans;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 页码类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> songhongkang</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Page</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> List&lt;T&gt; list; <span class="comment">// 每页查到的记录存放的集合</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PAGE_SIZE = <span class="number">4</span>; <span class="comment">// 每页显示的记录数</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> pageNo; <span class="comment">// 当前页</span></span><br><span class="line"><span class="comment">//	private int totalPageNo; // 总页数，通过计算得到</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> totalRecord; <span class="comment">// 总记录数，通过查询数据库得到</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="【User-java】"><a href="#【User-java】" class="headerlink" title="【User.java】"></a>【User.java】</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.bookstore.beans;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用户类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> songhongkang</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> Integer id;</span><br><span class="line">	<span class="keyword">private</span> String username;</span><br><span class="line">	<span class="keyword">private</span> String password;</span><br><span class="line">	<span class="keyword">private</span> String email;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="第8章：数据库连接池"><a href="#第8章：数据库连接池" class="headerlink" title="第8章：数据库连接池"></a>第8章：数据库连接池</h2><h3 id="8-1-JDBC数据库连接池的必要性"><a href="#8-1-JDBC数据库连接池的必要性" class="headerlink" title="8.1 JDBC数据库连接池的必要性"></a>8.1 JDBC数据库连接池的必要性</h3><ul>
<li><p>在使用开发基于数据库的web程序时，传统的模式基本是按以下步骤：　　</p>
<ul>
<li><strong>在主程序（如servlet、beans）中建立数据库连接</strong></li>
<li><strong>进行sql操作</strong></li>
<li><strong>断开数据库连接</strong></li>
</ul>
</li>
<li><p>这种模式开发，存在的问题:</p>
<ul>
<li>普通的JDBC数据库连接使用 DriverManager 来获取，每次向数据库建立连接的时候都要将 Connection 加载到内存中，再验证用户名和密码(得花费0.05s～1s的时间)。需要数据库连接的时候，就向数据库要求一个，执行完成后再断开连接。这样的方式将会消耗大量的资源和时间。<strong>数据库的连接资源并没有得到很好的重复利用。</strong>若同时有几百人甚至几千人在线，频繁的进行数据库连接操作将占用很多的系统资源，严重的甚至会造成服务器的崩溃。</li>
<li><strong>对于每一次数据库连接，使用完后都得断开。</strong>否则，如果程序出现异常而未能关闭，将会导致数据库系统中的内存泄漏，最终将导致重启数据库。（回忆：何为Java的内存泄漏？）</li>
<li><strong>这种开发不能控制被创建的连接对象数</strong>，系统资源会被毫无顾及的分配出去，如连接过多，也可能导致内存泄漏，服务器崩溃。 </li>
</ul>
</li>
</ul>
<h3 id="8-2-数据库连接池技术"><a href="#8-2-数据库连接池技术" class="headerlink" title="8.2 数据库连接池技术"></a>8.2 数据库连接池技术</h3><ul>
<li><p>为解决传统开发中的数据库连接问题，可以采用数据库连接池技术。</p>
</li>
<li><p><strong>数据库连接池的基本思想</strong>：就是为数据库连接建立一个“缓冲池”。预先在缓冲池中放入一定数量的连接，当需要建立数据库连接时，只需从“缓冲池”中取出一个，使用完毕之后再放回去。</p>
</li>
<li><p><strong>数据库连接池</strong>负责分配、管理和释放数据库连接，它<strong>允许应用程序重复使用一个现有的数据库连接，而不是重新建立一个</strong>。</p>
</li>
<li><p>数据库连接池在初始化时将创建一定数量的数据库连接放到连接池中，这些数据库连接的数量是由<strong>最小数据库连接数来设定</strong>的。无论这些数据库连接是否被使用，连接池都将一直保证至少拥有这么多的连接数量。连接池的<strong>最大数据库连接数量</strong>限定了这个连接池能占有的最大连接数，当应用程序向连接池请求的连接数超过最大连接数量时，这些请求将被加入到等待队列中。</p>
</li>
</ul>
<p><img src="https://gitee.com/zlpxiaokeai/img/raw/master/img/1555593464033.png" alt="1555593464033"></p>
<ul>
<li><strong>工作原理：</strong></li>
</ul>
<p><img src="https://gitee.com/zlpxiaokeai/img/raw/master/img/1555593598606.png" alt="1555593598606"></p>
<ul>
<li><p><strong>数据库连接池技术的优点</strong></p>
<p><strong>1. 资源重用</strong></p>
<p>由于数据库连接得以重用，避免了频繁创建，释放连接引起的大量性能开销。在减少系统消耗的基础上，另一方面也增加了系统运行环境的平稳性。</p>
<p><strong>2. 更快的系统反应速度</strong></p>
<p>数据库连接池在初始化过程中，往往已经创建了若干数据库连接置于连接池中备用。此时连接的初始化工作均已完成。对于业务请求处理而言，直接利用现有可用连接，避免了数据库连接初始化和释放过程的时间开销，从而减少了系统的响应时间</p>
<p><strong>3. 新的资源分配手段</strong></p>
<p>对于多应用共享同一数据库的系统而言，可在应用层通过数据库连接池的配置，实现某一应用最大可用数据库连接数的限制，避免某一应用独占所有的数据库资源</p>
<p><strong>4. 统一的连接管理，避免数据库连接泄漏</strong></p>
<p>在较为完善的数据库连接池实现中，可根据预先的占用超时设定，强制回收被占用连接，从而避免了常规数据库连接操作中可能出现的资源泄露</p>
</li>
</ul>
<h3 id="8-3-多种开源的数据库连接池"><a href="#8-3-多种开源的数据库连接池" class="headerlink" title="8.3 多种开源的数据库连接池"></a>8.3 多种开源的数据库连接池</h3><ul>
<li>JDBC 的数据库连接池使用 javax.sql.DataSource 来表示，DataSource 只是一个接口，该接口通常由服务器(Weblogic, WebSphere, Tomcat)提供实现，也有一些开源组织提供实现：<ul>
<li><strong>DBCP</strong> 是Apache提供的数据库连接池。tomcat 服务器自带dbcp数据库连接池。<strong>速度相对c3p0较快</strong>，但因自身存在BUG，Hibernate3已不再提供支持。</li>
<li><strong>C3P0</strong> 是一个开源组织提供的一个数据库连接池，<strong>速度相对较慢，稳定性还可以。</strong>hibernate官方推荐使用</li>
<li><strong>Proxool</strong> 是sourceforge下的一个开源项目数据库连接池，有监控连接池状态的功能，<strong>稳定性较c3p0差一点</strong></li>
<li><strong>BoneCP</strong> 是一个开源组织提供的数据库连接池，速度快</li>
<li><strong>Druid</strong> 是阿里提供的数据库连接池，据说是集DBCP 、C3P0 、Proxool 优点于一身的数据库连接池，但是速度不确定是否有BoneCP快</li>
</ul>
</li>
<li>DataSource 通常被称为数据源，它包含连接池和连接池管理两个部分，习惯上也经常把 DataSource 称为连接池</li>
<li><strong>DataSource用来取代DriverManager来获取Connection，获取速度快，同时可以大幅度提高数据库访问速度。</strong></li>
<li>特别注意：<ul>
<li>数据源和数据库连接不同，数据源无需创建多个，它是产生数据库连接的工厂，因此<strong>整个应用只需要一个数据源即可。</strong></li>
<li>当数据库访问结束后，程序还是像以前一样关闭数据库连接：conn.close(); 但conn.close()并没有关闭数据库的物理连接，它仅仅把数据库连接释放，归还给了数据库连接池。</li>
</ul>
</li>
</ul>
<h4 id="8-3-1-C3P0数据库连接池-选学"><a href="#8-3-1-C3P0数据库连接池-选学" class="headerlink" title="8.3.1 C3P0数据库连接池(选学)"></a>8.3.1 C3P0数据库连接池(选学)</h4><ul>
<li>获取连接方式一</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用C3P0数据库连接池的方式，获取数据库的连接：不推荐</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection1</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">	ComboPooledDataSource cpds = <span class="keyword">new</span> ComboPooledDataSource();</span><br><span class="line">	cpds.setDriverClass(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>); </span><br><span class="line">	cpds.setJdbcUrl(<span class="string">&quot;jdbc:mysql://localhost:3306/test&quot;</span>);</span><br><span class="line">	cpds.setUser(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">	cpds.setPassword(<span class="string">&quot;abc123&quot;</span>);</span><br><span class="line">		</span><br><span class="line"><span class="comment">//	cpds.setMaxPoolSize(100);</span></span><br><span class="line">	</span><br><span class="line">	Connection conn = cpds.getConnection();</span><br><span class="line">	<span class="keyword">return</span> conn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>获取连接方式二</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用C3P0数据库连接池的配置文件方式，获取数据库的连接：推荐</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> DataSource cpds = <span class="keyword">new</span> ComboPooledDataSource(<span class="string">&quot;helloc3p0&quot;</span>);</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection2</span><span class="params">()</span> <span class="keyword">throws</span> SQLException</span>&#123;</span><br><span class="line">	Connection conn = cpds.getConnection();</span><br><span class="line">	<span class="keyword">return</span> conn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，src下的配置文件为：【c3p0-config.xml】</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">c3p0-config</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">named-config</span> <span class="attr">name</span>=<span class="string">&quot;helloc3p0&quot;</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 获取连接的4个基本信息 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;user&quot;</span>&gt;</span>root<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>&gt;</span>abc123<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;jdbcUrl&quot;</span>&gt;</span>jdbc:mysql:///test<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClass&quot;</span>&gt;</span>com.mysql.jdbc.Driver<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">&lt;!-- 涉及到数据库连接池的管理的相关属性的设置 --&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 若数据库中连接数不足时, 一次向数据库服务器申请多少个连接 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;acquireIncrement&quot;</span>&gt;</span>5<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 初始化数据库连接池时连接的数量 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;initialPoolSize&quot;</span>&gt;</span>5<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 数据库连接池中的最小的数据库连接数 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;minPoolSize&quot;</span>&gt;</span>5<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 数据库连接池中的最大的数据库连接数 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxPoolSize&quot;</span>&gt;</span>10<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- C3P0 数据库连接池可以维护的 Statement 的个数 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxStatements&quot;</span>&gt;</span>20<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 每个连接同时可以使用的 Statement 对象的个数 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxStatementsPerConnection&quot;</span>&gt;</span>5<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;/<span class="name">named-config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">c3p0-config</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h4 id="8-3-2-DBCP数据库连接池-选学"><a href="#8-3-2-DBCP数据库连接池-选学" class="headerlink" title="8.3.2 DBCP数据库连接池(选学)"></a>8.3.2 DBCP数据库连接池(选学)</h4><ul>
<li>DBCP 是 Apache 软件基金组织下的开源连接池实现，该连接池依赖该组织下的另一个开源系统：Common-pool。如需使用该连接池实现，应在系统中增加如下两个 jar 文件：<ul>
<li>Commons-dbcp.jar：连接池的实现</li>
<li>Commons-pool.jar：连接池实现的依赖库</li>
</ul>
</li>
<li><strong>Tomcat 的连接池正是采用该连接池来实现的。</strong>该数据库连接池既可以与应用服务器整合使用，也可由应用程序独立使用。</li>
<li>数据源和数据库连接不同，数据源无需创建多个，它是产生数据库连接的工厂，因此整个应用只需要一个数据源即可。</li>
<li>当数据库访问结束后，程序还是像以前一样关闭数据库连接：conn.close(); 但上面的代码并没有关闭数据库的物理连接，它仅仅把数据库连接释放，归还给了数据库连接池。</li>
<li>配置属性说明</li>
</ul>
<table>
<thead>
<tr>
<th>属性</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>initialSize</td>
<td>0</td>
<td>连接池启动时创建的初始化连接数量</td>
</tr>
<tr>
<td>maxActive</td>
<td>8</td>
<td>连接池中可同时连接的最大的连接数</td>
</tr>
<tr>
<td>maxIdle</td>
<td>8</td>
<td>连接池中最大的空闲的连接数，超过的空闲连接将被释放，如果设置为负数表示不限制</td>
</tr>
<tr>
<td>minIdle</td>
<td>0</td>
<td>连接池中最小的空闲的连接数，低于这个数量会被创建新的连接。该参数越接近maxIdle，性能越好，因为连接的创建和销毁，都是需要消耗资源的；但是不能太大。</td>
</tr>
<tr>
<td>maxWait</td>
<td>无限制</td>
<td>最大等待时间，当没有可用连接时，连接池等待连接释放的最大时间，超过该时间限制会抛出异常，如果设置-1表示无限等待</td>
</tr>
<tr>
<td>poolPreparedStatements</td>
<td>false</td>
<td>开启池的Statement是否prepared</td>
</tr>
<tr>
<td>maxOpenPreparedStatements</td>
<td>无限制</td>
<td>开启池的prepared 后的同时最大连接数</td>
</tr>
<tr>
<td>minEvictableIdleTimeMillis</td>
<td></td>
<td>连接池中连接，在时间段内一直空闲， 被逐出连接池的时间</td>
</tr>
<tr>
<td>removeAbandonedTimeout</td>
<td>300</td>
<td>超过时间限制，回收没有用(废弃)的连接</td>
</tr>
<tr>
<td>removeAbandoned</td>
<td>false</td>
<td>超过removeAbandonedTimeout时间后，是否进 行没用连接（废弃）的回收</td>
</tr>
</tbody></table>
<ul>
<li>获取连接方式一：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection3</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">	BasicDataSource source = <span class="keyword">new</span> BasicDataSource();</span><br><span class="line">		</span><br><span class="line">	source.setDriverClassName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">	source.setUrl(<span class="string">&quot;jdbc:mysql:///test&quot;</span>);</span><br><span class="line">	source.setUsername(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">	source.setPassword(<span class="string">&quot;abc123&quot;</span>);</span><br><span class="line">		</span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	source.setInitialSize(<span class="number">10</span>);</span><br><span class="line">		</span><br><span class="line">	Connection conn = source.getConnection();</span><br><span class="line">	<span class="keyword">return</span> conn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>获取连接方式二：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用dbcp数据库连接池的配置文件方式，获取数据库的连接：推荐</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> DataSource source = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		Properties pros = <span class="keyword">new</span> Properties();</span><br><span class="line">		</span><br><span class="line">		InputStream is = DBCPTest.class.getClassLoader().getResourceAsStream(<span class="string">&quot;dbcp.properties&quot;</span>);</span><br><span class="line">			</span><br><span class="line">		pros.load(is);</span><br><span class="line">		<span class="comment">//根据提供的BasicDataSourceFactory创建对应的DataSource对象</span></span><br><span class="line">		source = BasicDataSourceFactory.createDataSource(pros);</span><br><span class="line">	&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">	&#125;</span><br><span class="line">		</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection4</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		</span><br><span class="line">	Connection conn = source.getConnection();</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> conn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，src下的配置文件为：【dbcp.properties】</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">driverClassName</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="attr">url</span>=<span class="string">jdbc:mysql://localhost:3306/test?rewriteBatchedStatements=true&amp;useServerPrepStmts=false</span></span><br><span class="line"><span class="attr">username</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">password</span>=<span class="string">abc123</span></span><br><span class="line"></span><br><span class="line"><span class="attr">initialSize</span>=<span class="string">10</span></span><br><span class="line"><span class="comment">#...</span></span><br></pre></td></tr></table></figure>



<h4 id="8-3-3-Druid（德鲁伊）数据库连接池"><a href="#8-3-3-Druid（德鲁伊）数据库连接池" class="headerlink" title="8.3.3 Druid（德鲁伊）数据库连接池"></a>8.3.3 Druid（德鲁伊）数据库连接池</h4><p>Druid是阿里巴巴开源平台上一个数据库连接池实现，它结合了C3P0、DBCP、Proxool等DB池的优点，同时加入了日志监控，可以很好的监控DB池连接和SQL的执行情况，可以说是针对监控而生的DB连接池，<strong>可以说是目前最好的连接池之一。</strong></p>
<p>方式一：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testConnection1</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">	DruidDataSource source = <span class="keyword">new</span> DruidDataSource();</span><br><span class="line">	</span><br><span class="line">	source.setUsername(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">	source.setPassword(<span class="string">&quot;abc123&quot;</span>);</span><br><span class="line">	source.setUrl(<span class="string">&quot;jdbc:mysql://localhost:3306/test&quot;</span>);</span><br><span class="line">	source.setDriverClassName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">	</span><br><span class="line">	source.setInitialSize(<span class="number">10</span>);</span><br><span class="line">	source.setMaxActive(<span class="number">100</span>);</span><br><span class="line">	</span><br><span class="line">	Connection conn = source.getConnection();</span><br><span class="line">	System.out.println(conn);</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方式二：使用配置文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.druid;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.sql.DataSource;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.druid.pool.DruidDataSourceFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDruid</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		Properties pro = <span class="keyword">new</span> Properties();		 pro.load(TestDruid.class.getClassLoader().getResourceAsStream(<span class="string">&quot;druid.properties&quot;</span>));</span><br><span class="line">		DataSource ds = DruidDataSourceFactory.createDataSource(pro);</span><br><span class="line">		Connection conn = ds.getConnection();</span><br><span class="line">		System.out.println(conn);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>其中，src下的配置文件为：【druid.properties】</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">url=jdbc:mysql:<span class="comment">//localhost:3306/test?rewriteBatchedStatements=true</span></span><br><span class="line">username=root</span><br><span class="line">password=<span class="number">123456</span></span><br><span class="line">driverClassName=com.mysql.jdbc.Driver</span><br><span class="line"></span><br><span class="line">initialSize=<span class="number">10</span></span><br><span class="line">maxActive=<span class="number">20</span></span><br><span class="line">maxWait=<span class="number">1000</span></span><br><span class="line">filters=wall</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<ul>
<li>详细配置参数：</li>
</ul>
<table>
<thead>
<tr>
<th><strong>配置</strong></th>
<th><strong>缺省</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td>username</td>
<td></td>
<td>连接数据库的用户名</td>
</tr>
<tr>
<td>password</td>
<td></td>
<td>连接数据库的密码。如果你不希望密码直接写在配置文件中，可以使用ConfigFilter。详细看这里：<a href="https://github.com/alibaba/druid/wiki/%E4%BD%BF%E7%94%A8ConfigFilter">https://github.com/alibaba/druid/wiki/%E4%BD%BF%E7%94%A8ConfigFilter</a></td>
</tr>
<tr>
<td>url</td>
<td></td>
<td>连接数据库的url，不同数据库不一样。例如：mysql :   jdbc:mysql://10.20.153.104:3306/druid2      oracle :   jdbc:oracle:thin:@10.20.149.85:1521:ocnauto</td>
</tr>
<tr>
<td>driverClassName</td>
<td></td>
<td>根据url自动识别   这一项可配可不配，如果不配置druid会根据url自动识别dbType，然后选择相应的driverClassName(建议配置下)</td>
</tr>
<tr>
<td>name</td>
<td></td>
<td>配置这个属性的意义在于，如果存在多个数据源，监控的时候可以通过名字来区分开来。   如果没有配置，将会生成一个名字，格式是：”DataSource-” +   System.identityHashCode(this)</td>
</tr>
<tr>
<td>initialSize</td>
<td>0</td>
<td>初始化时建立物理连接的个数。初始化发生在显示调用init方法，或者第一次getConnection时</td>
</tr>
<tr>
<td>maxActive</td>
<td>8</td>
<td>最大连接池数量</td>
</tr>
<tr>
<td>maxIdle</td>
<td>8</td>
<td>已经不再使用，配置了也没效果</td>
</tr>
<tr>
<td>minIdle</td>
<td></td>
<td>最小连接池数量</td>
</tr>
<tr>
<td>maxWait</td>
<td></td>
<td>获取连接时最大等待时间，单位毫秒。配置了maxWait之后，缺省启用公平锁，并发效率会有所下降，如果需要可以通过配置useUnfairLock属性为true使用非公平锁。</td>
</tr>
<tr>
<td>poolPreparedStatements</td>
<td>false</td>
<td>是否缓存preparedStatement，也就是PSCache。PSCache对支持游标的数据库性能提升巨大，比如说oracle。在mysql下建议关闭。</td>
</tr>
<tr>
<td>maxOpenPreparedStatements</td>
<td>-1</td>
<td>要启用PSCache，必须配置大于0，当大于0时，poolPreparedStatements自动触发修改为true。在Druid中，不会存在Oracle下PSCache占用内存过多的问题，可以把这个数值配置大一些，比如说100</td>
</tr>
<tr>
<td>validationQuery</td>
<td></td>
<td>用来检测连接是否有效的sql，要求是一个查询语句。如果validationQuery为null，testOnBorrow、testOnReturn、testWhileIdle都不会其作用。</td>
</tr>
<tr>
<td>testOnBorrow</td>
<td>true</td>
<td>申请连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。</td>
</tr>
<tr>
<td>testOnReturn</td>
<td>false</td>
<td>归还连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能</td>
</tr>
<tr>
<td>testWhileIdle</td>
<td>false</td>
<td>建议配置为true，不影响性能，并且保证安全性。申请连接的时候检测，如果空闲时间大于timeBetweenEvictionRunsMillis，执行validationQuery检测连接是否有效。</td>
</tr>
<tr>
<td>timeBetweenEvictionRunsMillis</td>
<td></td>
<td>有两个含义： 1)Destroy线程会检测连接的间隔时间2)testWhileIdle的判断依据，详细看testWhileIdle属性的说明</td>
</tr>
<tr>
<td>numTestsPerEvictionRun</td>
<td></td>
<td>不再使用，一个DruidDataSource只支持一个EvictionRun</td>
</tr>
<tr>
<td>minEvictableIdleTimeMillis</td>
<td></td>
<td></td>
</tr>
<tr>
<td>connectionInitSqls</td>
<td></td>
<td>物理连接初始化的时候执行的sql</td>
</tr>
<tr>
<td>exceptionSorter</td>
<td></td>
<td>根据dbType自动识别   当数据库抛出一些不可恢复的异常时，抛弃连接</td>
</tr>
<tr>
<td>filters</td>
<td></td>
<td>属性类型是字符串，通过别名的方式配置扩展插件，常用的插件有：   监控统计用的filter:stat日志用的filter:log4j防御sql注入的filter:wall</td>
</tr>
<tr>
<td>proxyFilters</td>
<td></td>
<td>类型是List，如果同时配置了filters和proxyFilters，是组合关系，并非替换关系</td>
</tr>
</tbody></table>
<h2 id="第9章：Apache-DBUtils实现CRUD操作"><a href="#第9章：Apache-DBUtils实现CRUD操作" class="headerlink" title="第9章：Apache-DBUtils实现CRUD操作"></a>第9章：Apache-DBUtils实现CRUD操作</h2><h3 id="9-1-Apache-DBUtils简介"><a href="#9-1-Apache-DBUtils简介" class="headerlink" title="9.1 Apache-DBUtils简介"></a>9.1 Apache-DBUtils简介</h3><ul>
<li><p>commons-dbutils 是 Apache 组织提供的一个开源 JDBC工具类库，它是对JDBC的简单封装，学习成本极低，并且使用dbutils能极大简化jdbc编码的工作量，同时也不会影响程序的性能。</p>
</li>
<li><p>API介绍：</p>
<ul>
<li>org.apache.commons.dbutils.QueryRunner</li>
<li>org.apache.commons.dbutils.ResultSetHandler</li>
<li>工具类：org.apache.commons.dbutils.DbUtils   </li>
</ul>
</li>
<li><p>API包说明：</p>
</li>
</ul>
<p><img src="https://gitee.com/zlpxiaokeai/img/raw/master/img/1555595163263.png" alt="1555595163263"></p>
<p><img src="https://gitee.com/zlpxiaokeai/img/raw/master/img/1555595198644.png" alt="1555595198644"></p>
<h3 id="9-2-主要API的使用"><a href="#9-2-主要API的使用" class="headerlink" title="9.2 主要API的使用"></a>9.2 主要API的使用</h3><h4 id="9-2-1-DbUtils"><a href="#9-2-1-DbUtils" class="headerlink" title="9.2.1 DbUtils"></a>9.2.1 DbUtils</h4><ul>
<li>DbUtils ：提供如关闭连接、装载JDBC驱动程序等常规工作的工具类，里面的所有方法都是静态的。主要方法如下：<ul>
<li><strong>public static void close(…) throws java.sql.SQLException</strong>：　DbUtils类提供了三个重载的关闭方法。这些方法检查所提供的参数是不是NULL，如果不是的话，它们就关闭Connection、Statement和ResultSet。</li>
<li>public static void closeQuietly(…): 这一类方法不仅能在Connection、Statement和ResultSet为NULL情况下避免关闭，还能隐藏一些在程序中抛出的SQLEeception。</li>
<li>public static void commitAndClose(Connection conn)throws SQLException： 用来提交连接的事务，然后关闭连接</li>
<li>public static void commitAndCloseQuietly(Connection conn)： 用来提交连接，然后关闭连接，并且在关闭连接时不抛出SQL异常。 </li>
<li>public static void rollback(Connection conn)throws SQLException：允许conn为null，因为方法内部做了判断</li>
<li>public static void rollbackAndClose(Connection conn)throws SQLException</li>
<li>rollbackAndCloseQuietly(Connection)</li>
<li>public static boolean loadDriver(java.lang.String driverClassName)：这一方装载并注册JDBC驱动程序，如果成功就返回true。使用该方法，你不需要捕捉这个异常ClassNotFoundException。</li>
</ul>
</li>
</ul>
<h4 id="9-2-2-QueryRunner类"><a href="#9-2-2-QueryRunner类" class="headerlink" title="9.2.2 QueryRunner类"></a>9.2.2 QueryRunner类</h4><ul>
<li><p><strong>该类简单化了SQL查询，它与ResultSetHandler组合在一起使用可以完成大部分的数据库操作，能够大大减少编码量。</strong></p>
</li>
<li><p>QueryRunner类提供了两个构造器：</p>
<ul>
<li>默认的构造器</li>
<li>需要一个 javax.sql.DataSource 来作参数的构造器</li>
</ul>
</li>
<li><p>QueryRunner类的主要方法：</p>
<ul>
<li><strong>更新</strong><ul>
<li>public int update(Connection conn, String sql, Object… params) throws SQLException:用来执行一个更新（插入、更新或删除）操作。</li>
<li> ……</li>
</ul>
</li>
<li><strong>插入</strong><ul>
<li>public <T> T insert(Connection conn,String sql,ResultSetHandler<T> rsh, Object… params) throws SQLException：只支持INSERT语句，其中 rsh - The handler used to create the result object from the ResultSet of auto-generated keys.  返回值: An object generated by the handler.即自动生成的键值</T></T></li>
<li>….</li>
</ul>
</li>
<li><strong>批处理</strong><ul>
<li>public int[] batch(Connection conn,String sql,Object[][] params)throws SQLException： INSERT, UPDATE, or DELETE语句</li>
<li>public <T> T insertBatch(Connection conn,String sql,ResultSetHandler<T> rsh,Object[][] params)throws SQLException：只支持INSERT语句</T></T></li>
<li>…..</li>
</ul>
</li>
<li><strong>查询</strong><ul>
<li>public Object query(Connection conn, String sql, ResultSetHandler rsh,Object… params) throws SQLException：执行一个查询操作，在这个查询中，对象数组中的每个元素值被用来作为查询语句的置换参数。该方法会自行处理 PreparedStatement 和 ResultSet 的创建和关闭。</li>
<li>…… </li>
</ul>
</li>
</ul>
</li>
<li><p>测试</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 测试添加</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testInsert</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">	QueryRunner runner = <span class="keyword">new</span> QueryRunner();</span><br><span class="line">	Connection conn = JDBCUtils.getConnection3();</span><br><span class="line">	String sql = <span class="string">&quot;insert into customers(name,email,birth)values(?,?,?)&quot;</span>;</span><br><span class="line">	<span class="keyword">int</span> count = runner.update(conn, sql, <span class="string">&quot;何成飞&quot;</span>, <span class="string">&quot;he@qq.com&quot;</span>, <span class="string">&quot;1992-09-08&quot;</span>);</span><br><span class="line"></span><br><span class="line">	System.out.println(<span class="string">&quot;添加了&quot;</span> + count + <span class="string">&quot;条记录&quot;</span>);</span><br><span class="line">		</span><br><span class="line">	JDBCUtils.closeResource(conn, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 测试删除</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testDelete</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">	QueryRunner runner = <span class="keyword">new</span> QueryRunner();</span><br><span class="line">	Connection conn = JDBCUtils.getConnection3();</span><br><span class="line">	String sql = <span class="string">&quot;delete from customers where id &lt; ?&quot;</span>;</span><br><span class="line">	<span class="keyword">int</span> count = runner.update(conn, sql,<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">	System.out.println(<span class="string">&quot;删除了&quot;</span> + count + <span class="string">&quot;条记录&quot;</span>);</span><br><span class="line">		</span><br><span class="line">	JDBCUtils.closeResource(conn, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="9-2-3-ResultSetHandler接口及实现类"><a href="#9-2-3-ResultSetHandler接口及实现类" class="headerlink" title="9.2.3 ResultSetHandler接口及实现类"></a>9.2.3 ResultSetHandler接口及实现类</h4><ul>
<li><p>该接口用于处理 java.sql.ResultSet，将数据按要求转换为另一种形式。</p>
</li>
<li><p>ResultSetHandler 接口提供了一个单独的方法：Object handle (java.sql.ResultSet .rs)。</p>
</li>
<li><p>接口的主要实现类：</p>
<ul>
<li>ArrayHandler：把结果集中的第一行数据转成对象数组。</li>
<li>ArrayListHandler：把结果集中的每一行数据都转成一个数组，再存放到List中。</li>
<li><strong>BeanHandler：</strong>将结果集中的第一行数据封装到一个对应的JavaBean实例中。</li>
<li><strong>BeanListHandler：</strong>将结果集中的每一行数据都封装到一个对应的JavaBean实例中，存放到List里。</li>
<li>ColumnListHandler：将结果集中某一列的数据存放到List中。</li>
<li>KeyedHandler(name)：将结果集中的每一行数据都封装到一个Map里，再把这些map再存到一个map里，其key为指定的key。</li>
<li><strong>MapHandler：</strong>将结果集中的第一行数据封装到一个Map里，key是列名，value就是对应的值。</li>
<li><strong>MapListHandler：</strong>将结果集中的每一行数据都封装到一个Map里，然后再存放到List</li>
<li><strong>ScalarHandler：</strong>查询单个值对象</li>
</ul>
</li>
<li><p>测试</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 测试查询:查询一条记录</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 使用ResultSetHandler的实现类：BeanHandler</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testQueryInstance</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">	QueryRunner runner = <span class="keyword">new</span> QueryRunner();</span><br><span class="line"></span><br><span class="line">	Connection conn = JDBCUtils.getConnection3();</span><br><span class="line">		</span><br><span class="line">	String sql = <span class="string">&quot;select id,name,email,birth from customers where id = ?&quot;</span>;</span><br><span class="line">		</span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	BeanHandler&lt;Customer&gt; handler = <span class="keyword">new</span> BeanHandler&lt;&gt;(Customer.class);</span><br><span class="line">	Customer customer = runner.query(conn, sql, handler, <span class="number">23</span>);</span><br><span class="line">	System.out.println(customer);	</span><br><span class="line">	JDBCUtils.closeResource(conn, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 测试查询:查询多条记录构成的集合</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 使用ResultSetHandler的实现类：BeanListHandler</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testQueryList</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">	QueryRunner runner = <span class="keyword">new</span> QueryRunner();</span><br><span class="line"></span><br><span class="line">	Connection conn = JDBCUtils.getConnection3();</span><br><span class="line">		</span><br><span class="line">	String sql = <span class="string">&quot;select id,name,email,birth from customers where id &lt; ?&quot;</span>;</span><br><span class="line">		</span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	BeanListHandler&lt;Customer&gt; handler = <span class="keyword">new</span> BeanListHandler&lt;&gt;(Customer.class);</span><br><span class="line">	List&lt;Customer&gt; list = runner.query(conn, sql, handler, <span class="number">23</span>);</span><br><span class="line">	list.forEach(System.out::println);</span><br><span class="line">		</span><br><span class="line">	JDBCUtils.closeResource(conn, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 自定义ResultSetHandler的实现类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testQueryInstance1</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">	QueryRunner runner = <span class="keyword">new</span> QueryRunner();</span><br><span class="line"></span><br><span class="line">	Connection conn = JDBCUtils.getConnection3();</span><br><span class="line">		</span><br><span class="line">	String sql = <span class="string">&quot;select id,name,email,birth from customers where id = ?&quot;</span>;</span><br><span class="line">		</span><br><span class="line">	ResultSetHandler&lt;Customer&gt; handler = <span class="keyword">new</span> ResultSetHandler&lt;Customer&gt;() &#123;</span><br><span class="line"></span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> Customer <span class="title">handle</span><span class="params">(ResultSet rs)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;handle&quot;</span>);</span><br><span class="line"><span class="comment">//			return new Customer(1,&quot;Tom&quot;,&quot;tom@126.com&quot;,new Date(123323432L));</span></span><br><span class="line">				</span><br><span class="line">			<span class="keyword">if</span>(rs.next())&#123;</span><br><span class="line">				<span class="keyword">int</span> id = rs.getInt(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">				String name = rs.getString(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">				String email = rs.getString(<span class="string">&quot;email&quot;</span>);</span><br><span class="line">				Date birth = rs.getDate(<span class="string">&quot;birth&quot;</span>);</span><br><span class="line">					</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">new</span> Customer(id, name, email, birth);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">				</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">		</span><br><span class="line">	Customer customer = runner.query(conn, sql, handler, <span class="number">23</span>);</span><br><span class="line">		</span><br><span class="line">	System.out.println(customer);</span><br><span class="line">		</span><br><span class="line">	JDBCUtils.closeResource(conn, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 如何查询类似于最大的，最小的，平均的，总和，个数相关的数据，</span></span><br><span class="line"><span class="comment"> * 使用ScalarHandler</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testQueryValue</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">	QueryRunner runner = <span class="keyword">new</span> QueryRunner();</span><br><span class="line"></span><br><span class="line">	Connection conn = JDBCUtils.getConnection3();</span><br><span class="line">		</span><br><span class="line">	<span class="comment">//测试一：</span></span><br><span class="line"><span class="comment">//	String sql = &quot;select count(*) from customers where id &lt; ?&quot;;</span></span><br><span class="line"><span class="comment">//	ScalarHandler handler = new ScalarHandler();</span></span><br><span class="line"><span class="comment">//	long count = (long) runner.query(conn, sql, handler, 20);</span></span><br><span class="line"><span class="comment">//	System.out.println(count);</span></span><br><span class="line">		</span><br><span class="line">	<span class="comment">//测试二：</span></span><br><span class="line">	String sql = <span class="string">&quot;select max(birth) from customers&quot;</span>;</span><br><span class="line">	ScalarHandler handler = <span class="keyword">new</span> ScalarHandler();</span><br><span class="line">	Date birth = (Date) runner.query(conn, sql, handler);</span><br><span class="line">	System.out.println(birth);</span><br><span class="line">		</span><br><span class="line">	JDBCUtils.closeResource(conn, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="JDBC总结"><a href="#JDBC总结" class="headerlink" title="JDBC总结"></a>JDBC总结</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">总结</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testUpdateWithTx</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">	Connection conn = <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="comment">//1.获取连接的操作（</span></span><br><span class="line">		<span class="comment">//① 手写的连接：JDBCUtils.getConnection();</span></span><br><span class="line">		<span class="comment">//② 使用数据库连接池：C3P0;DBCP;Druid</span></span><br><span class="line">		<span class="comment">//2.对数据表进行一系列CRUD操作</span></span><br><span class="line">		<span class="comment">//① 使用PreparedStatement实现通用的增删改、查询操作（version 1.0 \ version 2.0)</span></span><br><span class="line"><span class="comment">//version2.0的增删改public void update(Connection conn,String sql,Object ... args)&#123;&#125;</span></span><br><span class="line"><span class="comment">//version2.0的查询 public &lt;T&gt; T getInstance(Connection conn,Class&lt;T&gt; clazz,String sql,Object ... args)&#123;&#125;</span></span><br><span class="line">		<span class="comment">//② 使用dbutils提供的jar包中提供的QueryRunner类</span></span><br><span class="line">			</span><br><span class="line">		<span class="comment">//提交数据</span></span><br><span class="line">		conn.commit();</span><br><span class="line">			</span><br><span class="line">	</span><br><span class="line">	&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">			</span><br><span class="line">			</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">//回滚数据</span></span><br><span class="line">			conn.rollback();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (SQLException e1) &#123;</span><br><span class="line">			e1.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">			</span><br><span class="line">	&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">		<span class="comment">//3.关闭连接等操作</span></span><br><span class="line">		<span class="comment">//① JDBCUtils.closeResource();</span></span><br><span class="line">		<span class="comment">//② 使用dbutils提供的jar包中提供的DbUtils类提供了关闭的相关操作</span></span><br><span class="line">			</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>jdbc</category>
      </categories>
      <tags>
        <tag>jdbc</tag>
      </tags>
  </entry>
  <entry>
    <title>搭建自己的个人博客</title>
    <url>/2021/09/01/%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<p>用hexo和github搭建自己的个人博客</p>
<span id="more"></span>



<h1 id="环境安装"><a href="#环境安装" class="headerlink" title="环境安装"></a>环境安装</h1><ol>
<li>git</li>
<li>node.js</li>
<li>hexo</li>
</ol>
<h2 id="安装git"><a href="#安装git" class="headerlink" title="安装git"></a>安装git</h2><p>直接在点击下面链接下载安装。然后按照步骤安装即可。</p>
<p><a href="https://git-scm.com/">https://git-scm.com/</a></p>
<h2 id="安装node-js"><a href="#安装node-js" class="headerlink" title="安装node.js"></a>安装node.js</h2><p>同样点击下面链接下载安装。然后按照步骤安装即可。</p>
<p><a href="https://nodejs.org/en/download/">https://nodejs.org/en/download/</a></p>
<h2 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h2><p>通过下面命令进行安装</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure>

<p>执行以下命令确认hexo已安装好，该命令会显示hexo的版本及依赖的包。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo -v</span><br></pre></td></tr></table></figure>

<p>如果安装好则会显示以下信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo-cli: 4.3.0</span><br><span class="line">os: win32 10.0.18362</span><br><span class="line">node: 16.8.0</span><br><span class="line">v8: 9.2.230.21-node.20</span><br><span class="line">uv: 1.42.0</span><br><span class="line">zlib: 1.2.11</span><br><span class="line">brotli: 1.0.9</span><br><span class="line">ares: 1.17.2</span><br><span class="line">modules: 93</span><br><span class="line">nghttp2: 1.42.0</span><br><span class="line">napi: 8</span><br><span class="line">llhttp: 6.0.2</span><br><span class="line">openssl: 1.1.1k+quic</span><br><span class="line">cldr: 39.0</span><br><span class="line">icu: 69.1</span><br><span class="line">tz: 2021a</span><br><span class="line">unicode: 13.0</span><br><span class="line">ngtcp2: 0.1.0-DEV</span><br><span class="line">nghttp3: 0.1.0-DEV</span><br></pre></td></tr></table></figure>

<h1 id="hexo创建博客"><a href="#hexo创建博客" class="headerlink" title="hexo创建博客"></a>hexo创建博客</h1><p>创建一个空白文件夹blog，作为博客根目录，在该根目录下，运行cmd窗口.</p>
<p>注意文件夹必须为空</p>
<p><img src="https://gitee.com/zlpxiaokeai/img/raw/master/img/image-20210903145523286.png" alt="image-20210903145523286"></p>
<p>然后执行如下命令初始化，执行以下命令初始化博客。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo init</span><br></pre></td></tr></table></figure>

<p>分别执行下面命令，启动服务。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo cl #清除缓存文件 (db.json) 和已生成的静态文件 (public)</span><br><span class="line">hexo g  #生成静态网站文件</span><br><span class="line">hexo s  #启动服务器。默认情况下，访问网址为： http://localhost:4000/</span><br></pre></td></tr></table></figure>

<p>默认是4000端口，在浏览器输入<a href="http://localhost:4000就可以访问默认博客了">http://localhost:4000就可以访问默认博客了</a></p>
<p>到此默认的hexo博客就建立好了,但是大家一般会使用其他主题来使得博客更加好看,下面介绍next主题.</p>
<p>更多hexo命令解释请看<a href="https://hexo.io/zh-cn/docs/commands.html#server">https://hexo.io/zh-cn/docs/commands.html#server</a></p>
<h1 id="next主题"><a href="#next主题" class="headerlink" title="next主题"></a>next主题</h1><p>使用如下git指令下载NexT最新的主题文件(注意要在博客目录下运行cmd窗口执行如下命令)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/theme-next/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure>

<p>现在Hexo中有两份主要的配置文件，其名称都是_config.yml。 其中，一份位于站点根目录下，主要包含Hexo本身的配置；另一份位于next主题目录下，主要用于配置主题相关的选项。将前者称为站点配置文件， 后者称为主题配置文件。</p>
<h2 id="站点文件配置"><a href="#站点文件配置" class="headerlink" title="站点文件配置"></a>站点文件配置</h2><p>找到站点的_config.yml文件,修改其中如下的值。</p>
<p><img src="https://gitee.com/zlpxiaokeai/img/raw/master/img/image-20210903154538650.png" alt="image-20210903154538650"></p>
<table>
<thead>
<tr>
<th><code>title</code></th>
<th>网站标题</th>
</tr>
</thead>
<tbody><tr>
<td><code>subtitle</code></td>
<td>网站副标题</td>
</tr>
<tr>
<td><code>description</code></td>
<td>网站描述</td>
</tr>
<tr>
<td><code>keywords</code></td>
<td>网站的关键词。支持多个关键词。</td>
</tr>
<tr>
<td><code>author</code></td>
<td>您的名字</td>
</tr>
<tr>
<td><code>language</code></td>
<td>网站使用的语言。对于简体中文用户来说，使用不同的主题可能需要设置成不同的值，请参考你的主题的文档自行设置，常见的有 <code>zh-Hans</code>和 <code>zh-CN</code>。</td>
</tr>
<tr>
<td><code>timezone</code></td>
<td>网站时区。Hexo 默认使用您电脑的时区。请参考 <a href="https://en.wikipedia.org/wiki/List_of_tz_database_time_zones">时区列表</a> 进行设置，如 <code>America/New_York</code>, <code>Japan</code>, 和 <code>UTC</code> 。一般的，对于中国大陆地区可以使用 <code>Asia/Shanghai</code>。</td>
</tr>
</tbody></table>
<h2 id="站点文件配置-1"><a href="#站点文件配置-1" class="headerlink" title="站点文件配置"></a>站点文件配置</h2><h3 id="菜单项"><a href="#菜单项" class="headerlink" title="菜单项"></a>菜单项</h3><p>菜单配置包括三个部分，第一是菜单项（名称和链接），第二是菜单项的显示文本，第三是菜单项对应的图标。 </p>
<p><img src="https://gitee.com/zlpxiaokeai/img/raw/master/img/image-20210903154935622.png" alt="image-20210903154935622"></p>
<h3 id="初始化对应的Menu文件夹"><a href="#初始化对应的Menu文件夹" class="headerlink" title="初始化对应的Menu文件夹"></a>初始化对应的Menu文件夹</h3><p>配置完菜单之后,还要在终端中输入（前提在<strong>Hexo</strong>文件路径下）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo new page &quot;categories&quot;</span><br></pre></td></tr></table></figure>

<p>否则会出现</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Cannot GET/xxx 错误</span><br></pre></td></tr></table></figure>

<p>同时还要在<code>blog/source/categories</code>中<strong>index.md</strong>文件，添加<code>type: categories</code>，</p>
<p><img src="https://gitee.com/zlpxiaokeai/img/raw/master/img/image-20210903155908305.png" alt="image-20210903155908305"></p>
<p>其他菜单项目也同理创建。</p>
<h3 id="next四种主题"><a href="#next四种主题" class="headerlink" title="next四种主题"></a>next四种主题</h3><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"># Schemes</span><br><span class="line">#scheme: Muse</span><br><span class="line">scheme: Mist</span><br><span class="line">#scheme: Pisces</span><br><span class="line">#scheme: Gemini</span><br></pre></td></tr></table></figure>

<p>选择其中一个就行,我选择的是Mist</p>
<h3 id="设置头像"><a href="#设置头像" class="headerlink" title="设置头像"></a>设置头像</h3><p>编辑 <strong>主题配置文件</strong>， 修改字段 <code>avatar</code>， 值设置成头像的链接地址，图片可以传到next/source/uploads目录下。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">avatar: /uploads/avatar.jpg</span><br></pre></td></tr></table></figure>



<h3 id="字数统计-阅读时长"><a href="#字数统计-阅读时长" class="headerlink" title="字数统计+阅读时长"></a>字数统计+阅读时长</h3><ol>
<li>安装hexo-wordcount</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm i --save hexo-wordcount</span><br></pre></td></tr></table></figure>

<ol>
<li>配置主题文件</li>
</ol>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">post_wordcount:</span><br><span class="line">  item_text: <span class="literal">true</span></span><br><span class="line">  wordcount: <span class="literal">true</span></span><br><span class="line">  min2read: <span class="literal">true</span></span><br><span class="line">  totalcount: <span class="literal">true</span></span><br><span class="line">  separated_meta: <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h3 id="阅读更多"><a href="#阅读更多" class="headerlink" title="阅读更多"></a>阅读更多</h3><p>在首页显示一篇文章的部分内容，并提供一个链接跳转到全文页面是一个常见的需求。在xxx.md的文章中使用</p>
<p>使用下面标签即可，在标签之前的会在主页显示，标签之后的则在点击阅读更多之后显示。</p>
<p><img src="https://gitee.com/zlpxiaokeai/img/raw/master/img/image-20210903160122768.png" alt="image-20210903160122768"></p>
<h1 id="修改文章目录导航"><a href="#修改文章目录导航" class="headerlink" title="修改文章目录导航"></a>修改文章目录导航</h1><h2 id="取消数字编号"><a href="#取消数字编号" class="headerlink" title="取消数字编号"></a>取消数字编号</h2><p>在主题配置文件中关闭目录中的数字编号：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">themes\next\_config.ymltoc:</span><br><span class="line">  number: false  # 关闭目录中的数字编号</span><br></pre></td></tr></table></figure>

<h2 id="展开全部目录层级"><a href="#展开全部目录层级" class="headerlink" title="展开全部目录层级"></a>展开全部目录层级</h2><p>默认情况下文章的多级目录是折叠的，点击才会触发下级菜单的展开，并且并且同时只能展开一个目录分支，这会造成在点击不同目录标题的时候目录跳来跳去。如果你想实现默认展开全部目录的功能，可以在自定义样式文件中添加以下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">themes\next\source\css\_custom\custom.styl//TOC目录默认全部展开</span><br><span class="line">.post-toc .nav .nav-child &#123;</span><br><span class="line">  display: block;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="默认展开两级目录"><a href="#默认展开两级目录" class="headerlink" title="默认展开两级目录"></a>默认展开两级目录</h2><p>通常文章内会出现多级标题，对应的目录里就会有多级导航出现，这时候一些原本你不希望出现的次要标题也会在目录中出现并且无法折叠。可以通过以下样式实现默认只展开两级目录，这样以来就通过一个折中的方案完美解决了目录折叠的问题。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">themes\next\source\css\_custom\custom.styl//TOC目录默认展开两级</span><br><span class="line">.post-toc .nav .nav-level-1&gt;.nav-child &#123;</span><br><span class="line">  display: block;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="只显示两级目录"><a href="#只显示两级目录" class="headerlink" title="只显示两级目录"></a>只显示两级目录</h2><p>如果你根本不想让三级及以上的标题出现 TOC 导航目录中，可以考虑在自定义样式文件中添加以下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">themes\next\source\css\_custom\custom.styl//TOC目录默认只显示两级目录</span><br><span class="line">.nav-level-2 &gt; .nav-child &#123;</span><br><span class="line">  display: none !important;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="主动隐藏文章目录"><a href="#主动隐藏文章目录" class="headerlink" title="主动隐藏文章目录"></a>主动隐藏文章目录</h2><p>如果你写了一篇并不算长的文章，没有层层嵌套的多级目录结构，此时侧边的文章目录空荡荡的就有点鸡肋了。修改侧边栏布局模板中的相关逻辑代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">themes\next\layout\_macro\sidebar.swig- &#123;% set display_toc = is_post and theme.toc.enable %&#125;</span><br><span class="line">+ &#123;% set display_toc = is_post and theme.toc.enable and not page.hide_toc %&#125;</span><br></pre></td></tr></table></figure>

<p>然后就可在 Front-Matter 中设定变量 hide_toc 用于控制是否隐藏侧边目录</p>
<h1 id="Mist外观下，修改侧边栏在左边"><a href="#Mist外观下，修改侧边栏在左边" class="headerlink" title="Mist外观下，修改侧边栏在左边"></a>Mist外观下，修改侧边栏在左边</h1><p>参考：</p>
<ul>
<li><p><a href="https://blog.fish-404.icu/Blog-adjust-sidebar-nextmist-left/">Blog-调整NexT主题Mist外观侧边栏在左</a></p>
</li>
<li><p><a href="http://mashirosorata.vicp.io/HEXO-NEXT%E4%B8%BB%E9%A2%98%E4%B8%AA%E6%80%A7%E5%8C%96%E9%85%8D%E7%BD%AE.html">HEXO+NEXT主题个性化配置|SORA</a></p>
</li>
</ul>
<p>在NexT主题的Mist外观下，侧边栏默认在右，而只有在<code>Pisces</code>，<code>Gemini</code>这两种外观下才可以通过<code>_config.yml</code>直接修改选择左侧或是右侧。</p>
<p>在此过程中需要修改如下几个文件：</p>
<ul>
<li>sidebar.styl</li>
<li>sidebar-toggle.styl</li>
<li>back-to-top.styl</li>
<li>motion.js</li>
</ul>
<p> <strong>1.sidebar.styl</strong></p>
<p>路径：<code>.\themes\next\source\css\_common\components\sidebar\</code><br>将此文件的第3行<code>right</code>改为<code>left</code></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.sidebar</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: fixed;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p><strong>2.sidebar-toggle.styl</strong></p>
<p>路径：<code>.\themes\next\source\css\_common\components\sidebar\</code><br>同样将第3行冒号前的<code>right</code>改为<code>left</code></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">left</span>: $b2t-position-right;</span><br></pre></td></tr></table></figure>

<p><strong>3.back-to-top.styl</strong></p>
<p>路径：<code>.\themes\next\source\css\_common\components\</code><br>将第5行冒号前的<code>right</code>改为<code>left</code></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">left</span>: $b2t-position-right;</span><br></pre></td></tr></table></figure>

<p><strong>4.motion.js</strong></p>
<p>路径：<code>.\themes\next\source\js\src\motion.js</code><br>利用搜索功能找到改文档中的<code>paddingRight</code>字段，将<code>paddingRight</code>改为<code>paddingLeft</code>(共两处)。</p>
<p>重新部署即可完成侧边栏在左的设置。</p>
<p><strong>修改窗口缩小bug</strong></p>
<p>仅使用上面的方案情况下，如果侧边栏的设置是展开状态，在浏览器窗口缩小时会导致侧边栏仍然存在且占据相当大的位置。做以下调整。</p>
<p>找到<code>./themes/source/js/src/motion.js</code>文件，在<code>$(document).ready(function ()&#123;&#125;)</code>内添加内容：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">window</span>.onload=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	    <span class="keyword">var</span> bwol=<span class="built_in">document</span>.body.offsetWidth;</span><br><span class="line">	    <span class="keyword">if</span>(bwol &lt; <span class="number">975</span>)&#123;</span><br><span class="line">		$(<span class="string">&#x27;aside#sidebar&#x27;</span>).css(<span class="string">&quot;display&quot;</span>,<span class="string">&quot;none&quot;</span>);</span><br><span class="line">		$(<span class="string">&#x27;body&#x27;</span>).css(<span class="string">&quot;paddingLeft&quot;</span>,<span class="string">&quot;0px&quot;</span>);</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">window</span>.onresize = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	    <span class="keyword">var</span> bwos=<span class="built_in">document</span>.body.offsetWidth;</span><br><span class="line">	    bwos &lt; <span class="number">975</span> &amp;&amp; $(<span class="string">&#x27;body&#x27;</span>).velocity(<span class="string">&#x27;stop&#x27;</span>).velocity(&#123;<span class="attr">paddingLeft</span>: <span class="number">0</span>&#125;,<span class="number">0</span>);</span><br><span class="line">	    <span class="keyword">if</span>($(<span class="string">&#x27;aside#sidebar&#x27;</span>).css(<span class="string">&#x27;display&#x27;</span>) != <span class="string">&#x27;none&#x27;</span> &amp;&amp; $(<span class="string">&#x27;aside#sidebar&#x27;</span>).css(<span class="string">&#x27;width&#x27;</span>)!=<span class="string">&#x27;0px&#x27;</span>)</span><br><span class="line">		$(<span class="string">&#x27;body&#x27;</span>).velocity(<span class="string">&#x27;stop&#x27;</span>).velocity(&#123;<span class="attr">paddingLeft</span>: <span class="number">350</span>&#125;,<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	   NexT.motion = &#123;&#125;;</span><br><span class="line">	   </span><br><span class="line">	   ...</span><br></pre></td></tr></table></figure>

<h1 id="Hexo博客显示图片办法"><a href="#Hexo博客显示图片办法" class="headerlink" title="Hexo博客显示图片办法"></a>Hexo博客显示图片办法</h1><h2 id="方法一-使用typora-Picgo-gitee"><a href="#方法一-使用typora-Picgo-gitee" class="headerlink" title="方法一 使用typora+Picgo+gitee"></a>方法一 使用typora+Picgo+gitee</h2><a href="/2021/09/03/Typora+PicGo-Core%E5%BB%BA%E7%AB%8B%E5%9B%BE%E5%BA%8A/" title="使用typora+Picgo+gitee 建立图床,显示hexo博客中图片">使用typora+Picgo+gitee 建立图床,显示hexo博客中图片</a>

<h2 id="方法二-建立同名文件夹"><a href="#方法二-建立同名文件夹" class="headerlink" title="方法二   建立同名文件夹"></a>方法二   建立同名文件夹</h2><ol>
<li><p>修改博客配置。</p>
<p>修改博客根目录中<code>_config.yml</code>文件的配置项<code>post_asset_folder</code>为<code>true</code>：</p>
<p>2.通过<code>hexo new xxx</code>新建博客后，会产生一个和文件同名的文件夹。(或者自己建立一个xxx.md文件和xxx文件夹)</p>
</li>
</ol>
<p><img src="https://gitee.com/zlpxiaokeai/img/raw/master/img/image-20210903145943342.png" alt="image-20210903145943342"></p>
<p>在博客根目录中下使用npm安装插件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install https://github.com/CodeFalling/hexo-asset-image --save</span><br></pre></td></tr></table></figure>

<p>当文章需要添加图片时，将需要添加的图片放入同名的文件夹中，使用相对位置索引到该图片,如下所示.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">![示例](./xxxx/a.png)</span><br></pre></td></tr></table></figure>

<h1 id="站内文章引用"><a href="#站内文章引用" class="headerlink" title="站内文章引用"></a>站内文章引用</h1><p>在写文章的过程中，有时候需要引用站内的其他文章。可以通过内置的标签插件的语法<code>post_link</code>来实现引用。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% post_link 文章文件名（不要后缀） 文章标题（可选） %&#125;</span><br></pre></td></tr></table></figure>

<p> 引用 xxx.md</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% post_link xxx %&#125;</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% post_link xxx 要显示的内容 %&#125;</span><br></pre></td></tr></table></figure>

<p>要显示的内容不写,默认显示标题</p>
<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><h2 id="next5中文目录点击无法跳转问题"><a href="#next5中文目录点击无法跳转问题" class="headerlink" title="next5中文目录点击无法跳转问题"></a>next5中文目录点击无法跳转问题</h2><p><strong>解决方案</strong></p>
<p>这个错误很明显，因为控制台已经告诉我错误代码在 <code>post-details.js</code>里了，顺着提示找到 <code>themes\next\source\js\src\post-details.js</code>，找到第 73 行为目录绑定点击事件的方法，会看到：</p>
<p>[<img src="https://gitee.com/zlpxiaokeai/img/raw/master/img/image-20201217170155109.png" alt="image-20201217170155109"></p>
<p>添加如下代码即可:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对获取到的url进行重编码</span></span><br><span class="line">targetSelector = <span class="built_in">decodeURI</span>(<span class="built_in">this</span>.getAttribute(<span class="string">&#x27;href&#x27;</span>))</span><br></pre></td></tr></table></figure>

<p>然后 <code>hexo clean &amp;&amp; hexo g &amp;&amp; hexo s</code> 重新跑一下，发现目录就正常了。</p>
]]></content>
      <categories>
        <category>博客</category>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>文本文件与二进制文件的区别</title>
    <url>/2021/09/04/%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6%E4%B8%8E%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h1 id="文本文件与二进制文件的定义"><a href="#文本文件与二进制文件的定义" class="headerlink" title="文本文件与二进制文件的定义"></a>文本文件与二进制文件的定义</h1><p>计算机的存储在物理上是二进制的，所以<strong>文本文件与二进制文件的区别并不是物理上的，而是逻辑上的</strong>。这两者只是在编码层次上有差异。简单来说，</p>
<ul>
<li>文本文件是基于字符编码的文件，常见的编码有ASCII编码，UNICODE编码等等。</li>
<li>二进制文件是基于值编码的文件，你可以根据具体应用，指定某个值是什么意思（这样一个过程，可以看作是自定义编码与解码的过程）。</li>
</ul>
<span id="more"></span>

<h1 id="文本文件与二进制文件的区别"><a href="#文本文件与二进制文件的区别" class="headerlink" title="文本文件与二进制文件的区别"></a>文本文件与二进制文件的区别</h1><p>文本文件：</p>
<ol>
<li>基本上是定长编码的(也有非定长的编码如UTF-8)。</li>
</ol>
<p>二进制文件：</p>
<ol>
<li>二进制文件可看成是变长编码的，因为是值编码嘛，多少个比特代表一个值，完全由决定。</li>
</ol>
<p>文本文件的存储与其读取基本上是个逆过程。而二进制文件的存取显然与文本文件的存取差不多，只是编／解码方式不同而已</p>
<p>参考:<a href="https://blog.csdn.net/colourful_sky/article/details/80334250">文本文件和二进制文件的差异和区别</a></p>
]]></content>
      <categories>
        <category>文件</category>
      </categories>
      <tags>
        <tag>文本文件</tag>
        <tag>二进制文件</tag>
      </tags>
  </entry>
</search>
